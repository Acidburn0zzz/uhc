%%[20
preamble tex "%include lhs2TeX.fmt\n%include afp.fmt\n%include ehrules.fmt\n"

external Ty_Int
external empty

viewhierarchy = B < E0 < E1 < E2 < E < U1, B < E0 < E1 < EL < UL, B < D < DC, B < E0 < E1 < E2 < EX < UX, B < E0 < E1 < L

data Expr [expr]
  view E0
    | Var  [e.var]  ident :: HsName
  view E1
    | Int  [e.int]  n     :: Int
    | App  [e.app]  f     :: Expr
                    a     :: Expr
    | Lam  [e.lam]  ident :: HsName
                    body  :: Expr
  view E2
    | Plus [e.plus] a     :: Expr
                    b     :: Expr
  view EL
    | Let  [e.let]  n     :: Int
                    ident :: HsName
                    expr  :: Expr
                    body  :: Expr

data Prog [prog]
  view U1
    | Prog [p] e   :: Expr
               uty :: Ty

data Tp [ty]
  view D
    | Con  [d.con] ident :: HsName
    | Var  [d.var] ident :: HsName
    | Ann  [d.ann] ann   :: Annotation
                   tp    :: Tp
    | App  [d.app] f     :: Tp
                   a     :: Tp

data Data [dt]
  view D
    | Data [dt] ident   :: HsName
                tyvars  :: Tyvars
                constrs :: Constrs

data Constr [constr]
  view D
    | Constr [constr]  ident :: HsName
                       tps   :: Tp

format tex Ty_Int = Int
format tex Gam = Gamma
format tex gam = Gamma
format tex ty = tau
format tex uty = utau
format tex utyA = utau
format tex utyB = utau
format tex empty = emptyset
format tex cs = zeta
format tex Cs = zeta
format tex bcs = omega
format tex Bcs = omega
format tex addme = "\\+/"
format tex dots = "..."

scheme expr "Expr" =
  view E =
    holes [ e: Expr, gam: Gam, ty: Ty ]
    judgespec gam :- e : ty
    judgeuse tex gam :-..type e : ty
    explain (Within environment |gam| , |e| has type |ty| .)
    explain gam = (Environment | (ident :-> ty)..._ | with types of identifiers)
    explain ty = (Type of the expression)
  view U1 =
    holes [ cs: Cs, uty: Ty ]
    judgespec gam :- e : uty ~> cs
    judgeuse tex gam :-..unq e : uty ~> cs
    explain (Within environment |gam| , |e| has annotated type |uty| , provided that the constraints in |cs| are satisfied.)
    explain cs = (Constraints between annotations)
    explain ty = (Annotated type of the expression)
  view EL =
    holes [ e: Expr, gam: Gam, ty: Ty ]
    judgespec gam :- e : ty
    judgeuse tex gam :-..type e : ty
    explain (Within environment |gam| , |e| has type |ty| .)
    explain gam = (Environment | (ident :-> ty)..._ | with types of identifiers)
    explain ty = (Type of the expression)
  view UL =
    holes [ cs: Cs, uty: Ty, bcs: Bcs ]
    judgespec gam :- e : uty ~> cs, bcs
    judgeuse tex gam :-..unq e : uty ~> cs, bcs
    explain (Within environment |gam| , |e| has annotated type |uty| , provided that the constraints in |bcs| are satisfied.)
    explain cs = (Constraints between annotations)
    explain ty = (Annotated type of the expression)
  view EX =
    holes [ e: Expr, gam: Gam, ty: Ty ]
    judgespec gam :- e : ty
    judgeuse tex gam :-..type e : ty
    explain (Within environment |gam| , |e| has type |ty| .)
    explain gam = (Environment | (ident :-> ty)..._ | with types of identifiers)
    explain ty = (Type of the expression)
  view UX =
    holes [ e: Expr, cs: Cs, uty: Ty ]
    judgespec gam :- e : uty ~> cs
    judgeuse tex gam :-..unq e : uty ~> cs
    explain (Within environment |gam| , |e| has annotated type |uty| , provided that the constraints in |cs| are satisfied.)
    explain cs = (Constraints between annotations)
    explain ty = (Annotated type of the expression)
  view L =
    holes [ e: Expr, gam: Gam, ty: Ty ]
    judgespec gam :- e : ty
    judgeuse tex gam :- e : ty
    explain (Within environment |gam| , |e| has type |ty| .)
    explain gam = (Environment | (ident :-> ty)..._ | with types of identifiers)
    explain ty = (Type of the expression)


scheme prog "Prog" =
  view U1 =
    holes [ p : Prog ]
    judgespec gam :- p
    judgeuse tex gam :-..prog p


ruleset prog.base scheme prog  "Program type rule" =
  rule p "Prog" =
    view U1 =
      judge E : expr = gam :- e : uty ~> cs
      judge P : unpack = uty === { _ , delta }
      judge F : flowPrimWeak = cs.f === { (1,*,1) =>= delta }
      judge C : check = cs.f cs
      judge K : consistency =
      -
      judge R : prog = gam :- (e : uty)


ruleset expr.base scheme expr  "Expression type rules" =
  rule e.int "Int" =
    view E =
      -
      judge R : expr = gam :- n : Ty_Int
    view U1 =
      -
      judge R : expr
        | uty = Ty_Int..delta
        | cs = empty
    view EX =
      -
      judge R : expr = gam :- n : Ty_Int
    view UX =
      -
      judge R : expr
        | uty = Ty_Int..delta
        | cs = empty
    view L =
      -
      judge R : expr = empty :- n : Ty_Int
  rule e.var "Var" =
    view E =
      judge G : lookup = ident :-> ty `elem` gam
      -
      judge R : expr = gam :- ident : ty
    view U1 =
      judge G : lookup = ident :-> ty `elem` gam
      judge P : unpack = uty === { ty , delta }
      -
      judge R : expr
        | cs = empty
    view EL =
      judge G : lookup = ident.n :-> ty `elem` gam
      -
      judge R : expr = gam :- ident : ty
    view UL =
      judge G : lookup = ident.n :-> uty.x `elem` gam
      judge A : freshAnnot = uty.x ~> uty
      judge U1 : unpack = uty.x === { _ , a }
      judge U2 : unpack = uty === { _ , b }
      -
      judge R : expr
        | cs = { Inst n [(a, b)] }
        | bcs = empty
    view EX =
      judge G : lookup = ident :-> tau `elem` gam
      -
      judge R : expr = gam :- ident : tau
    view UX =
      judge G : lookup = ident :-> utau.env `elem` gam
      judge F : freshAnnot = utau.env ~> utau
      -
      judge R : expr
        | cs = empty
    view L =
      -
      judge R : expr = ({ident :-> tau}) :- ident : ty
  rule e.plus "Plus" =
    view E =
      judge A : expr = gam :- x : Ty_Int
      judge B : expr = gam :- y : Ty_Int
      -
      judge R : expr = gam :- (x opplus y) : Ty_Int
    view U1 =
      judge A : expr
        | uty = Ty_Int..a
        | cs = cs.a
      judge B : expr
        | uty = Ty_Int..b
        | cs = cs.b
      judge C1 : flowPrimWeak = cs.c1 === {c =>= a}
      judge C2 : flowPrimWeak = cs.c2 === {c =>= b}
      -
      judge R : expr
        | cs  = cs.c1 cs.c2 cs.a cs.b
        | uty = Ty_Int..c
    view EX =
      judge A : expr = gam :- x : Ty_Int
      judge B : expr = gam :- y : Ty_Int
      -
      judge R : expr = gam :- (x opplus y) : Ty_Int
    view UX =
      judge A : expr
        | uty = Ty_Int..a
        | cs = cs.a
      judge B : expr
        | uty = Ty_Int..b
        | cs = cs.b
      judge C1 : flowPrim2 = cs.c1 === {c.ref =>= a.ref}
      judge C2 : flowPrim2 = cs.c2 === {c.ref =>= b.ref}
      judge P1 : unpackTup = a === { a.ref, _ }
      judge P2 : unpackTup = b === { b.ref, _ }
      judge P3 : unpackTup = c === { c.ref, _ }
      -
      judge R : expr
        | cs  = cs.c1 cs.c2 cs.a cs.b
        | uty = Ty_Int..c
  rule e.app "App" =
    view E =
      judge F : expr = gam :- f : ty.f
      judge A : expr = gam :- a : ty.a
      judge C : match = ty.f <=> (ty.a -> ty)
      -
      judge R : expr = gam :- f a : ty
    view U1 =
      judge F : expr
        | uty = uty.f
        | cs  = cs.f
      judge A : expr
        | uty = uty.a
        | cs  = cs.a
      judge C  : match = uty.f <=> (uty.a.1 ->..(delta.1) uty.r)
      judge C2 : match = ty.r <=> ty
      judge C3 : match = ty.a.1 <=> ty.a
      judge P : unpack = uty === { _, delta }
      judge F1 : flow = :- uty.a.1 =>= uty.a ~> cs.m1
      judge F2 : flowPrimWeak = cs.m2 === { delta =>= delta.1 }
      judge F3 : flow = :- uty =>= uty.r ~> cs.r
      -
      judge R : expr
        | cs = cs.m1 cs.m2 cs.r cs.a cs.f
    view EX =
      judge F : expr = gam :- f : ty.f
      judge A : expr = gam :- a : ty.a
      judge C : match = ty.f <=> (ty.a -> ty)
      -
      judge R : expr = gam :- f a : ty
    view UX =
      judge F : expr
        | uty = uty.f
        | cs  = cs.f
      judge A : expr
        | uty = uty.a
        | cs  = cs.a
      judge C : match = uty.f <=> (uty.a.1 ->..(delta.1) uty.r)
      judge C2 : freshAnnot = uty.r ~> uty
      judge C3 : match = uty.a.1 <=> uty.a
      judge T1 : unpack = uty === { ty , delta.top }
      judge M1 : mkFlow = cs.md === delta.top =>= delta
      judge M2 : mkFlow = cs.ma === uty.a.1 =>= uty.a
      judge M3 : mkFlow = cs.mr === uty =>= uty.r
      -
      judge R : expr
        | cs = cs.md cs.ma cs.mr cs.a cs.f
    view L =
      judge F : expr = gam.f :- f : (ty.a -> ty)
      judge A : expr = gam.a :- a : ty.a
      -
      judge R : expr = (gam.f, gam.a) :- f a : ty
  rule e.lam "Lam" =
    view E =
      judge B : expr = (x :-> ty.x + gam) :- b : ty
      -
      judge R : expr = gam :- (\x -> b) : (ty.x -> ty)
    view U1 =
      judge B : expr = (x :-> ty.x + gam) :- b : uty ~> cs.b
      judge S1 : gather = x :- b ~> ({ x.1:uty.1.a1, "...", x.n:uty.n.an })
      judge P : unpack = uty.x === { _, a }
      judge S2 : sum = cs.sum === { sum <= a }
      -
      judge R : expr
        | uty = uty.x ->..delta uty
        | cs  = cs.sum cs.b
    view EX =
      judge B : expr = (x :-> ty.x + gam) :- b : ty
      -
      judge R : expr = gam :- (\x -> b) : (ty.x -> ty)
    view UX =
      judge B : expr = (x :-> ty.x + gam) :- b : uty ~> cs.b
      judge S1 : gather = x :- b ~> ({ x.1:uty.1.a1, "...", x.n:uty.n.an })
      judge P : unpack = uty.x === { _, a }
      judge S2 : sum = cs.sum === { sum <= a }
      -
      judge R : expr
        | uty = uty.x ->..delta uty
        | cs  = cs.sum cs.b
    view L =
      judge B : expr = (x :-> ty.x + gam) :- b : ty
      -
      judge R : expr = gam :- (\x -> b) : (ty.x -> ty)

  rule e.let "Let" =
    view EL =
      judge E : expr = gam :- expr : ty.expr
      judge B : expr = (x.m :-> ty.expr + gam) :- body : ty
      -
      judge R : expr = gam :- (let.m x "=" expr in body) : ty
  view UL =
      judge E : expr
        | uty = uty.e
        | cs  = cs.e
        | bcs = bcs.e
      judge B : expr = (x.m :-> uty.expr + gam) :- body : uty ~> cs.b , bcs.b
      judge C1 : gather = x :- (expr, body) ~> ({ x.1:uty.1.a1, "...", x.n:uty.n.an })
      judge P : unpack = uty.x === {_ , delta }
      judge S : sum = cs.sum === { sum <= delta }
      -
      judge R : expr
        | cs  = cs.sum cs.b
        | bcs = {(m, cs.e)} bcs.e bcs.b


relation lookup =
  view B =
    holes [ nm: Nm, gam: Gam, ty: Ty ]
    judgespec nm :-> ty `elem` gam

relation match =
  view B =
    holes [ a: Ty, b: Ty ]
    judgespec a <=> b

relation unpack =
  view B =
    holes [ a : Ty, b: Ty, c: Ann ]
    judgespec a === { b, c }
    judgeuse tex a === "(Sup(" b ")(" c

relation unpackTup =
  view B =
    holes [ a : Ann', b : Ann', c : Ann' ]
    judgespec a === {b, c}
    judgeuse tex a === (b, c)

relation flowPrim =
  view B =
    holes [ a: Ann, b: Ann, cs: Cs ]
    judgespec cs === { a =>= b }

relation flowPrimWeak =
  view B =
    holes [ a: Ann, b: Ann, cs: Cs ]
    judgespec cs === { a =>= b }
    judgeuse tex cs === { a =>=.s b }

relation flowPrim2 =
  view UX =
    holes [ a: Ann, b: Ann, cs: Cs ]
    judgespec cs === { a =>= b }
    judgeuse tex cs === { a =>=.s b }

relation flow =
  view B =
    holes [ utyA: Ty, utyB: Ty, cs: Cs ]
    judgespec :- utyA =>= utyB ~> cs
    judgeuse tex :-..flow utyA =>= utyB ~> cs

ruleset flow.base scheme flow "Flow type rules" =
  rule int "Int" =
    view U1 =
      judge F : flowPrim = cs === { a =>= b }
      -
      judge R : flow = :- Ty_Int..a =>= Ty_Int..b ~> cs
  rule arrow "Arrow" =
    view U1 =
      judge F : flowPrim = cs.f === { a =>= b }
      judge A : flow = :- uty.b =>= uty.d ~> cs.1
      judge B : flow = :- uty.c =>= uty.a ~> cs.2
      -
      judge R : flow = :- (uty.a ->..a uty.b) =>= (uty.c ->..b uty.d) ~> cs.f cs.1 cs.2


relation gather =
  view B =
    holes [ x : HsName, b : Expr, r : Set ]
    judgespec x :- b ~> r
    judgeuse tex x :-..gather b ~> r

relation sum =
  view B =
    holes [ a : Ann, cs : Cs ]
    judgespec cs === { sum <= a }
    judgeuse tex cs === { a.1 addme dots addme a.n <= a }

relation check =
  view U1 =
    holes [ cs : Cs ]
    judgespec cs
    judgeuse tex satisfied cs

relation consistency =
  view U1 =
    holes [ x : Dummy ]
    judgespec
    judgeuse tex "all tripples consistent"




scheme tp "Type" =
  view D =
    holes [ tau: Tp, gam: Gam, kappa: Ty ]
    judgespec gam :- tau : kappa
    judgeuse tex gam :-..kind tau : kappa
    explain (Within environment |gam| , |tau| has kind |kappa| .)
    explain gam = (Environment | (ident :-> kappa)..._ | with kinds of identifiers)
    explain kappa = (Kind of the type)
  view DC =
    holes [ cs: Cs, ukappa: Ty ]
    judgespec gam :- tau : ukappa ~> cs
    judgeuse tex gam :-..kind tau : ukappa ~> cs
    explain (Within environment |gam| , |tau| has annotated type |ukappa| , provided that the constraints in |cs| are satisfied.)
    explain cs = (Constraints between annotations)
    explain ty = (Annotated kind of the type)


ruleset tp.base scheme tp  "Type type rules" =
  rule d.var "Var" =
    view D =
      judge G : lookup = ident :-> kappa `elem` gam
      -
      judge R : tp = gam :- ident : kappa
    view DC =
      judge G : lookup = ident :-> ukappa.env `elem` gam
      judge F : freshAnnot = ukappa.env ~> ukappa
      -
      judge R : tp
        | cs = empty
  rule d.con "Con" =
    view D =
      judge G : lookup = ident.n :-> kappa `elem` gam
      -
      judge R : tp = gam :- ident.n : kappa
    view DC =
      judge G : lookup = ident.n :-> ukappa.env `elem` gam
      judge F : freshAnnot = ukappa.env ~> ukappa
      -
      judge R : tp
        | cs = { Inst n " " ukappa.env " " ukappa }
  rule d.ann "Ann" =
    view D =
      judge K : tp = gam :- tau : kappa
      -
      judge R : tp = gam :- tau..delta : kappa
    view DC =
      judge K : tp = gam :- tau : ukappa ~> cs
      judge P : unpack = ukappa === { kappa , delta.top }
      judge M : mkFlow = cs.ann === delta.top =>= delta
      -
      judge R : tp = gam :- tau..delta : ukappa ~> cs.ann cs
  rule d.app "App" =
    view D =
      judge F : tp = gam :- f : kappa.f
      judge A : tp = gam :- a : kappa.a
      judge C : match = kappa.f <=> (kappa.a -> kappa)
      -
      judge R : tp = gam :- f a : kappa
    view DC =
      judge F : tp
        | ukappa = ukappa.f
        | cs     = cs.f
      judge A : tp
        | ukappa = ukappa.a
        | cs     = cs.a
      judge C : match = ukappa.f <=> (ukappa.a.1 ->..(delta.1) ukappa.r)
      judge C2 : freshAnnot = ukappa.r ~> ukappa
      judge C3 : match = kappa.a.1 <=> kappa.a
      judge T1 : unpack = ukappa === { kappa , delta.top }
      judge M1 : mkFlow = cs.md === delta.top =>= delta
      judge M2 : mkFlow = cs.ma === ukappa.a.1 =>= ukappa.a
      judge M3 : mkFlow = cs.mr === ukappa =>= ukappa.r
      -
      judge R : tp
        | cs = cs.md cs.ma cs.mr cs.a cs.f


relation freshAnnot =
  view B =
    holes [ utyA: Ty, utyB: Ty ]
    judgespec utyA ~> utyB
    judgeuse tex freshAnnotate utyA ~> utyB

relation mkFlow =
  view B =
    holes [ tyA : Ty, tyB : Ty, cs : Cs ]
    judgespec cs === tyA =>= tyB
    judgeuse tex cs === { tyA =>= tyB }

%%]
