%%[main

%format sumtuples = "\sum_{i}"

\chapter{Lambda calculus without bindings}
\label{chapt.NoBindings}

In the introduction (Chapter~\ref{chapt.Introduction}) we showed that functional programs perform a lot of copying
in order to preserve referential transparency in the presence of destructive updates. It is possible to get
similar performance, compared to destructive updates in imperative programs. Two steps are needed to get this
done: the first step is to analyse which values are guaranteed to be used at most once, and the second step
is to insert special code for destructive updates on values that are used at most once. We devote this entire
thesis to the first step, and leave the second step as future work.

This chapter presents a uniqueness type system for a severely restricted language: simply-typed lambda calculus
with no |let| bindings, but with integers and an addition operator. Although restricted, this languages serves well to
discuss the fundamentals of uniqueness typing, and our implementation of the uniqueness type system. In subsequent
chapters, we extend the language with features, until most of Haskell is covered.

This chapter is organized as follows. We start with an overview of the system and some small examples to give a general
feeling about our approach. Then we provide a rather large example that demonstrates the approach in detail. This example
touches several aspects of our approach, such as the definition of the language, constraint gathering, and constraint
solving. In the remainder of the chapter, we treat these aspects in a more formal fashion.


\section{Intuition}

  We start with an overview of the uniqueness type system. The system consists of two parts. The first part deals with
  constraint generation and the second part deals with constraint solving. This separation is not relevant at this
  point, but is important for seperating concerns later in this thesis. The application of an implementation of this
  type system to an expression, we call a uniqueness analysis.

  As we mentioned in the introduction, there are boundaries to what is decidable and what is not. To keep the analysis
  feasible, we associate uniqueness properties with the type of a value and not with a value itself. The analysis is
  conservative: if a type is unique, we know that it is used exactly once, but if it is not, it can be unique but
  probably is not.

  \subsection{Annotations}

  Instead of just classifying types as unique or shared, we distinguish five different values:

%%[[wrap=code
  data Usage
    =  Zero          -- not used (0)
    |  Affine        -- at most used once (1-) "unique"
    |  Linear        -- exactly used once (1)
    |  Strict        -- at least used once, possibly more (1+)
    |  Arbitrary     -- arbitrary usage (*) "shared"
%%]

  Some optimizations demand that a value is exactly used once, while for other optimizations it is sufficient that a value
  is used at most once, which is slightly less demanding. Technically speaking, |Strict| has nothing to do with uniqueness
  typing, but we get strictness analysis for free, so we include it here anyway. We still call our typing approach
  uniqueness typing, although it is technically more than that.

  To specify that a value |v| of type |Int| is exactly used once, we write: |v :: (Sup(Int)(1))|. Likewise, if |f| is
  a function with annotated type |f :: (Sup(Int)(1)) (Sup(->)(1)) (Sup(Int)(*))|, then |f| is a function that is used
  exactly once, producing a value that may be used any number of times, and states that the parameter is used
  exactly once, and may not be used elsewhere.

  The analysis expects a program annotated in this fashion and verifies that the annotations are correct (inference in
  Chapter~\ref{chapt.Polyvariant}). Unfortunately, we cannot easily formulate the conditions of when an annotation is
  correct or not. We have to check two things: does the annotation fit in the context, and does the annotation fit with
  the number of references there are to the value. With context we mean that if two types are unified, that their annotations
  also unify. For example, a value with usage |1| cannot be passed to a function that has an |1-| usage for its parameter,
  because the function cannot guarantee that the value will always be used. With the number of references we mean the
  guaranteed upper and lower bound on the number of times the value will be evaluated or referenced. For example, a value
  that is referenced at least once cannot have the usage annotation |0|. We have sufficient information for the
  context check (which is basically a form of unification), but insufficient informatoin for the reference-check.

  That is why we demand that the types in an expression are annotated with three annotations (!). A usage
  annotation, a lower-bound usage-count annotation, and an upper-bound usage-count annotation. The lower-bound
  usage-count annotation tells us that a value is at least a certain number of times, and the upper-bound
  usage-count annotation tells us that a value is at most used a certain number of times. The reference-check
  demands that the usage-annotation is in between these bounds. Furthermore, we can check the validity of
  the upper and lower bound annotations.

  We explain by means of an example how these three annotations interact and how we formulate the checks into
  a constraint satisfaction problem. Unfortunately, that is rather hard to grasp at this point, so we defer
  the explanation to Section~\ref{sect.BigExample}. Instead, we discuss here how to check the upper-bound
  usage-count annotation, since the checks on the lower-bound usage-count and also the context-check on the
  usage annotation itself will be quite similar (this will become clear in Section~\ref{sect.BigExample}).

  \subsection{Checking the upper-bound usage-count annotation}

  An upper-bound usage-count annotation |u| specifies that the corresponding values are at most used
  |u| times:

%%[[wrap=code
  data UpperBound
    | 0             -- not used
    | 1             -- at most used once
    | *             -- arbitrary usage, but typically represents a number greater than one
%%]

  We assume that expressions are annotated with upper-bound usage-count annotations. That means that
  all type constructors occurring in the types of an expression have an upper-bound usage-count annotation.
  For example, an annotated version of the expression |(\x -> x) 3| is:

%%[[wrap=code
  (\x -> x) 3
  (((\(x :: (Sup(Sub(Int)(a))(1))) -> x :: (Sup(Sub(Int)(b))(1))) :: (Sup(Sub(Int)(c))(1)) (Sup(Sub(->)(d))(1)) (Sup(Sub(Int)(e))(1))) (3 :: (Sup(Sub(Int)(f))(1)))) :: (Sup(Sub(Int)(g))(1))
%%]

  This looks quite intimidating, but let us consider what is displayed here. The outermost expression is annotated
  with |(Sup(Sub(Int)(g))(1))|, which means that the result of the expression is used at most once. The outermost expression
  is an application of an argument to a function. The annotated type of the function is |(Sup(Sub(Int)(c))(1)) (Sup(Sub(->)(d))(1)) (Sup(Sub(Int)(e))(1))|. The annotation on the
  arrow type constructor, (Sup((Sub(->)(d)))(1)), specifies that the function is used at most once. The annotation
  |(Sup(Sub(Int)(c))(1))| specifies that the parameter is used at most once, and |(Sup(Sub(Int)(e))(1))| demands
  that the result is used at most once. The annotation |(Sup(Sub(Int)(f))(1))| specifies that the argument
  is used at most once. The annotation on the parameter of the function and the annotation on the argument of the
  function are related to each other. Likewise, the annotation on the result of the function is related to the
  annotation on the function application. The annotation of the parameter of the function is related to the
  annotation of the result of the function, but that depends on the structure of the body of the function.
  Take a moment to get a clear picture of the annotations and their meaning.

  Are these annotations correct? For this example, it is not difficult to see that indeed the value |3| is not used
  more than once, but we need a systematic approach to verify this. We check the annotations by a traversal over the
  structure of the expression, and approximate the upper bound from below. By computing an approximation of a least
  upper bound, we check that the upper bound provided by the programmer is high enough to be an upper bound for any
  execution of the program. In other words, we determine from the structure of the program that the upper bound
  should be at least |m| to be an upper bound, and verify that the upper bound given by the programmer is at least
  |m|. The upper bound is allowed to be higher than is strictly nesseccairy.

  The root of the expression is the starting point. When execution the expression, the root
  is evaluated once to obtain the value. So, the upper bound for the root of the expression is at least |1|. The annotated
  type of the root, |(Sup(Int)(1))|, is therefore correct. The root of the expression is a function application. Since the
  annotation is correct, it means that the upper bound for the function application is at least the upper bound of the
  root of the expression, thus at least |1|. The function is at least as often used than the function application, so
  the upper bound of the function is at least the upper bound of the function application, thus at least |1|. The annotation
  on |(Sup(Sub(->)(d))(1))| is correct. The same reasoning applies to the result of the function. The upper bound of the result
  of the function is at least the upper bound of the function application . The annotation on |(Sup(Sub(Int)(e))(1))| is correct.

  Now the function and the argument. Consider the argument first. The function fully determines how often it
  is used. The upper bound of the argument is at least the upper bound of the parameter of the function. The annotation
  on |(Sup(Sub(Int)(c))(1))| is the upper bound of the parameter, thus the upper bound of the argument is at least
  |1|. |(Sup(Sub(Int)(f))(1))| is correct. Of course, we have to verify that the upper bound of the parameter of the
  function is |1|. We take a look at the function. The body of the function has an upper bound of |1|, because the the result
  of the function has an upper bound of |1|. The body of the function is a use of parameter |x|. So, the upper bound for
  this occurrence of |x| is |1|. The annotation on |(Sup(Sub(Int)(b))(1))| is correct. The upper bound for the parameter
  |x| is at least the sum of the upper bounds of the occurences. There are no other occurrences of |x|,
  so the aggegrated upper bound of |x| is |1|. We come back to this specific subject later. The annotation on
  |(Sup(Sub(Int)(a))(1))| is correct. Again, take a moment
  to get a mental picture of how the abstract syntax tree is compared and how annotations are compared from outermost
  expressions to innermost expressions and from left to right.

  An important step is the aggegration of upper bounds for occurences of an identifier. The following variation of
  the above example shows why it is important:

%%[[wrap=code
  (\x -> x + x) 3
  (\((Sub(x)(0)) :: (Sup(Sub(Int)(a))(*))) -> ((Sub(x)(1)) :: (Sup(Sub(Int)(b))(1))) + ((Sub(x)(2)) :: (Sup(Sub(Int)(c))(1)))) (3 :: (Sup(Sub(Int)(d))(*)))
%%]

  The number of times a value bound to |(Sub(x)(0))| is used, is the aggegrated number of times the value is used as |(Sub(x)(1))| and
  |(Sub(x)(2))|. Any actual usage count for |(Sub(x)(1))| or |(Sub(x)(2))| is lower than their corresponding upper bound. A safe approximation for
  a least upper bound of |(Sub(x)(0))| is the sum of the upper bounds of |(Sub(x)(1))| and |(Sub(x)(2))|. As the example shows, the upper
  bounds of |(Sub(x)(1))| and |(Sub(x)(2))| are both |1|, so the sum is |*| and the annotation is correct.

  As we mentioned several times already, a conservative approximation of the upper bound is allowed. The upper bound may
  be higher than it practice will be the case. For example, if we know that a value is not used, we may also assume that
  it is at most used once. Futhermore, assuming that some value is used an arbitrary number of times is always allowed. It
  is safe to pretend that the upper bound is higher than is actually the case, but it makes the analysis result less accurate.

  The following example is a variation upon the earlier example where some of the annotations are higher than
  is strictly neccessairy:

%%[[wrap=code
  (\x -> x) 3
  (((\(x :: (Sup(Sub(Int)(a))(*))) -> x :: (Sup(Sub(Int)(b))(1))) :: (Sup(Sub(Int)(c))(*)) (Sup(Sub(->)(d))(*)) (Sup(Sub(Int)(e))(1))) (3 :: (Sup(Sub(Int)(f))(*)))) :: (Sup(Sub(Int)(g))(1))
%%]

  We verify again that these annotations are correct. The outermost expression is used at most once, so
  the upper bound is at least |1|. The annotation on |(Sup(Sub(Int)(g))(1))| is correct. The upper bound for
  the function itself is at least as high as the upper bound for the function application. The upper bound
  for the function is |*|, which is at least as high as the upper bound of |1| of the function application.
  The annotation on |(Sup(Sub(->)(d))(*))| is correct. The result of the function has an upper bound of |1|,
  which is at least as high as the upper bound of |1| of the function application. The annotation on
  |(Sup((Sub(Int)(e)))(1))| is correct. The aggegrated upper bound for |x| is at least the sum of the upper bounds of
  the occurrences of |x|, which in this case is |(Sup(Sub(Int)(b))(1))|. The annotation on
  |(Sup(Sub(Int)(a))(*))| is higher, but that is allowed, so it is correct. Consequently, our traversal of the
  expression deamnds that the the annotations on |(Sup(Sub(Int)(c))(*))| and |(Sup(Sub(Int)(f))(*))| are at
  least the annotation on |(Sup(Sub(Int)(a))(*))|, which is correct.

  To summarize: what our analysis does is to start with some known information about the root of the expression
  and `push' it through the abstract syntax tree from outermost to innermost, and in case of functions from result to
  arguments based on the body. A mental picture is that there is an `flow' of count-information from the
  root of the expression to the leaves. We say that the analysis propagates counts. We see in later sections that
  dealing with a lower bound, and dealing with usage annotations, is not much different than what we did in
  this section.

\section{The next step}
\label{sect.BigExample}

  With the intuitions gained in the previous section, we introduce a constraint-based approach to uniqueness
  typing. For example, for the upper bound analysis of the previous section, we generate a constraint
  |... =>= ...| for each time we wrote `at least', and a constraint |... \+/ ... \+/ ... <= ...| where
  we aggegrated upper bounds. It that it? Yes, that is it basically, because we will show that the
  same constraints can be used for the lower bound analysis and the analysis for the actual usage
  values.

  The running example in this section is the following expression:

%%[[wrap=code
  (\x y -> (y + x) + x) 3 4
%%]

  The result of this program is evaluated once when the program is executed. Consequently, the results of
  both additions are used once, and thus is the |x| parameter used twice and the |y| parameter once. Which
  in turn means that the value |3| is used twice and the value |4| once. In terms of usage, |3| the
  value |3| is linear (exactly once), and the value |4| is strict (more than once).

  Efficient code can be produced with this \emph{usage information}. A conventional implementation of addition in a pure,
  lazy language, evaluates both arguments, allocate memory for an integer, and store the result of
  the addition there. But in this case, there is no need to allocate memory for the result of the additions.
  Since the value passed to |y| is linear, the value of |x| can be added directly to the value of |y|
  (destructively updating the value of |y|). The result of the addition is again linear, and the
  value of |x| can be added directly again for the second addition. The result: less memory allocation,
  less copying, and better cache utilization. If the compiler also inlines functions that are at most
  used once, and evaluates strict values before passing it to a function, then this code is as efficient
  as a corresponding imperative program.

  \subsection{Annotations}

  Usage information is encoded as annotation on the type constructors in the type of a value. The type
  specifies how much certain regions of a value are used (Section~\ref{sect.TpAnnConstr}). As mentioned
  in the introduction, a type has three annotations. This looks horrible, but unfortunately, we cannot
  do anything against it until next chapter.

  As an example of a tripple of annotations, consider the type |(Sup(Int)((1,1+,*)))|. The first
  annotation is the lower-bound usage-count annotation, which specifies that the value is at least used once.
  The second annotation is a usage annotation, specifying that the value is strict, meanting that it is used
  at least one or more times. The third annotation is the upper-bound usage-count annotation, which specifies
  that the value is at most used an arbitrary number of times. This tupple is consistent if the lower bound
  is smaller or equal than the usage annotation, and the usage annotation is smaller or equal to the upper bound.
  The smaller or equal relation is defined between the three types of annotations in the obvious way.

  For the above example, a possible annotation is:

%%[[wrap=code
    (  (\x y ->  (  (  y :: (Sup(Int)((1, 1, 1)))
                    +  x :: (Sup(Int)((1, 1+, *)))
                    ) :: (Sup(Int)((1, 1, 1))))
                 +  x :: (Sup(Int)((1, 1+, *)))
                 ) :: (Sup(Int)((1, 1, 1)))
       ) :: (Sup(Int)((1, 1+, *))) (Sup(->)((1, 1, 1))) (Sup(Int)((1, 1, 1))) (Sup(->)((1, 1, 1))) (Sup(Int)((1, 1, 1))))
       (3 :: (Sup(Int)((1, 1+, *)))) (4 :: (Sup(Int)((1, 1, 1)))
    ) :: (Sup(Int)((1, 1, 1)))
%%]

  This looks quite intimidating, but that is just because there are a lot of types involved and the
  annotations take much space. In the next chapter, we infer all annotations, and the lower
  and upper bound annotations become implicit, resulting in cleaner types (Section~\ref{sect.TheInferencer}).
  But we first have to do the dirty work here.

  \subsection{Checking the annotations}

  How to check that the annotated typing of a program is valid? First we check that the program is correctly
  typed for the conventional type system of simply typed lambda calculus. Secondly, we check that all
  tripples of annotations are consistent. Then it is time for the real work:
  we gather a set of constraints from the annotated program, and check if the constraints are satisfied. When the
  constraints are satisfied, the annotations are correct and the program is correctly typed according to the
  uniqueness type system.

  As a side note, in order to keep the explanation compact, we are a bit
  sloppy in distinguishing identifiers, values and types. For example, if we talk about the upper bound of
  a function, we intend the upper-bound usage-count annotation on the type associated with the
  value representing the function. Or when we talk about the uses of an expression, we actually mean how
  often the value corresponding to the expression is used.

  We illustrate the constraints by analyzing the example\footnote{For clarity, the annotations values have a number
  superscripted, such that you can see which annotation appears where in the constraints.}. For a description of the constraints and their
  meaning, check Section~\ref{sect.TpAnnConstr}. We reason about a program in an outermost-to-innermost way. We
  start with the entire program (expression):

%%[[wrap=code
    ( ... ) :: (Sup(Int)(((Sup(1)(1)), (Sup(1)(2)), (Sup(1)(3)))))
%%]

  The result of the entire expression is exactly used once. However, we are allowed to be less accurate for the result
  of the entire expression. Any usage value that is consistent is allowed. We generate the constraint |(1, *, 1) (Sub(=>=)(s)) ((Sup(1)(1)), (Sup(1)(2)), (Sup(1)(3)))|. This constraint specifies that the lower bound
  is at most |1|, the upper bound is at least |1|, and the usage annotation can be anything as long as it is consistent with
  the two bounds in the tripple. The subscript |s| indicates that the usage annotation is ignored in this constraint. A |=>=| constraint
  without the |s| suffix is encountered later in the example. The generated constraint expresses what we know about the result of the entire expression. We call this
  constraint a flow or propagation constraint, because with some immagination, it `pushes' values on the
  left-hand side to the right-hand side. We often call a |=>=| constraint a coercion, which is explained in the next
  section.

  One step into the expression, an application is encountered:

%%[[wrap=code
    (( ... :: (Sup(Int)(((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))))) (Sup(->)(((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9))))) (Sup(Int)(((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))))) (4 :: (Sup(Int)(((Sup(1)(13)), (Sup(1)(14)), (Sup(1)(15))))))) :: (Sup(Int)(((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18)))))
%%]

  Several constraints are generated for a function application:

  \begin{itemize}
  \item The function application and the function. The uses of the function depends on the uses of the
        function application. We generate the constraint |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) (Sub(=>=)(s)) ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))|.
        The lower bound of the function (|(Sup(1)(7))|) is at most the lower bound of the function application (|(Sup(1)(16))|). The upper bound of
        the function (|(Sup(1)(18))|) is at least the upper bound of the function application (|(Sup(1)(9))|). The constraint
        expresses precisely how often the function is used, if we know how often the function application itself is used.
        The usage annotations are unrelated, since the memory occupied by the function has nothing to do with the memory
        occupied by the result of the function.
  \item The function application and result of the function. the result of the function application depends on
        how often the function application itself is used. We generate the constraint |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) =>= ((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))|.
        The lower bound of the result of the function (|(Sup(1)(10))|) is at most the lower bound of the function application (|(Sup(1)(16))|). The upper bound of
        the result of the function function (|(Sup(1)(18))|) is at least the upper bound of the function application (|(Sup(1)(11))|). The usage annotation (|(Sup(1)(12))|)
        of the result of the function should be equal (modulo coercion) to the usage annotation of the function application (|(Sup(1)(17))|).
  \item The function and the argument of the function application. The uses of the argument of the function
        application depend on the annotations of the parameter of the function. We generate the constraint |((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))) =>= ((Sup(1)(13)), (Sup(1)(14)), (Sup(1)(15)))|.
        The semantics of the constraint capture the relations between the three annotations on the type of the function parameter and
        the type of the argument value.
  \end{itemize}

  The remainder of the constraint we find by analyzing the function expression and the argument expression. No constraint is generated for
  the argument expression, since that is an |Int| expression, and each consistent tripple is valid. In other words: the value |3| can
  represent a linear |Int|, but also a strict |Int| or an affine |Int|. So, verifying the function expression is what remains.

  The function expression is again an application:

%%[[wrap=code
    ( ... :: (Sup(Int)(((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21))))) (Sup(->)(((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24))))) ((Sup(Int)(((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27))))) (Sup(->)(((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30))))) (Sup(Int)(((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))))))
      (3 :: (Sup(Int)(((Sup(1)(34)), (Sup(1+)(35)), (Sup(*)(36))))))
        :: (Sup(Int)(((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))))) (Sup(->)(((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9))))) (Sup(Int)(((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))))
%%]

  This is basically the same situation as above, except with one important difference. The type of the result of the
  function application is a function. Its type has more than one type constructor, and multiple tripples of annotations.
  Each type constructor in one type has a corresponding type constructor in the other type. The |=>=| constraint is generated
  between tripples attached on corresponding type constructors. This way we check annotations that specify
  usages of the same regions of a value. The direction of the |=>=| constraint depends on co-variance and contra-variance. The
  direction is reversed for |=>=| constraint between |contra-variant| type constructors. The reason is that co-variant type
  constructors correspond to values for which the annotation require some property (``I must be used exactly once''), whereas
  contra-variant type constructors correspond to values for which the annotations provide some property (``I am used exactly once''),
  which is essentially the inversed direction.See Peyton Jones~\cite{peytonjones04pract-inf-rank} for an elaborate explanation
  on co-variance and contra-variance and subtyping.

  Applying the same reasoning as with the previous function application, we generate the following constraints:

%%[[wrap=code

    ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))      (Sub(=>=)(s))  ((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24)))   -- use of the function
    ((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))   =>=            ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))   -- use of the function value (resulting Int, co-variant)
    ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))      =>=            ((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30)))   -- use of the function value (function type, co-variant)
    ((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))   =>=            ((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6)))      -- use of the function value (argument Int, contra-variant)
    ((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21)))  =>=            ((Sup(1)(34)), (Sup(1+)(35)), (Sup(*)(36)))  -- use of the argument
%%]

  This leaves to analyze the function of the function application, and the argument of the function application. The argument
  is again an |Int| expression, which does not result in constraints, so we proceed with the function expression.

  The function expression is a lambda abstraction:

%%[[wrap=code
    ( \(x :: (Sup(Int)(((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21)))))) (y :: (Sup(Int)(((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))))) -> ... y :: (Sup(Int)(((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39))))) ... (Sub(x)(1)) :: (Sup(Int)(((Sup(1)(40)), (Sup(1+)(41)), (Sup(*)(42))))) ... (Sub(x)(2)) :: (Sup(Int)(((Sup(1)(43)), (Sup(1+)(44)), (Sup(*)(45)))))
    ) :: (Sup(Int)(((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21))))) (Sup(->)(((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24))))) ((Sup(Int)(((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27))))) (Sup(->)(((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30))))) (Sup(Int)(((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33))))))
%%]

  For a lambda abstraction, we perform two tasks: analyze the body of the lambda abstraction, and
  combine the results of the uses of the values represented by the parameters. We check that the aggegrated
  results match the sum of the individual results with the special constraint: |tripple((Sub(use_site)(1))) \+/ ... \+/ tripple((Sub(use_site)(n))) <= triple(def_site)|.
  This constraint ensures that we check that the lower-bound is low enough and the upper-bound is high enough (as we explained in
  the previous section). Furthermore, the constraint ensures that if the parameter has some usage value |u|, that all its
  occurrences added up correspond to |u|. For example, if |u| is linear, it means that one of the occurrences must be linear and
  all the other occurrences not used.

  With only one use-site of |y|, and two use-sites of |x|, the constraints are:

%%[[wrap=code
   ((Sup(1)(40)), (Sup(1+)(41)), (Sup(*)(42))) \+/ ((Sup(1)(43)), (Sup(1+)(44)), (Sup(*)(45))) <= ((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21)))  -- for x
   ((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39))) <= ((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))                                                    -- for y
%%]

  The function body remains to be checked. The function body consists of the additions:

%%[[wrap=code
  ((y :: (Sup(Int)(((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39)))))) + ((Sub(x)(1)) :: (Sup(Int)(((Sup(1)(40)), (Sup(1+)(41)), (Sup(*)(42))))))) :: (Sup(Int)(((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))))
  ((( ... ) :: (Sup(Int)(((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))))) + ((Sub(x)(2)) :: (Sup(Int)(((Sup(1)(43)), (Sup(1+)(44)), (Sup(*)(45))))))) :: (Sup(Int)(((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33))))))
%%]

  The addition operator uses both the arguments at least as many times as the result is used. The default operational
  semantics for addition stores the result of the addition in a memory location unrelated to the arguments of the
  addition. So, usage annotations of the arguments of the addition are unrelated to the usage annotation on the result
  of the addition. But the lower-bound and upper-bound annotations of the arguments are related to the lower-bound and
  upper-bound annotations of the result of the expression. The usage-annotation on the result of the addition may be
  any value that fits the two bounds. For the relation between the arguments of the addition and the result of the
  addition, we generate a weaker version of the |=>=| constraint that ignores the usage annotation, but does not
  ignore the two bounds: |(Sub(=>=)(s))|, with the |s| of 'soft'. When we want to stress the difference between these
  two |=>=| constraints, we write the normal |=>=| constraint as |(Sub(=>=)(h))|, with the |h| of 'hard'.

  The following constraints relate the result of the additions properly to the arguments of the addition:

%%[[wrap=code
    ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39)))
    ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(40)), (Sup(1+)(41)), (Sup(*)(42)))
    ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))
    ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(43)), (Sup(1+)(44)), (Sup(*)(45)))
%%]

  \subsection{Checking the constraints}

  The final part of this example is to verify that the constraints hold. We show by an example how we interpret
  the constraints. We define when a constraint hold more precisely in Section~\ref{Sect.CheckingConstraints}. We assume that
  the constraints are already checked for consistency, meaning that the usage annotation fits between the upper and
  lower bound. With the constraints being consistent, the
  following table lists the constraints and their interpretation (see Figure~\ref{splitFunc} for the definition of |properSplit|):

  \begin{tabular}{llllr}
    constraint & lower bound & usage & upper bound & holds \\
    \hline
      |(1, *, 1) (Sub(=>=)(s)) ((Sup(1)(1)), (Sup(1)(2)), (Sup(1)(3)))|   & |1 >= (Sup(1)(1))| & & |1 <= (Sup(1)(3))| & OK  \\
      |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) (Sub(=>=)(s)) ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))| & |(Sup(1)(16)) >= (Sup(1)(7))| & & |(Sup(1)(18)) <= (Sup(1)(9))| & OK  \\
      |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) =>= ((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))|  & |(Sup(1)(16)) >= (Sup(1)(10))| & |(Sup(1)(17)) <= (Sup(1)(11))| & |(Sup(1)(18)) <= (Sup(1)(12))| & OK  \\
      |((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))) =>= ((Sup(1)(13)), (Sup(1)(14)), (Sup(1)(15)))|       & |(Sup(1)(4)) >= (Sup(1)(13))| & |(Sup(1)(5)) <= (Sup(1)(14))| & |(Sup(1)(6)) <= (Sup(1)(15))| & OK  \\
      |((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))      (Sub(=>=)(s))  ((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24)))|    & |(Sup(1)(7)) >= (Sup(1)(22))| &  & |(Sup(1)(9)) <= (Sup(1)(24))| & OK  \\
      |((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))   =>=  ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))|    & |(Sup(1)(10)) >= (Sup(1)(31))| & |(Sup(1)(11)) <= (Sup(1)(32))| & |(Sup(1)(12)) <= (Sup(1)(33))| & OK  \\
      |((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))      =>=  ((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30)))|    & |(Sup(1)(7)) >= (Sup(1)(28))| & |(Sup(1)(8)) <= (Sup(1)(29))| & |(Sup(1)(9)) <= (Sup(1)(30))| & OK  \\
      |((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))   =>=  ((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6)))|    & |(Sup(1)(25)) >= (Sup(1)(4))| & |(Sup(1)(26)) <= (Sup(1)(5))| & |(Sup(1)(27)) <= (Sup(1)(6))| & OK  \\
      |((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21)))  =>=  ((Sup(1)(34)), (Sup(1+)(35)), (Sup(*)(36)))|    & |(Sup(1)(19)) >= (Sup(1)(34))| & |(Sup(1+)(20)) <= (Sup(1+)(35))| & |(Sup(*)(20)) <= (Sup(*)(36))| & OK  \\
      |((Sup(1)(40)), (Sup(1+)(41)), (Sup(*)(42))) \+/ ((Sup(1)(43)), (Sup(1+)(44)), (Sup(*)(45)))| & |(Sup(1)(40)) `max` (Sup(1)(43)) >= (Sup(1)(19))| & |properSplit {(Sup(1+)(41)), (Sup(1+)(44))} (Sup(1+)(20))| & |(Sup(1)(42)) + (Sup(1)(45)) <= (Sup(1)(21))| & OK  \\
      |  <= ((Sup(1)(19)), (Sup(1+)(20)), (Sup(*)(21)))|   & & & & \\
      |((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39))) <= ((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))|  & |(Sup(1)(37)) >= (Sup(1)(25))| & |properSplit {(Sup(1)(38))} (Sup(1)(26))| & |(Sup(1)(39)) <= (Sup(1)(27))| & OK  \\
      |((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39)))|  & |(Sup(1)(46)) >= (Sup(1)(37))| &  & |(Sup(1)(48)) <= (Sup(1)(39))| & OK  \\
      |((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(40)), (Sup(1+)(41)), (Sup(*)(42)))|  & |(Sup(1)(46)) >= (Sup(1)(40))| &  & |(Sup(1)(48)) <= (Sup(*)(42))| & OK  \\
      |((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))|  & |(Sup(1)(31)) >= (Sup(1)(46))| &  & |(Sup(1)(33)) <= (Sup(1)(48))| & OK  \\
      |((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(43)), (Sup(1+)(44)), (Sup(*)(45)))|  & |(Sup(1)(13)) >= (Sup(1)(43))| & & |(Sup(1)(33)) <= (Sup(*)(45))| & OK  \\
  \end{tabular}

  So, the annotated program is properly annotated. But this is not the only annotated program that satisfies the
  above constraints. For example, set all annotations to |*| and verify that constraints still hold. However, set
  all annotations to |0| to find out that not all combinations are allowed. In the next chapter, we determine
  a least solution to the constraints, which means a highest upper bound, a least lower bound, and a most precise
  usage annotation.

  The remainder of this chapter delves more precisely into each subject that is encountered in this section.

\section{Language}
\label{sect.ExprLanguage}

  As mentioned before, the language in this chapter is a simply typed
  lambda calculus without |let| bindings. The latter means no (recursive) |let|, but
  there are bindings by lambda abstraction:

%%[[wrap=code
  expr  ::=  int           -- integer expression (Int)
        |    var           -- variable expression (Var)
        |    expr + expr   -- plus operator (Plus)
        |    expr expr     -- application (App)
        |    \var -> expr  -- lambda abstraction (Lam)

%%]

  Types are assigned to each subexpression. The language of types is:

%%[[wrap=code
  tau  ::=  Int      -- tycon int (Int)
       |    (->)     -- tycon arrow (Arrow)
       |    tau tau  -- type application (App)
%%]

  We assume that all programs are correctly typed according to the type
  system in Figure~\ref{RulerUniquenessExamples.E.expr.base}.

  \rulerCmdUse{RulerUniquenessExamples.E.expr.base}


\section{Types, Annotations and Constraints}
\label{sect.TpAnnConstr}

  For the uniqueness type system, we extend the language of types to include
  the annotations encountered in the examples. These annotations are
  attached to type constructors:

%%[[wrap=code
  utau  ::=  Sup(Int)((low,use,up))   -- tycon int (Int)
        |    Sup((->))((low,use,up))  -- tycon arrow (Arrow)
        |    utau utau                -- type application (App)

  low   ::=  0 | 1                    -- lower-bound usage-count annotation
  use   ::=  0 | 1- | 1 | 1+ | *      -- usage annotation
  up    ::=  0 | 1 | *                -- upper-bound usage-count annotation
%%]

  Why annotate the type constructors? Consider how a value is represented in
  memory. The type constructors of a type partition the memory representation
  of a value. Each area of memory for a certain value is associated with a
  single type constructor in the corresponding type. We get the usage
  properties of an area of memory by looking at the annotations on the
  corresponding type constructor.

  Another question is: why is the arrow type constructor annotated? There are
  several reasons. From a practical view considering code generation: functions
  are also values: \emph{closures}. Such a value is represented by an area of
  memory, and can be unique or shared like any other value. From a more
  theoretical point of view, unique functions have the property that they can
  be safely inlined~\cite{Wansbrough:PhDThesis}. So, the arrow type constructor is
  annotated as well, like any other value.

  A type constructor gets a tripple with three annotations: a lower-bound usage-count annotation,
  a usage annotation, and an upper-bound usage-count annotation. The values of
  the two bound annotations are totally ordered. The use-annotations are partially
  ordered, but almost uncomparable: |0 <= 0, 1- <= 1-, 1- <= *, 1 <= 1, 1+ <= 1+, * <= *|. This is
  where the term coercion comes from. The fact that a value is used at most once may be forgotten, but
  can require the insertion of some coercion function, depending on the optimizations of the back-end.

  A tripple is consistent if the usage annotation fits into the boundaries given by the two boundary
  annotations. See Figure~\ref{code.FitsInBounds} for a specification of a usage
  annotation fitting between the two boundary annotations.

  \begin{figure}
  \label{code.FitsInBounds}
%%[[wrap=code
  fits  (0,  0,   0)  = True
  fits  (1,  1,   1)  = True
  fits  (1,  1+,  h)  = h >= 1
  fits  (_,  1-,  1)  = True
  fits  (l,  *,   h)  = l <= h
  fits  (_,  _,   _)  = False
%%]
  \end{figure}

  The ordering are important. The analysis gets as input an annotated
  program and produces a set of constraints that hold between the annotations,
  if the annotations are valid. The semantics of these constraints make heavy
  use of the fact that one annotation is greater or equal to another annotation,
  as we will see in Section~\ref{Sect.CheckingConstraints}.

  There are three types of constraints for the type system in this chapter:

%%[[wrap=code
  constr  ::=  (low,use,up) =>= (low,use,up)                          -- coercion
          |    (low,use,up) (Sub(=>=)(s)) (low,use,up)                -- coercion (ignores use)
          |    (low,use,up) \+/ ... \+/ (low,use,up) <= (low,use,up)  -- aggegration
%%]

  As demonstrated in the examples, the |=>=| constraint is used to propagate usage
  information. It specifies that the lower bound on the left-hand side is greater
  than the lower bound on the right-hand side. Vice versa, it specifies that
  the upper bound on the left-hand side is smaller than the upper bound on the
  right-hand side. Finally, it specifies that the two usage values are equal,
  unless the left-hand side can be coerced into the right-hand side.

  With the |=>=| constraint, we essentially check that all boundary information is
  properly propagated from outermost expression to innermost expression, from
  body to parameters. The usages of values bound to identifiers, are treated separately
  for each use-site of an identifier and added to each other by using the |\+/|
  constraint. Section~\ref{Sect.CheckingConstraints} describes how the constraints are
  checked.

\section{Gathering constraints}
\label{Sect.ConstraintGathering}

  This section lists type rules for the uniqueness type system. Figure~\ref{RulerUniquenessExamples.U1.prog.base} defines
  that an annotated program is valid when the gathered constraints are satisfied. Section~\ref{Sect.CheckingConstraints}
  deals with constraint satisfiability. Constraints are gathered according to the expression type rules in
  Figure~\ref{RulerUniquenessExamples.U1.expr.base}. We will now consider the rules in more detail.

  \rulerCmdUse{RulerUniquenessExamples.U1.prog.base}

  The type rule for the whole program (Figure~\ref{RulerUniquenessExamples.U1.prog.base}) states that the resulting expression has a lower and upper bound of |1|. By assuming
  that all the tripples are consistent, this means that the resulting expression can have an arbitrary usage value (except not 0). We pattern
  match on the annotated type of the expression to obtain the annotation |delta| on the outermost type constructor and generate a constraint
  that specifies that the lower bound is at least |1| and the upper bound is at most |1|. This constraint, and the
  constraints gathered from the expression itself, must be satisfied for the program to be valid according to
  the uniqueness type system.

  Types are written in two ways in the type rules. A type written as |utau| has annotations. A type written as
  |tau| has no annotations. We sometimes write |(Sub(tau)(a))| to refer to the unannotated version of |(Sub(utau)(a))|.
  A |utau| is also denoted as |Sup(tau)(delta)|, where |delta| is the outermost\footnote{In this chapter, this is the tripple on the outermost type constructor of the type expression. In the presence of data type, this is the outermost annotation on the result-kind of the type expression.} annotation.

  \rulerCmdUse{RulerUniquenessExamples.U1.expr.base}

  Constraints for an expression are gathered by a traversal over the expression, as is described by Figure~\ref{RulerUniquenessExamples.U1.expr.base}.
  The case for integers is the easiest: integers can be produced for any usage annotation and nothing has to be checked for them. We neither have to check anything
  for the use-sites of identifiers, since we deal with these identifiers in the case for lambda abstraction.

  The case for integer addition is slightly more complicated. Aside from consistency, there are no demands on the uniqueness
  component of the result of the addition. On the other hand, we check that the upper and lower bound annotations of the parameters are
  properly propagation from result of the addition to the arguments of the addition. For that, a |(Sub(=>=)(s))| constraint is generated
  between the tripple on the result type and the tripples on the argument types.

  The function application is perhaps the most difficult case in the uniqueness type system. Three things have to be done: check
  that the bounds of the function are in agreement with the bounds of the function application. Check that the bounds of the
  function application and the usage annotation are in agreement with the bounds and usage annotation of the value of the
  function. Finally, check that the bounds and usage annotation of the argument is in agreement with the bounds and usage
  annotation of the parameters.

  For checking propagation, we bring to the attention that the value passed to a function, or the value returned by the function, can
  be a function itself. Propagation deals with all annotated type constructors in the type to make sure that argument and parameter, and
  function result and result, are properly connected. Note that variance plays a role here: the direction of an argument of a function
  is the opposite to the result of the function. Suppose that a function |f| is passed to function |g| as parameter, then |g| applies the
  function, and passes some argument |x|. Propagation is from |x|, to the parameter of |g|, and inside |g| to the result-value of |g|. The
  flow of boundaries and usage information for such an annotation is the other way around than the usual flow. In Figure~\ref{RulerUniquenessExamples.U1.flow.base} we list the
  type rules that walk over the type and generate the |=>=|-constraints for each two corresponding annotations in the proper direction.

  \rulerCmdUse{RulerUniquenessExamples.U1.flow.base}

  The last case to deal with is lambda abstraction. We use an auxiliary rule that gathers all annotated types of the use-sites of the
  identifier of the lambda. There is no check between the tripple of the result of the body and the result-part of the
  annotated type of the lambda function. As is visible in the type rules, we force the annotated types to be exactly the same. A
  function application can weaken the bounds and usage information of the result, if needed.

  As a final note about the type rules: the type system can be formulated in a less complicated, but not syntax directed, way. By adding
  an additional case for coercions, the places where we generated a |=>=|-constraint can be extracted and handled by this special
  non-deterministic rule. However, that would make it unclear at which places the |=>=| constraint is generated, and that is actually
  what we want to make explicit, so we choose for a more elaborate, syntax directed, representation of the type rules.

\section{Checking constraints}
\label{Sect.CheckingConstraints}

  We define precisely when a constraint is satisfied or not:

%%[[wrap=code
satisfied :: Check
satisfied  (a =>= b)                                   = a `coercionSatisfied` b
satisfied  (a (Sub(=>=)(s)) b)                         = a `weakCoercionSatisfied` b
satisfied  ((Sub(a)(1)) \+/ ... \+/ (Sub(a)(2)) <= a)  = [(Sub(a)(1)) ... (Sub(a)(n))] `sumSatisfied` a
%%]

  \subsection{Coercion constraints}
  
  For a coercion constraint, the lower bound of the left-hand side should be
  greater than the lower bound of the right-hand side. It is the other way around
  for the upper bound. If the coercion is weak, then the usage annotation is ignored,
  otherwise the right-hand side should be more specific than the left-hand side:

%%[[wrap=code
coercionSatisfied (a, b, c) (d, e, f)
  = a >= d && e <= b && c <= f
weakCoercionSatisfied (a, b, c) (d, e, f)
  = a >= d && c <= f
%%]

  This constraint is generated in such a way that we may weaken what we know on the
  right-hand side, to obtain the left-hand side. Depending on code generation, some
  coercion function may need to be inserted, for example, to move a value from a
  compile-time garbage collected heap to a runtime garbage collected heap. For a code
  generator that only selects special operations for types that are used at most once,
  no coercion function is required.

  \subsection{Sum constraint}

  For the sum constraint, we conservatively approximate the upper and lower bound. Things
  are a bit more complicated for the usage annotation. We check that the usage annotation
  is properly split up to the individual use sites (Figure~\ref{splitFunc}). We mean with this that if a value
  is linear, that one use site is linear and all the other use sites are not used at all.
  
  \begin{figure}
  \label{splitFunc}
  \caption{The isSplit function.}

%format eenp = (Sup(1)(+))
%format eenm = (Sup(1)(-))

%%[[wrap=code
isSplit as 0     = all (== 0) as
isSplit as 1     =  let (eq0, neq0) = partition (== 0) as
                    in length neq0 == 1 && head neq0 == 1
isSplit as eenp  = length as > 0 && any (== 1+) as && all (/= 0) as && all (/= 1) as
isSplit as eenm  = all (== 1-) as
isSplit as *     = all (== *) as
%%]
  \end{figure}
  
  The definition is quite straightforward:

%%[[wrap=code
sumSatisfied [((Sub(a)(1)), (Sub(b)(1)), (Sub(c)(1))), ..., ((Sub(a)(b)), (Sub(b)(n)), (Sub(c)(n)))] (d, e, f)
  =   (Sub(a)(1)) `max` ... `max` (Sub(a)(n)) >= d
  &&  (Sub(c)(1)) + ... + (Sub(c)(n)) <= f
  &&  isSplit [(Sub(b)(1)), ..., (Sub(b)(n))] e
%%]

  There is at this moment only a single exection path possible during the evaluation of
  the program. This changes in Chapter~\ref{chapt.Parallel}. In that chapter, we change
  this constraint as well, to deal with mutual exclusive occurrences.



\section{Conclusion}

  We showed in this chapter what we mean with uniqueness typing, be it with a simple language. Our approach
  consists of a set of type rules that specify when a program is correctly annotated with usage annotations.
  We turn this problem into a constraint satisfaction problem, which gives us a separation between the
  gathering of the constraint and the checking of them. In the next chapter, we show that the
  constraints also allow us to \emph{infer} usage annotations, instead of requiring that they are supplied
  by the programmer.

  In this chapter, we also told that usage annotations are not sufficient. We required lower-bound and upper-bound annotations
  as well. In the next chapter, we switch to inferring uniqueness properties, and there we infer these bounds as well.

%%]

