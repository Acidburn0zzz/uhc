%%[main

%format sumtuples = "\sum_{i}"

\chapter{Lambda calculus without bindings}
\label{chapt.NoBindings}

In the introduction (Chapter~\ref{chapt.Introduction}) we showed that functional programs perform a lot of copying
in order to preserve referential transparency in the presence of destructive updates. The work in this chapter
makes it possible to get similar performance of destructive updates in imperative programs. Two steps are needed to get this
done: the first step is to analyse which values are guaranteed to be used at most once, and the second step
is to insert special code for destructive updates on values that are used at most once. We devote this entire
thesis to the first step, and leave the second step as future work.

This chapter presents a uniqueness type system for a severely restricted language: simply-typed lambda calculus
with no |let| bindings, but with integers and an addition operator. Although restricted, this languages serves well to
discuss the fundamentals of uniqueness typing, and our implementation of the uniqueness type system. In subsequent
chapters, we extend the language with features, until most of Haskell is covered.

This chapter is organized as follows. We start with an overview of the system and some small examples to give a general
feeling about our approach. Then we provide a rather large example that demonstrates the approach in detail. This example
touches several aspects of our approach, such as the definition of the language, constraint gathering, and constraint
solving. In the remainder of the chapter, we treat these aspects in a more formal fashion.


\section{Intuition}

  We start with an overview of the uniqueness type system. The system consists of two parts. The first part deals with
  constraint generation and the second part deals with constraint solving. This separation is not relevant at this
  point, but is important for separating concerns later in this thesis. The application of an implementation of this
  type system to an expression, we call a uniqueness analysis.

  As we mentioned in the introduction, there are boundaries to what is decidable and what is not. To keep the analysis
  feasible, we associate uniqueness properties with the type of a value and not with a value itself. The analysis is
  conservative: if a type is unique, we know that it is used exactly once, but if it is not, it can be unique but is
  probably not.

  \subsection{Annotations}

  Instead of just classifying types as unique or shared, we distinguish five different values:

%%[[wrap=code
  data Usage
    =  Zero          -- not used (0)
    |  Affine        -- at most used once (1-) "unique"
    |  Linear        -- exactly used once (1)
    |  Strict        -- at least used once, possibly more (1+)
    |  Arbitrary     -- arbitrary usage (*) "shared"
%%]

  We call this usage value the \emph{cardinality}~\cite{jur} of a value. Later in this thesis, we associate a
  cardinality annotation with a type constructor. This annotation has nothing to do with the number of arguments
  of a type constructor in this thesis. It specifies how often a certain value is used.

  Some optimizations demand that a value is exactly used once, while for other optimizations it is sufficient that a value
  is used at most once, which is slightly less demanding. Our approach can verify both uniqueness properties and
  strictness properties. Although our focus is on uniqueness properties, we consider strictness as well, since we get it
  almost for free with our approach. We still call our approach uniqueness typing, but it is technically more than that.

  To specify that a value |v| of type |Int| is exactly used once, we write: |v :: (Sup(Int)(1))|. The |1| is a
  cardinality annotation specifying that the values corresponding to the |Int| type constructor, are used exactly
  once. Likewise, if |f| is a function with annotated type |f :: (Sup(Int)(1)) (Sup(->)(1)) (Sup(Int)(*))|, then |f| is a function that is used
  exactly once, producing a value that requires to be used any number of times, and states that the parameter is used
  exactly once, and may not be used elsewhere.

  The analysis expects a program annotated in this fashion and verifies that the annotations are correct (inference in
  Chapter~\ref{chapt.Polyvariant}). Unfortunately, we cannot easily formulate the conditions of when an annotation is
  correct or not. We have to check two things: does the annotation fit with related annotations (the context), and
  does the annotation fit with the number of references there are to the value. With context we mean that if two types are unified,
  that their annotations also unify. For example, a value with cardinality |1| cannot be passed to a function that has a |onemin| cardinality for its parameter,
  because the function cannot guarantee that the value will always be used. With the number of references we mean the
  guaranteed upper and lower bound on the number of times the value will be evaluated or referenced. For example, a value
  that is referenced at least once cannot have the cardinality annotation |0|. We have sufficient information for the
  context check (which is basically a form of unification), but insufficient information for the reference-check.

  We therefore ask the programmer to specify the upper and lower bound as well. The types in an expression are
  thus annotated with three (!) annotations. A cardinality annotation, a lower-bound usage-count annotation,
  and an upper-bound usage-count annotation. The lower-bound usage-count annotation tells us that a value is at
  least used a certain number of times, and the upper-bound usage-count annotation tells us that a value is at most
  used a certain number of times. The reference check demands that the cardinality annotation is in between
  these bounds (Figure~\ref{code.FitsInBounds}). The upper and lower bound can be verified by means of an
  analysis, which in turn means that we can verify the cardinality annotations.

  We explain by means of an example how these three annotations interact and how we formulate the checks into
  a constraint satisfaction problem. Unfortunately, that is rather hard to grasp at this point, so we defer
  the explanation to Section~\ref{sect.BigExample}. Instead, we discuss how to check the upper-bound
  usage-count annotations here, since the checks on the lower-bound usage-count and also the context-check on the
  usage annotations themselves are quite similar. This will become clear in Section~\ref{sect.BigExample}.

  \subsection{Checking the upper-bound usage-count annotation}

  An upper-bound usage-count annotation |u| specifies that the corresponding values are at most used
  |u| times:

%%[[wrap=code
  data UpperBound
    | 0             -- not used
    | 1             -- at most used once
    | *             -- arbitrary usage, but typically represents a number greater than one
%%]

  We assume that expressions are annotated with upper-bound usage-count annotations. That means that
  all type constructors occurring in the types of an expression have an upper-bound usage-count annotation.
  For example, an annotated version of the expression |(\x -> x) 3| is:

%%[[wrap=code
  (\x -> x) 3
  (((\(x :: (Sup(Sub(Int)(a))(1))) -> x :: (Sup(Sub(Int)(b))(1))) :: (Sup(Sub(Int)(c))(1)) (Sup(Sub(->)(d))(1)) (Sup(Sub(Int)(e))(1))) (3 :: (Sup(Sub(Int)(f))(1)))) :: (Sup(Sub(Int)(g))(1))
%%]

  This looks quite intimidating, but let us consider what is displayed here. The outermost expression is annotated
  with |(Sup(Sub(Int)(g))(1))|, which means that the result of the expression is used at most once. The outermost expression
  is an application of an argument to a function. The annotated type of the function is |(Sup(Sub(Int)(c))(1)) (Sup(Sub(->)(d))(1)) (Sup(Sub(Int)(e))(1))|. The annotation on the
  arrow type constructor, (Sup((Sub(->)(d)))(1)), specifies that the function is used at most once. The annotation
  |(Sup(Sub(Int)(c))(1))| specifies that the parameter is used at most once, and |(Sup(Sub(Int)(e))(1))| demands
  that the result is used at most once. The annotation |(Sup(Sub(Int)(f))(1))| specifies that the argument
  is used at most once. The annotation on the parameter of the function and the annotation on the argument of the
  function are related to each other. Likewise, the annotation on the result of the function is related to the
  annotation on the function application. The annotation of the parameter of the function is related to the
  annotation of the result of the function, but that depends on the structure of the body of the function.
  Take a moment to get a clear picture of the annotations and their meaning.

  Are these annotations correct? For this example, it is not difficult to see that indeed the value |3| is not used
  more than once, but we need a systematic approach to verify this. We check the annotations by a traversal over the
  structure of the expression, and approximate the upper bound from below. By computing an approximation of a least
  upper bound, we check that the upper bound provided by the programmer is high enough to be an upper bound for any
  execution of the program. In other words, we determine from the structure of the program that the upper bound
  should be at least |m| to be an upper bound, and verify that the upper bound given by the programmer is at least
  |m|. The upper bound is allowed to be higher than is strictly necessary (safe approximation).

  The root of the expression is the starting point. When execution the expression, the root
  is evaluated once to obtain the value. So, the upper bound for the root of the expression is at least |1|. The annotated
  type of the root, |(Sup(Int)(1))|, is therefore correct. The root of the expression is a function application. Since the
  annotation is correct, it means that the upper bound for the function application is at least the upper bound of the
  root of the expression, thus at least |1|. The function is at least as often used than the function application, so
  the upper bound of the function is at least the upper bound of the function application, thus at least |1|. The annotation
  on |(Sup(Sub(->)(d))(1))| is correct. The same reasoning applies to the result of the function. The upper bound of the result
  of the function is at least the upper bound of the function application . The annotation on |(Sup(Sub(Int)(e))(1))| is correct.

  Now the function and the argument. Consider the argument first. The function fully determines how often it
  is used. The upper bound of the argument is at least the upper bound of the parameter of the function. The annotation
  on |(Sup(Sub(Int)(c))(1))| is the upper bound of the parameter, thus the upper bound of the argument is at least
  |1|. |(Sup(Sub(Int)(f))(1))| is correct. Of course, we have to verify that the upper bound of the parameter of the
  function is |1|. We take a look at the function. The body of the function has an upper bound of |1|, because the the result
  of the function has an upper bound of |1|. The body of the function is a use of parameter |x|. So, the upper bound for
  this occurrence of |x| is |1|. The annotation on |(Sup(Sub(Int)(b))(1))| is correct. The upper bound for the parameter
  |x| is at least the sum of the upper bounds of the occurrences. There are no other occurrences of |x|,
  so the aggregated upper bound of |x| is |1|. We come back to this specific subject later. The annotation on
  |(Sup(Sub(Int)(a))(1))| is correct. Again, take a moment
  to get a mental picture of how the abstract syntax tree is compared and how annotations are compared from outermost
  expressions to innermost expressions and from left to right.

  An important step is the aggregation of upper bounds for occurrences of an identifier. The following variation of
  the above example shows why it is important:

%%[[wrap=code
  (\x -> x + x) 3
  (\((Sub(x)(0)) :: (Sup(Sub(Int)(a))(*))) -> ((Sub(x)(1)) :: (Sup(Sub(Int)(b))(1))) + ((Sub(x)(2)) :: (Sup(Sub(Int)(c))(1)))) (3 :: (Sup(Sub(Int)(d))(*)))
%%]

  The number of times a value bound to |(Sub(x)(0))| is used, is the aggregated number of times the value is used as |(Sub(x)(1))| and
  |(Sub(x)(2))|. Any actual usage count for |(Sub(x)(1))| or |(Sub(x)(2))| is lower than their corresponding upper bound. A safe approximation for
  a least upper bound of |(Sub(x)(0))| is the sum of the upper bounds of |(Sub(x)(1))| and |(Sub(x)(2))|. As the example shows, the upper
  bounds of |(Sub(x)(1))| and |(Sub(x)(2))| are both |1|, so the sum is |*| and the annotation is correct.

  As we mentioned several times already, a conservative approximation of the upper bound is allowed. The upper bound may
  be higher than it practice will be the case. For example, if we know that a value is not used, we may also assume that
  it is at most used once. Furthermore, assuming that some value is used an arbitrary number of times is always allowed. It
  is safe to pretend that the upper bound is higher than is actually the case, but it makes the analysis result less accurate.

  The following example is a variation upon the earlier example where some of the annotations are higher than
  is strictly necessary:

%%[[wrap=code
  (\x -> x) 3
  (((\(x :: (Sup(Sub(Int)(a))(*))) -> x :: (Sup(Sub(Int)(b))(1))) :: (Sup(Sub(Int)(c))(*)) (Sup(Sub(->)(d))(*)) (Sup(Sub(Int)(e))(1))) (3 :: (Sup(Sub(Int)(f))(*)))) :: (Sup(Sub(Int)(g))(1))
%%]

  We verify again that these annotations are correct. The outermost expression is used at most once, so
  the upper bound is at least |1|. The annotation on |(Sup(Sub(Int)(g))(1))| is correct. The upper bound for
  the function itself is at least as high as the upper bound for the function application. The upper bound
  for the function is |*|, which is at least as high as the upper bound of |1| of the function application.
  The annotation on |(Sup(Sub(->)(d))(*))| is correct. The result of the function has an upper bound of |1|,
  which is at least as high as the upper bound of |1| of the function application. The annotation on
  |(Sup((Sub(Int)(e)))(1))| is correct. The aggregated upper bound for |x| is at least the sum of the upper bounds of
  the occurrences of |x|, which in this case is |(Sup(Sub(Int)(b))(1))|. The annotation on
  |(Sup(Sub(Int)(a))(*))| is higher, but that is allowed, so it is correct. Consequently, our traversal of the
  expression demands that the the annotations on |(Sup(Sub(Int)(c))(*))| and |(Sup(Sub(Int)(f))(*))| are at
  least the annotation on |(Sup(Sub(Int)(a))(*))|, which is correct.

  To summarize: what our analysis does is to start with some known information about the root of the expression
  and `push' it through the abstract syntax tree from outermost to innermost, and in case of functions from result to
  arguments based on the body. A mental picture is that there is an `flow' of count-information from the
  root of the expression to the leaves. We say that the analysis 'propagates' counts. We see in later sections that
  dealing with a lower bound, and dealing with usage annotations, is not much different than what we did in
  this section.

\section{The next step}
\label{sect.BigExample}

  With the intuitions gained in the previous section, we introduce a constraint-based approach to uniqueness
  typing. For example, for the upper bound analysis of the previous section, we generate a constraint
  |... =>= ...| for each time we wrote `at least', and a constraint |... \*/ ... \*/ ... <= ...| where
  we aggregated upper bounds. It that it? Yes, that is it basically, because we will show that the
  same constraints can be used for the lower bound analysis and the analysis for the actual usage
  values.

  The running example in this section is the following expression:

%%[[wrap=code
  (\x y -> (y + x) + x) 3 4
%%]

  The result of this program is evaluated once when the program is executed. Consequently, the results of
  both additions are used once, and thus is the |x| parameter used twice and the |y| parameter once. Which
  in turn means that the value |3| is used twice and the value |4| once. In terms of usage, |3| the
  value |3| is linear (exactly once), and the value |4| is strict (more than once).

  Efficient code can be produced with this usage information. A conventional implementation of addition in a pure,
  lazy language, evaluates both arguments, allocate memory for an integer, and store the result of
  the addition there. But in this case, there is no need to allocate memory for the result of the additions.
  Since the value passed to |y| is linear, the value of |x| can be added directly to the value of |y|
  (destructively updating the value of |y|). The result of the addition is again linear, and the
  value of |x| can be added directly again for the second addition. The result: less memory allocation,
  less copying, and better cache utilization. If the compiler also inlines functions that are at most
  used once, and evaluates strict values before passing it to a function, then this code is as efficient
  as a corresponding imperative program.

  \subsection{Annotations}

  Usage information is encoded as a cardinality annotation on the type constructors in the type of a value. The type
  specifies how much certain regions of a value are used (Section~\ref{sect.TpAnnConstr}). As mentioned
  in the introduction, a type has three annotations. This looks horrible, but unfortunately, we cannot
  do anything against it until next chapter.

  As an example of a triple of annotations, consider the type |(Sup(Int)((1,oneplus,*)))|. The first
  annotation is the lower-bound usage-count annotation, which specifies that the value is at least used once.
  The second annotation is the cardinality annotation, specifying that the value is strict, meaning that it is used
  one or more times. The third annotation is the upper-bound usage-count annotation, which specifies
  that the value is at most used an arbitrary number of times. This triple is consistent if the lower bound
  is smaller or equal than the cardinality annotation, and the usage annotation is smaller or equal to the upper bound.
  The smaller or equal relation is defined between the three types of annotations in the obvious way, and
  consistency for a triple is defined in Figure~\ref{code.FitsInBounds}.

  For the above example, a possible annotation is:

%%[[wrap=code
    (  (\x y ->  (  (  y :: (Sup(Int)((1, 1, 1)))
                    +  x :: (Sup(Int)((1, oneplus, *)))
                    ) :: (Sup(Int)((1, 1, 1))))
                 +  x :: (Sup(Int)((1, oneplus, *)))
                 ) :: (Sup(Int)((1, 1, 1)))
       ) :: (Sup(Int)((1, oneplus, *))) (Sup(->)((1, 1, 1))) (Sup(Int)((1, 1, 1))) (Sup(->)((1, 1, 1))) (Sup(Int)((1, 1, 1))))
       (3 :: (Sup(Int)((1, oneplus, *)))) (4 :: (Sup(Int)((1, 1, 1)))
    ) :: (Sup(Int)((1, 1, 1)))
%%]

  This looks quite intimidating, but that is just because there are a lot of types involved and the
  annotations take much space. In the next chapter, we infer all annotations, and the lower
  and upper bound annotations become implicit, resulting in cleaner types (Section~\ref{sect.TheInferencer}).
  But we first have to do the dirty work here.

  \subsection{Checking the annotations}

  How to check that the annotated typing of a program is valid? First we check that the program is correctly
  typed for the conventional type system of simply typed lambda calculus. Secondly, we check that all
  triples of annotations are consistent. Then it is time for the real work:
  gather a set of constraints from the annotated program, and check if the constraints are satisfied. When the
  constraints are satisfied, the annotations are correct and the program is correctly typed according to the
  uniqueness type system.

  As a side note, in order to keep the explanation compact, we are a bit
  sloppy in distinguishing identifiers, values and types. For example, if we talk about the upper bound of
  a function, we intend the upper-bound usage-count annotation on the type constructor associated with the
  value representing the function. Or when we talk about the cardinality of an expression, we actually mean how
  often the value corresponding to the expression is used. So, assume that the notion of obtaining a cardinality annotation, upper bound,
  and lower bound is overloaded for identifiers, expressions, values, types and type constructors in the obvious way.

  We illustrate the constraints by analyzing the example\footnote{For clarity, the annotations values have a number
  superscripted to show where they appear in the constraints.}. For a description of the constraints and their
  meaning, check Section~\ref{sect.TpAnnConstr}. We reason about a program in an outermost-to-innermost way. We
  start with the entire program (expression):

%%[[wrap=code
    ( ... ) :: (Sup(Int)(((Sup(1)(1)), (Sup(1)(2)), (Sup(1)(3)))))
%%]

  The result of the entire expression is exactly used once. However, we are allowed to be less accurate for the result
  of the entire expression. Any usage value that is consistent is allowed. We generate the constraint |(1, *, 1) (Sub(=>=)(s)) ((Sup(1)(1)), (Sup(1)(2)), (Sup(1)(3)))|. This constraint specifies that the lower bound
  is at most |1|, the upper bound is at least |1|, and the cardinality annotation can be anything as long as it is consistent with
  the two bounds in the triple. The subscript |s| indicates that the usage annotation is ignored in this constraint. A |=>=| constraint
  without the |s| suffix is encountered later in the example. The generated constraint expresses what we know about the result of the entire expression. We call this
  constraint a flow or propagation constraint, because with some imagination, it `pushes' values on the
  left-hand side to the right-hand side. We often call a |=>=| constraint a coercion, which is explained in the next
  section.

  One step into the expression, an application is encountered:

%%[[wrap=code
    (( ... :: (Sup(Int)(((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))))) (Sup(->)(((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9))))) (Sup(Int)(((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))))) (4 :: (Sup(Int)(((Sup(1)(13)), (Sup(1)(14)), (Sup(1)(15))))))) :: (Sup(Int)(((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18)))))
%%]

  Several constraints are generated for a function application:

  \begin{itemize}
  \item The function application and the function. The number of usages of the function depends on the number of usages of the
        function application. We generate the constraint |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) (Sub(=>=)(s)) ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))|.
        The lower bound of the function (|(Sup(1)(7))|) is at most the lower bound of the function application (|(Sup(1)(16))|). The upper bound of
        the function (|(Sup(1)(18))|) is at least the upper bound of the function application (|(Sup(1)(9))|). The constraint
        expresses precisely how often the function is used, if we know how often the function application itself is used.
        The cardinality annotations are unrelated, since the memory occupied by the function has nothing to do with the memory
        occupied by the result of the function.
  \item The function application and result of the function. The number of uses of the result of the function application depends on
        how often the function application itself is used. We generate the constraint |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) =>= ((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))|.
        The lower bound of the result of the function (|(Sup(1)(10))|) is at most the lower bound of the function application (|(Sup(1)(16))|). The upper bound of
        the result of the function function (|(Sup(1)(18))|) is at least the upper bound of the function application (|(Sup(1)(11))|). The cardinality annotation (|(Sup(1)(12))|)
        of the result of the function should be equal (modulo coercion) to the cardinality annotation of the function application (|(Sup(1)(17))|).
  \item The function and the argument of the function application. The uses of the argument of the function
        application depend on the annotations of the parameter of the function. We generate the constraint |((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))) =>= ((Sup(1)(13)), (Sup(1)(14)), (Sup(1)(15)))|.
        The semantics of the constraint capture the relations between the three annotations on the type of the function parameter and
        the type of the argument value.
  \end{itemize}

  The remainder of the constraints are obtained by analysing the function expression and the argument expression. There is no constraint generated for
  the argument expression, since that is an |Int| expression, and each consistent triple is valid. In other words: the value |3| can
  represent a linear |Int|, but also a strict |Int| or an affine |Int|. So, verifying the function expression is what remains.

  The function expression is again an application:

%%[[wrap=code
    ( ... :: (Sup(Int)(((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21))))) (Sup(->)(((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24))))) ((Sup(Int)(((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27))))) (Sup(->)(((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30))))) (Sup(Int)(((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))))))
      (3 :: (Sup(Int)(((Sup(1)(34)), (Sup(oneplus)(35)), (Sup(*)(36))))))
        :: (Sup(Int)(((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))))) (Sup(->)(((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9))))) (Sup(Int)(((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))))
%%]

  This is basically the same situation as above, except with one important difference. The type of the result of the
  function application is a function. Its type has more than one type constructor, and multiple triples of annotations.
  Each type constructor in one type has a corresponding type constructor in the other type. The |=>=| constraint is generated
  between triples attached on corresponding type constructors. This way we check annotations that specify
  usages of the same regions of a value. The direction of the |=>=| constraint depends on co-variance and contra-variance. The
  direction is reversed for |=>=| constraint between |contra-variant| type constructors. The reason is that co-variant type
  constructors correspond to values for which the annotation require some property (``I must be used exactly once''), whereas
  contra-variant type constructors correspond to values for which the annotations provide some property (``I am used exactly once''),
  which is essentially the inverse direction. See Peyton Jones~\cite{peytonjones04pract-inf-rank} for an elaborate explanation
  on co-variance and contra-variance and subtyping.

  Applying the same reasoning as with the previous function application, we generate the following constraints:

%%[[wrap=code

    ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))           (Sub(=>=)(s))  ((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24)))        -- use of the function
    ((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))        =>=            ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))        -- use of the function value (resulting Int, co-variant)
    ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))           =>=            ((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30)))        -- use of the function value (function type, co-variant)
    ((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))        =>=            ((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6)))           -- use of the function value (argument Int, contra-variant)
    ((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21)))  =>=            ((Sup(1)(34)), (Sup(oneplus)(35)), (Sup(*)(36)))  -- use of the argument
%%]

  This leaves to analyse the function of the function application, and the argument of the function application. The argument
  is again an |Int| expression, which does not result in constraints, so we proceed with the function expression.

  The function expression is a lambda abstraction:

%%[[wrap=code
    ( \(x :: (Sup(Int)(((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21)))))) (y :: (Sup(Int)(((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))))) -> ... y :: (Sup(Int)(((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39))))) ... (Sub(x)(1)) :: (Sup(Int)(((Sup(1)(40)), (Sup(oneplus)(41)), (Sup(*)(42))))) ... (Sub(x)(2)) :: (Sup(Int)(((Sup(1)(43)), (Sup(oneplus)(44)), (Sup(*)(45)))))
    ) :: (Sup(Int)(((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21))))) (Sup(->)(((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24))))) ((Sup(Int)(((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27))))) (Sup(->)(((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30))))) (Sup(Int)(((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33))))))
%%]

  For a lambda abstraction, we perform two tasks: analyze the body of the lambda abstraction, and
  combine the results of the uses of the values represented by the parameters. The bounds of each
  occurrence of some parameter are individually established. We generate an aggregation constraint
  to comine the bounds and to check that the cardinality value is properly split over the
  occurrences: |triple((Sub(use_site)(1))) \*/ ... \*/ triple((Sub(use_site)(n))) <= triple(def_site)|.
  We use the safe approximation that the upper bounds are combined by addition and the lower bounds
  by taking the minimum. This approach is improved in Chapter~\ref{chapt.Parallel}.
  This constraint ensures that we check that the lower-bound is low enough and the upper-bound is high enough. Furthermore,
  the constraint ensures that if the parameter has some cardinality value |u|, that the combined
  occurrences correspond to |u|. For example, if |u| is linear, it means that one of the occurrences must be linear and
  all the other occurrences not used.

  With only one use-site of |y|, and two use-sites of |x|, the constraints are:

%%[[wrap=code
   ((Sup(1)(40)), (Sup(oneplus)(41)), (Sup(*)(42))) \*/ ((Sup(1)(43)), (Sup(oneplus)(44)), (Sup(*)(45))) <= ((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21)))  -- for x
   ((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39))) <= ((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))                                                                   -- for y
%%]

  The function body remains to be checked. The function body consists of the additions:

%%[[wrap=code
  ((y :: (Sup(Int)(((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39)))))) + ((Sub(x)(1)) :: (Sup(Int)(((Sup(1)(40)), (Sup(oneplus)(41)), (Sup(*)(42))))))) :: (Sup(Int)(((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))))
  ((( ... ) :: (Sup(Int)(((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))))) + ((Sub(x)(2)) :: (Sup(Int)(((Sup(1)(43)), (Sup(oneplus)(44)), (Sup(*)(45))))))) :: (Sup(Int)(((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33))))))
%%]

  The addition operator uses both the arguments at least as many times as the result is used. The default operational
  semantics for addition stores the result of the addition in a memory location unrelated to the arguments of the
  addition. So, cardinality annotations of the arguments of the addition are unrelated to the cardinality annotation on the result
  of the addition. But the lower-bound and upper-bound annotations of the arguments are related to the lower-bound and
  upper-bound annotations of the result of the expression. The cardinality annotation on the result of the addition may be
  any value that fits the two bounds. For the relation between the arguments of the addition and the result of the
  addition, we generate a weaker version of the |=>=| constraint that ignores the cardinality annotation, but does not
  ignore the two bounds: |(Sub(=>=)(s))|, with the |s| of 'soft'. When we want to stress the difference between these
  two |=>=| constraints, we write the normal |=>=| constraint as |(Sub(=>=)(h))|, with the |h| of 'hard'.

  The following constraints relate the result of the additions properly to the arguments of the addition:

%%[[wrap=code
    ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39)))
    ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(40)), (Sup(oneplus)(41)), (Sup(*)(42)))
    ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))
    ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(43)), (Sup(oneplus)(44)), (Sup(*)(45)))
%%]

  \subsection{Checking the constraints}

  The final part of this example is to verify that the constraints hold. We show by an example how we interpret
  the constraints. We define when a constraint hold more precisely in Section~\ref{Sect.CheckingConstraints}. We assume that
  the triples are already checked for consistency, meaning that the usage annotation fits between the upper and
  lower bound. The following table lists the constraints and their interpretation (see Figure~\ref{splitFunc} for the definition of |properSplit|):

  \begin{tabular}{llllr}
    constraint & lower bound & usage & upper bound & holds \\
    \hline
      |(1, *, 1) (Sub(=>=)(s)) ((Sup(1)(1)), (Sup(1)(2)), (Sup(1)(3)))|   & |1 >= (Sup(1)(1))| & & |1 <= (Sup(1)(3))| & OK  \\
      |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) (Sub(=>=)(s)) ((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))| & |(Sup(1)(16)) >= (Sup(1)(7))| & & |(Sup(1)(18)) <= (Sup(1)(9))| & OK  \\
      |((Sup(1)(16)), (Sup(1)(17)), (Sup(1)(18))) =>= ((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))|  & |(Sup(1)(16)) >= (Sup(1)(10))| & |(Sup(1)(17)) <= (Sup(1)(11))| & |(Sup(1)(18)) <= (Sup(1)(12))| & OK  \\
      |((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6))) =>= ((Sup(1)(13)), (Sup(1)(14)), (Sup(1)(15)))|       & |(Sup(1)(4)) >= (Sup(1)(13))| & |(Sup(1)(5)) <= (Sup(1)(14))| & |(Sup(1)(6)) <= (Sup(1)(15))| & OK  \\
      |((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))      (Sub(=>=)(s))  ((Sup(1)(22)), (Sup(1)(23)), (Sup(1)(24)))|    & |(Sup(1)(7)) >= (Sup(1)(22))| &  & |(Sup(1)(9)) <= (Sup(1)(24))| & OK  \\
      |((Sup(1)(10)), (Sup(1)(11)), (Sup(1)(12)))   =>=  ((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))|    & |(Sup(1)(10)) >= (Sup(1)(31))| & |(Sup(1)(11)) <= (Sup(1)(32))| & |(Sup(1)(12)) <= (Sup(1)(33))| & OK  \\
      |((Sup(1)(7)), (Sup(1)(8)), (Sup(1)(9)))      =>=  ((Sup(1)(28)), (Sup(1)(29)), (Sup(1)(30)))|    & |(Sup(1)(7)) >= (Sup(1)(28))| & |(Sup(1)(8)) <= (Sup(1)(29))| & |(Sup(1)(9)) <= (Sup(1)(30))| & OK  \\
      |((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))   =>=  ((Sup(1)(4)), (Sup(1)(5)), (Sup(1)(6)))|    & |(Sup(1)(25)) >= (Sup(1)(4))| & |(Sup(1)(26)) <= (Sup(1)(5))| & |(Sup(1)(27)) <= (Sup(1)(6))| & OK  \\
      |((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21)))  =>=  ((Sup(1)(34)), (Sup(oneplus)(35)), (Sup(*)(36)))|    & |(Sup(1)(19)) >= (Sup(1)(34))| & |(Sup(oneplus)(20)) <= (Sup(oneplus)(35))| & |(Sup(*)(20)) <= (Sup(*)(36))| & OK  \\
      |((Sup(1)(40)), (Sup(oneplus)(41)), (Sup(*)(42))) \*/ ((Sup(1)(43)), (Sup(oneplus)(44)), (Sup(*)(45)))| & |(Sup(1)(40)) `max` (Sup(1)(43)) >= (Sup(1)(19))| & |properSplit {(Sup(oneplus)(41)), (Sup(oneplus)(44))} (Sup(oneplus)(20))| & |(Sup(1)(42)) + (Sup(1)(45)) <= (Sup(1)(21))| & OK  \\
      |  <= ((Sup(1)(19)), (Sup(oneplus)(20)), (Sup(*)(21)))|   & & & & \\
      |((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39))) <= ((Sup(1)(25)), (Sup(1)(26)), (Sup(1)(27)))|  & |(Sup(1)(37)) >= (Sup(1)(25))| & |properSplit {(Sup(1)(38))} (Sup(1)(26))| & |(Sup(1)(39)) <= (Sup(1)(27))| & OK  \\
      |((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(37)), (Sup(1)(38)), (Sup(1)(39)))|  & |(Sup(1)(46)) >= (Sup(1)(37))| &  & |(Sup(1)(48)) <= (Sup(1)(39))| & OK  \\
      |((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))  (Sub(=>=)(s))  ((Sup(1)(40)), (Sup(oneplus)(41)), (Sup(*)(42)))|  & |(Sup(1)(46)) >= (Sup(1)(40))| &  & |(Sup(1)(48)) <= (Sup(*)(42))| & OK  \\
      |((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(46)), (Sup(1)(47)), (Sup(1)(48)))|  & |(Sup(1)(31)) >= (Sup(1)(46))| &  & |(Sup(1)(33)) <= (Sup(1)(48))| & OK  \\
      |((Sup(1)(31)), (Sup(1)(32)), (Sup(1)(33)))  (Sub(=>=)(s))  ((Sup(1)(43)), (Sup(oneplus)(44)), (Sup(*)(45)))|  & |(Sup(1)(13)) >= (Sup(1)(43))| & & |(Sup(1)(33)) <= (Sup(*)(45))| & OK  \\
  \end{tabular}

  All constraints are satisfied, so the annotated program is properly annotated. But this is not the only annotated program that satisfies the
  above constraints. For example, set all annotations to |*| and verify that constraints still hold. However, set
  some annotations to |0| to find out that not all combinations are allowed. In the next chapter, we determine
  a least solution to the constraints, which means a least upper bound, a highest lower bound, and a most precise
  usage annotation.

  The remainder of this chapter delves more precisely into each subject that is encountered in this section.

\section{Language}
\label{sect.ExprLanguage}

  As mentioned before, the language in this chapter is a simply typed
  lambda calculus without |let| bindings. The latter means no (recursive) |let|, but
  there are bindings by lambda abstraction:

%%[[wrap=code
  expr  ::=  int           -- integer expression (Int)
        |    var           -- variable expression (Var)
        |    expr + expr   -- plus operator (Plus)
        |    expr expr     -- application (App)
        |    \var -> expr  -- lambda abstraction (Lam)

%%]

  Types are assigned to each subexpression. The language of types is:

%%[[wrap=code
  tau  ::=  Int      -- tycon int (Int)
       |    (->)     -- tycon arrow (Arrow)
       |    tau tau  -- type application (App)
%%]

  We assume that all programs are correctly typed according to the type
  system in Figure~\ref{RulerUniquenessExamples.E.expr.base}.

  \rulerCmdUse{RulerUniquenessExamples.E.expr.base}


\section{Types, Annotations and Constraints}
\label{sect.TpAnnConstr}

  For the uniqueness type system, we extend the language of types to include
  the annotations encountered in the examples. These annotations are
  attached to type constructors:

%%[[wrap=code
  utau  ::=  Sup(Int)((low,use,up))            -- tycon int (Int)
        |    Sup((->))((low,use,up))           -- tycon arrow (Arrow)
        |    utau utau                         -- type application (App)

  low   ::=  0 | 1                             -- lower-bound usage-count annotation
  use   ::=  0 | onemin | 1 | oneplus | *      -- cardinality annotation
  up    ::=  0 | 1 | *                         -- upper-bound usage-count annotation
%%]

  The lower-bound usage-count annotation specifies that a value represented
  by the annotated type constructor, is at least used |0| or |1| times. The
  upper-bound usage-annotation specifies that a value represented by the annotated type constructor,
  is at most used |0|, |1|, or an arbitrary number of times. The cardinality annotation specifies a
  usage property for a value. For example, the cardinality annotation |onemin| means
  that the corresponding value is at most used once.

  When we write that a variable is \emph{used}, we actually mean that the memory that
  is represented by the value is touched, either for reading or for writing. If a
  value has a lower-bound usage count of |1|, then we know that its memory is
  at least touched once. If it has an upper-bound usage count of |0|, the memory
  is never touched, altough there may be references to it during program execution. Such
  references are never evaluated though.

  Why annotate the type constructors? Consider how a value is represented in
  memory. The type constructors of a type partition the memory representation
  of a value. Each area of memory for a certain value is associated with a
  single type constructor in the corresponding type. We get the usage
  properties of an area of memory by looking at the annotations on the
  corresponding type constructor.

  Another question is: why is the arrow type constructor annotated? There are
  several reasons. From a practical view considering code generation: functions
  are also values: \emph{closures}. Such a value is represented by an area of
  memory, and can be unique or shared like any other value. From a more
  theoretical point of view, unique functions have the property that they can
  be safely inlined~\cite{Wansbrough:PhDThesis}. So, the arrow type constructor is
  annotated as well, like any other value.

  A type constructor gets a triple with three annotations: a lower-bound usage-count annotation,
  a cardinality annotation, and an upper-bound usage-count annotation. The values of
  the two bound annotations are totally ordered (|0 <= 1 <= *|). Cardinality annotations are partially
  ordered, but almost incomparable: |0 <= 0, onemin <= onemin, onemin <= *, 1 <= 1, oneplus <= oneplus, * <= *|. Only
  a value that is at most used once can be weakened to a value that is used an arbitrary number
  of times. This is where the term coercion comes from. The fact that a value is used at most once
  may be forgotten, but can require the insertion of some coercion function, depending on the
  optimizations of the back-end. For example, the code generator can choose to generate code that
  allocates values that are used at most once on a compile-time garbage-collected heap, and insert a
  coercion functionthat moves the value to a runtime garbage-collected heap when the restriction
  that a value is used at most once is forgotten.

  A triple is consistent if the cardinality annotation fits into the boundaries given by the two boundary
  annotations. See Figure~\ref{code.FitsInBounds} for a specification of a cardinality
  annotation fitting between the two boundary annotations.

  \begin{figure}
  \label{code.FitsInBounds}
  \caption{Consistency of tripples}

%%[[wrap=code
  fits  (0,  0,        0)  = True
  fits  (1,  1,        1)  = True
  fits  (1,  oneplus,  h)  = h >= 1
  fits  (_,  onemin,   1)  = True
  fits  (l,  *,        h)    = l <= h
  fits  (_,  _,        _)  = False
%%]
  \end{figure}

  The orderings are important. The analysis gets as input an annotated
  program and produces a set of constraints that hold between the annotations,
  if the annotations are valid. The semantics of these constraints make heavy
  use of the fact that one annotation is greater or equal to another annotation,
  as we will see in Section~\ref{Sect.CheckingConstraints}.

  There are three types of constraints for the type system in this chapter:

%%[[wrap=code
  constr  ::=  (low,use,up) =>= (low,use,up)                          -- coercion
          |    (low,use,up) (Sub(=>=)(s)) (low,use,up)                -- coercion (ignores use)
          |    (low,use,up) \*/ ... \*/ (low,use,up) <= (low,use,up)  -- aggregation
%%]

  As demonstrated in the examples, the coercion constraint (|=>=|) is used to propagate usage
  information. It specifies that the lower bound on the left-hand side is greater
  than the lower bound on the right-hand side. Vice versa, it specifies that
  the upper bound on the left-hand side is smaller than the upper bound on the
  right-hand side. Finally, it specifies that the two cardinality values are equal,
  unless the left-hand side can be coerced into the right-hand side.

  With the coercion constraint, we essentially check that all boundary information is
  properly propagated from outermost expression to innermost expression, from
  body to parameters. The usages of values bound to identifiers, are treated separately
  for each use-site of an identifier and added to each other by using the aggregation
  constraint |\*/|. Section~\ref{Sect.CheckingConstraints} describes how the constraints are
  checked.

\section{Gathering constraints}
\label{Sect.ConstraintGathering}

  This section lists type rules for the uniqueness type system. Figure~\ref{RulerUniquenessExamples.U1.prog.base} defines
  that an annotated program is valid when the gathered constraints are satisfied. Section~\ref{Sect.CheckingConstraints}
  deals with constraint satisfiability. Constraints are gathered according to the expression type rules in
  Figure~\ref{RulerUniquenessExamples.U1.expr.base}. We will now consider the rules in more detail.

  \rulerCmdUse{RulerUniquenessExamples.U1.prog.base}

  The type rule for the whole program (Figure~\ref{RulerUniquenessExamples.U1.prog.base}) states that the resulting expression has a lower and upper bound of |1|. By assuming
  that all the triples are consistent, this means that the resulting expression can have an arbitrary usage value (except not 0). We pattern
  match on the annotated type of the expression to obtain the annotation |delta| on the outermost type constructor and generate a constraint
  that specifies that the lower bound is at least |1| and the upper bound is at most |1|. This constraint, and the
  constraints gathered from the expression itself, must be satisfied for the program to be valid according to
  the uniqueness type system.

  Types are written in two ways in the type rules. A type written as |utau| has annotations. A type written as
  |tau| has no annotations. We sometimes write |(Sub(tau)(a))| to refer to the unannotated version of |(Sub(utau)(a))|.
  A |utau| is also denoted as |Sup(tau)(delta)|, where |delta| is the outermost\footnote{In this chapter, this is the
  triple on the outermost type constructor of the type expression. In the presence of data type, this is the outermost
  annotation on the result-kind of the type expression.} annotation.

  \rulerCmdUse{RulerUniquenessExamples.U1.expr.base}

  Constraints for an expression are gathered by a traversal over the expression, as is described by Figure~\ref{RulerUniquenessExamples.U1.expr.base}.
  The case for integers is the easiest: integers can be produced for any usage annotation and nothing has to be checked for them. We neither have to check anything
  for the use-sites of identifiers, since we deal with these identifiers in the case for lambda abstraction.

  The case for integer addition is slightly more complicated. Aside from consistency, there are no demands on the uniqueness
  component of the result of the addition. On the other hand, we check that the upper and lower bound annotations of the parameters are
  properly propagation from result of the addition to the arguments of the addition. For that, a |(Sub(=>=)(s))| constraint is generated
  between the triple on the result type and the triples on the argument types.

  The function application is perhaps the most difficult case in the uniqueness type system. Three things have to be done: check
  that the bounds of the function are in agreement with the bounds of the function application. Check that the bounds of the
  function application and the cardinality annotation are in agreement with the bounds and the cardinality annotation of the value of the
  function. Finally, check that the bounds and the cardinality annotation of the argument is in agreement with the bounds and usage
  annotation of the parameters.

  For checking propagation, we bring to the attention that the value passed to a function, or the value returned by the function, can
  be a function itself. Propagation deals with all annotated type constructors in the type to make sure that argument and parameter, and
  function result and result, are properly connected. Note that variance plays a role here: the direction of an argument of a function
  is the opposite to the result of the function. Suppose that a function |f| is passed to function |g| as parameter, then |g| applies the
  function, and passes some argument |x|. Propagation is from |x|, to the parameter of |g|, and inside |g| to the result-value of |g|. The
  flow of boundaries and usage information for such an annotation is the other way around than the usual flow. In Figure~\ref{RulerUniquenessExamples.U1.flow.base} we list the
  type rules that walk over the type and generate the |=>=|-constraints for each two corresponding annotations in the proper direction.

  \rulerCmdUse{RulerUniquenessExamples.U1.flow.base}

  The last case to deal with is lambda abstraction. We use an auxiliary rule that gathers all annotated types of the use-sites of the
  identifier of the lambda and turns these into an aggregation constraint. There is no constraint generated between the triple of the
  result of the body and the result-part of the annotated type of the lambda function. As is visible in the type rules, we force the annotated types to be exactly the same. This
  means that we cannot weaken the annotations of the body. But, a function application can weaken the bounds and usage information
  of the result, if needed.

  As a final note about the type rules: the type system can be formulated in a less complicated, but not syntax directed, way. By adding
  an additional case for coercions, the places where we generated a |=>=|-constraint can be extracted and handled by this special
  non-deterministic rule. However, that would make it unclear at which places the |=>=| constraint is generated, and that is actually
  what we want to make explicit, so we choose for a more elaborate, syntax directed, representation of the type rules.

\section{Checking constraints}
\label{Sect.CheckingConstraints}

  We define precisely when a constraint is satisfied or not:

%%[[wrap=code
satisfied :: Check
satisfied  (a =>= b)                                   = a `coercionSatisfied` b
satisfied  (a (Sub(=>=)(s)) b)                         = a `weakCoercionSatisfied` b
satisfied  ((Sub(a)(1)) \*/ ... \*/ (Sub(a)(2)) <= a)  = [(Sub(a)(1)) ... (Sub(a)(n))] `aggregationSatisfied` a
%%]

  \subsection{Coercion constraints}

  For a coercion constraint, the lower bound of the left-hand side should be
  greater than the lower bound of the right-hand side. It is the other way around
  for the upper bound. If the coercion is weak, then the cardinality annotation is ignored,
  otherwise the right-hand side should be more specific than the left-hand side:

%%[[wrap=code
coercionSatisfied (a, b, c) (d, e, f)
  = a >= d && e <= b && c <= f
weakCoercionSatisfied (a, b, c) (d, e, f)
  = a >= d && c <= f
%%]

  This constraint is generated in such a way that we may weaken what we know of the
  right-hand side, to obtain the left-hand side. Depending on code generation, some
  coercion function may need to be inserted, for example, to move a value from a
  compile-time garbage collected heap to a runtime garbage collected heap. For a code
  generator that only selects special operations for types that are used at most once,
  no coercion function is required.

  \subsection{Aggregation constraint}

  For the aggregation constraint, we conservatively approximate the upper and lower bound. Things
  are a bit more complicated for the cardinality annotation. We check that the usage annotation
  is properly split up to the individual use sites (Figure~\ref{splitFunc}). We mean with this that if a value
  is linear, that one use site is linear and all the other use sites are not used at all.
  Figure~\ref{code.sumsat} defines when an aggregation constraint is satisfied.

  \begin{figure}
  \label{splitFunc}
  \caption{The isSplit function.}

%%[[wrap=code
isSplit as 0        = all (== 0) as
isSplit as 1        =  let (eq0, neq0) = partition (== 0) as
                       in length neq0 == 1 && head neq0 == 1
isSplit as oneplus  = length as > 0 && any (== oneplus) as && all (/= 0) as && all (/= 1) as
isSplit as onemin   = all (== onemin) as
isSplit as *        = all (== *) as
%%]
  \end{figure}

  \begin{figure}
  \label{code.sumsat}
  \caption{aggregation constraint satisfaction}

%%[[wrap=code
aggregationSatisfied [((Sub(a)(1)), (Sub(b)(1)), (Sub(c)(1))), ..., ((Sub(a)(b)), (Sub(b)(n)), (Sub(c)(n)))] (a, b, c)
  =   (Sub(a)(1))  `max`  ...  `max`  (Sub(a)(n))  >=  a
  &&  (Sub(c)(1))  +  ...  +  (Sub(c)(n))  <=  c
  &&  isSplit [(Sub(b)(1)), ..., (Sub(b)(n))] b
%%]
  \end{figure}

  Note that when $n = 0$, |(Sub(a)(1))  `max` ... `max` (Sub(a)(n)) === 0| and |(Sub(c)(1)) +  ...  +  (Sub(c)(n)) === 0|.
  If an identifier does not occur syntactically, then the value cannot be touched though that identifier, and the lower
  bound corresponding to the type of the identifier is forced to |0| and the upper bound can be anything.

  All occurrences of an identifier point to the same value. So, if one occurrence of an identifier has a lower bound
  of |1|, it means that the occurrence is evaluated at least once, so the value is used at least once. We approximate the
  lower bound by taking the maximum of all lower bounds.

  At this moment, we do not distinguish between parallel and sequential occurrences of
  values. For parallel occurrences, we can use the maximum of the upper bounds instead
  of the sum, which is a better approximation. And in a similar way take the sum of the
  lower bounds instead of the maximum (note the duality here). We discuss this subject
  in Chapter~\ref{chapt.Parallel}.

\section{Conclusion}

  We showed in this chapter what we mean with uniqueness typing, be it with a simple language. Our approach
  consists of a set of type rules that specify when a program is correctly annotated with coercion annotations.
  We turn this problem into a constraint satisfaction problem, which gives us a separation between the
  gathering of the constraint and the checking of them. In the next chapter, we show that the
  constraints also allow us to \emph{infer} coercion annotations, instead of requiring that they are supplied
  by the programmer.

  In this chapter, we also told that usage annotations are not sufficient. We required lower-bound and upper-bound annotations
  as well. In the next chapter, we switch to inferring uniqueness properties, and there we infer these bounds as well.

%%]
