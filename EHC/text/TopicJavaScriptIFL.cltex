%%[prelude
%include IdentColors.fmt
%include Javascript.fmt

%format a_1
%format a_i
%format a_j
%format a_n
%format MANY   = "\!^{*}"
%format ::= = "::="
%format \ = "{\lambda}"

% defs etc
\newcommand{\todo}[1]{{\color{red}#1}}
\newcommand{\js}{JavaScript\xspace}
\newcommand{\uhcjscript}{\textit{uhc-jscript}\xspace}
\def\brunch{\verb+Brunch+\xspace}
\def\coffeescript{\verb+coffeescript+\xspace}
\def\jq{jQuery\xspace}
\def\jqui{jQuery UI\xspace}
%%]

%%[abstract
We introduce the Utrecht Haskell Compiler (UHC) JavaScript backend; a compiler
backend which allows one to cross-compile Haskell to JavaScript, so it can be
run in the browser. To interface with JavaScript and overcome part of the
impedance mismatch between the two languages, we introduce the Foreign
Expression Language; a small subset of JavaScript for use in Foreign Function
Interface (FFI) imports. Finally we discuss the implementation of a JavaScript
application, completely in Haskell, with which we show that it is now possible
to develop JavaScript applications completely in Haskell.
%%]

%%[introduction
When developing interactive web applications, JavaScript is often the language
of choice, due to every major browser supporting it natively. In contrast to
other client-side programming languages, no plugins are needed to execute
JavaScript. Unfortunately, JavaScript is currently the \textit{only}
client-side programming language that is supported on all major browsers.
People wishing to use other programming languages or paradigms have to rely on
using existing plugins such as Flash or Java Applets, writing custom browser
plugins, or hacking the browsers themselves. None of these options are ideal,
since they either require a lot of work, or force the use of strict, imperative
languages. Instead of choosing between the aforementioned options, we use the
Utrecht Haskell Compiler (UHC) \cite{dijkstra09uhc-arch,www09uhc} to compile
Haskell code to JavaScript, effectively turning JavaScript into a high-level
byte-code of some sorts.

In this paper, we introduce the UHC JavaScript backend, a compiler backend that
allows one to compile Haskell to JavaScript, while keeping Haskell's lazy
semantics. To overcome the impedance-mismatch between Haskell and JavaScript,
we have extended UHC's Foreign Function Interface (FFI) with a small
JavaScript-like expression language we call the Foreign Expression Language
(FEL). With these enhancements to the FFI, we claim that it is now possible to
write complete JavaScript applications using only Haskell. We back this claim
up by porting a web-based Prolog proof assistant from JavaScript to Haskell.
While this paper focusses on Haskell, the ideas should be relatively easy to
implement in similar languages, such as Clean.

With this paper, we make the following contributions:

\begin{itemize}
  \item We introduce the UHC JavaScript backend; a compiler backend that allows
    one to compile any Haskell code supported by the UHC to JavaScript and
    execute it in the browser with the same semantics.
  \item We introduce the Foreign Expression Language (FEL), which allows for a
    more natural way of interfacing with object-oriented languages.
  \item We show that it is now possible to write complete JavaScript
    applications using only Haskell.
\end{itemize}

The rest of this paper is structured as follows: section~\ref{hs2js} introduces
the UHC JavaScript runtime system (RTS) and FFI, after which section~\ref{jcu}
shows the implementation of a complete JavaScript application in Haskell, after
which sections~\ref{future} and~\ref{related} discuss future and related work
respectively. Finally, section~\ref{conclusion} concludes.
%%]


%%[HaskellToJavaScript
\label{hs2js}

\subsection{\label{rts}Runtime System}
There exists an obvious mismatch between Haskell and Object-Oriented (OO) languages,
which has been addressed in various ways over time (Section~\ref{related}):
\begin{itemize}
\item
 Mapping the runtime machinery required for Haskell to an imperative language has to deal with the lazy evaluation strategy
 imposed by Haskell (rest of this section).
\item
 Use of OO language mechanisms as available in JavaScript, in particular prototype based objects; we avoid dealing with this problem.
\item
 Use of available JavaScript libraries;
 we deal with this in the next section by exploiting the freedom offered by Haskell's Foreign Function Interface (FFI)
\end{itemize}

The design of any backend for a lazy functional languages needs to deal with functions, their (lazy) application to arguments,
and  evaluating  such applications to Weak Head Normal Form (WHNF).
The design should also cater for under- and over saturated function applications as well as tail recursion.

In UHC's JavaScript backend functions and their applications are both represented straightforwardly by objects:

\begin{code}
Fun.prototype = {
    applyN : function ( args ) ...
    needsNrArgs : function() ...
}

function Fun( fun ) { ... }
\end{code}

For now we omit implementation details and only expose the programmatic interface as used by the runtime system.
A |Fun| object wraps a JavaScript function so that it can be used as a Haskell function.
The |applyN| field is only used when function applications are being evaluated  (forced); only then
it is necessary to know the |needsNrArgs| number of arguments which must be passed.
For the time being it stays unevaluated as a |Fun| object wrapped inside an |App| or |AppLT|  closure object.

Similarly, partially applied (and thus undersaturated) functions
need to store already passed arguments and how many arguments are still missing.
An |AppLT| (|LT| stand for \emph{less than}) object encodes this and again we provide its programmatic interface first:

\begin{code}
AppLT.prototype = {
    applyN : function ( args ) ...
    needsNrArgs : function() ...
}

function AppLT( fun, args ) { ... }
\end{code}

An |AppLT| only wraps other |AppLT| objects or |Fun| objects.

Finally, for all remaining saturation cases an |App| object is used, knowledge
about the degree of saturation is delegated to the encapsulated function
object, which may be another |App|, |AppLT|, or |Fun|.

\begin{code}
App.prototype = {
    applyN : function ( args ) ...
}

function App( fun, args ) { ... }
\end{code}

With this interface we now can embed Haskell functions;
for example the function |\x -> id ^ (id x)| is,
assuming an elementary JavaScript function |id| is available, by:

\begin{code}
new Fun( function(x) {
    return new App(id, [new App(id,[x])]);
} )
\end{code}

Evaluation is forced by a separate function |eval| which assumes the presence
of an |eOrV| (evaluator Or Value) field in all Haskell runtime values, which tells us
whether the JavaScript object represents a Haskell non-WHNF value which needs further evaluation or not;
in the former case it will be a 
JavaScipt function of arity 0, which can be called.
A Haskell function or application object does not evaluate itself since the entailed tail recursion will cause the stack of the underlying
JavaScript engine to flow over.
The separate external function |eval| doing the evaluation allows non WHNF values to be returned,
thus implementing a trampoline mechanism:

\begin{code}
function eval( x ) {
    while ( x && x.eOrV ) {
        if ( typeof x.eOrV == 'function' ) {
            x = x.eOrV() ;
        } else {
            x = x.eOrV ;
    }   }
    return x ;
}
\end{code}

Even normal JavaScript values can be thrown at |eval|, provided they do not (accidentally) contain an |eOrV| field.
The actual |eval| function is somewhat more involved as it provides some protection against null values and also
updates the |eOrV| field for all intermediate non WHNF objects computed in the evaluation loop.

As usual the evaluation is driven by the need to pattern-match on a value, e.g. as the result of a case expression or by a built-in JavaScipt primitive which is strict in the corresponding argument
such as in the wrapper of the primitive multiplication function, which contains the actual multiplication (|*|):

\begin{code}
new Fun( function(a,b) {
    return eval(a) * eval(b) ;
} )
\end{code}

Depending on the number of arguments provided either an undersatured closure is built, or the function is directly invoked using
JavaScripts |apply|.
In case too many arguments are provided a JavaScript closure is constructed, which subsequently is evaluated in the evaluation 
loop of |eval|.
The implementation of |AppLT| is similar to that of |Fun|.
|App|s implementation of |applyN| simply delegates to |applyN| of the function it applies to.
Also omitted are the encodings of nullary applications, used for unevaluated constants (CAF, Constant Applicative Form) and indirection nodes required for
mutual recursive definitions.
Data types and tuples are straightforwardly mapped onto JavaScript objects
with fields for the constructor tag and its fields.
If available, record field names of the corresponding Haskell data type are used.


\subsection{\label{ffi}JavaScript Foreign Function Interface}
Talk about all the cool stuff
- Mostly discuss the Foreign Expression Language (FEL)

\begin{figure}[t]
\hrule
\begin{code}
exp    ::=  '{}'                                ^ -- Haskell constructor to JS object
         |  (arg | ident) post MANY             ^ -- JS expression

post   ::=  '.' ident                           ^ -- object field
         |  '[' exp ']'                         ^ -- array indexing
         |  '(' args ')'                        ^ -- function call

args   ::=  epsilon | arg (, arg) MANY          ^ -- possible arguments

arg    ::=  '%' ('*' | int)                     ^ -- all arguments, or a specific one
         |  '"' str '"'                         ^ -- literal text

ident  ::= a valid JavaScript identifier
int    ::= any integer
str    ::= any string
\end{code}
\caption{Import entity notation for the JS calling convention}
\label{jsimpent}
\end{figure}

- Briefly mention the dynamic/wrapper things
%%]


%%[JCUApp
\label{jcu}
What does the app do? How is it implemented? Does it work? Does it work well?
Is the UHC JS backend a full replacement for JS coding? Etc?
\cite{swierstra2011,stutterheim2012} \cite{snap}

The JCU Prolog Proof Assistant\cite{swierstra2011} is a tool developed for
students to familiarise themselves with Prolog through the aided solving of
Prolog proof trees. Originally programmed in \coffeescript\cite{coffeescript}
(sugar for \js) and using the \brunch\cite{brunch} framework.

Students can proof their Prolog query by applying a combination of variable
substitution and dropping rules from the list of rules on the tree.

The tool is presented as a web application and runs in any modern browser. The
application is written in Haskell which compiles to \js by UHC. It uses the
\uhcjscript\cite{uhcjs} library. The \uhcjscript library provides (among others)
bindings to the jQuery\cite{www11jquery} JavaScript library and the
AjaxQueue\cite{ajaxq} library. Since it is possible to compile arbitrary Haskell
code to \js, it is also possible to run any Haskell library, including
NanoProlog, on the client.

The Haskell implementation of the application has the same features and is as
stable as the original \coffeescript implementation. The Haskell implementation
is |IO|-heavy, but straightforward.

Thus it is possible to implement a non-trivial application completely in
Haskell, using the UHC JavaScript backend.

\subsection{\label{issues}Implementation Issues}
% todo describe: Which issues do you run into in general when you develop a JS
% app in Haskell?

% Ale: non-termination/threads, no native OO, interfacing with annoyingly
% multi-interpretable functions (functions that are dimensioned in both the number
% and type of their arguments)

We had to make concessions and create some workarounds due to the lack of
support for advanced language features, such as Functional Dependencies and Type
Families. Concretely this also means that not all Hackage packages can be build
using the UHC.

In \js the keyword |this| refers to the object currently in scope when calling a
function. Since the function our case was run by our RTS the |this| keyword
referred to the RTS objects' scope. Essentially exposing the RTS to the Haskell
world and hiding the scope that would expect to get when we would be using plain
\js. This is a topic for future work (\ref{future-work:this-scope}).
 
Specifically, the \jqui library ensures that |this| in the event callbacks
points to the object you, e.g., dropped another object on, instead of passing it
as an argument. In order to work around this we added a wrapper function that
captures |this| and passes it along to the wrapped function as an event. For
more details see the |wrappedThis| function in the RTS.

Since we now run the NanoProlog library on the client we risk infinite recursion
as the proof resolution can possibly recurse infinitely. The original
application executed this server-side where it ran in a separate thread. Each
resolution had a limited time to complete. \js doesn't offer the possibility to
fork threads, so the proof resolution runs in the main thread, risking blocking.
The only way to achieve parallel computation in \js is using WebWorkers.
 
\subsection{\label{performance}Performance}
% Performance is decent, except for the actual Prolog backtracking. Where is the bottleneck?
% Ale: Probably as I've stated before the problem is in the memory management as
% is supported by the benchmarks in Chrome and Fx.

In general the performance of the web application is on par with the previous
implementation. Performance becomes an issue when using browsers other than
Google Chrome (v) as their 

%%]


%%[futureWork
\label{future}

\subsection*{Communicating with the server}\label{ssec:communicating-with-server}
Currently the communication with the server is encoded manually. That is, the
creation of the \js values to be send over hardcoded in the application. When
coding both the server and the client in Haskell one should be able to create
something like `typed channels' for each server endpoint. This would further
improve the type safety of the application.

\subsection*{Background threading}
Although the basic interface for using \verb+WebWorkers+ is present it is
currently not possible to seamlessly pass Haskell values due to the presence
of functions. Figuring out how then to pass Haskell values is subject to
future research.

\subsection*{Generic |FromJS| and |ToJS| for converting objects/records}
It should be fairly straightforward to implement a generic implementation for
|FromJS| and |ToJS| using deriving Generic.

\subsection*{Providing an api to build web applications}\label{ssec:providing-an-api-to-build-web-applications}
One could think of providing a similar API such as WxHaskell\cite{wxHaskell}
does for constructing native application, but for web applications. Also one
could think of providing a Functional
Reactive\cite{Elliott:2009:PFR:1596638.1596643,Wan:2000:FRP:349299.349331,reactive-banana} 
interface to building the web application.

\subsection*{Typechecking}
Currently, foreign expressions are not typechecked at all. In case of a
programming error the compiler will currently panic in the best-case scenario
and happily generate \js code that fails at runtime in the worst-case scenario.
Constraints on the imports and exports need to be formalised and the foreign
types should be typechecked according to the foreign expressions. Some example
constraints that could be typechecked:

\begin{itemize}
  \item Only datatype values may be exported as objects, not functions or
        primitive types.
  \item Only wrapped functions may be exported in objects.
\end{itemize}

The first item could be realised by supporting type constraints in the foreign
import. This is already allowed by the type system, but the RTS does not
currently support this.

\subsection*{Testing}
During development, the code has only received limited, informal testing. The
UHC's test suite should be expanded to enable automated testing. Additionally,
real-world \js front-end applications should be ported to Haskell and the
\uhcjscript library to identify shortcomings of the existing ideas and
implementations.

\subsection*{Benchmarking an optimising}
Some benchmarks have been performed that show that the generated \js is quite
a bit slower than a hand-written version of the same code. Unfortunately, these
numbers aren't publicly available, nor is is clear where the biggest
bottlenecks are located. It would be very interesting to do another round of
benchmarks, including the object code. Afterwards, it would be interesting to
identify bottlenecks and find ways to speed up the generated code.

\subsection*{Static object compilation}
Currently the only way of converting a datatype to a \js object is to do so at
runtime. This, however, is a process with time complexity linear in the number
of datatype records. Future work could focus on generating (parts of) \js
objects at compile-time, so that only dynamic values will need to be copied to
the object at runtime.

\subsection*{Safe |this| scope (working title)}\label{future-work:this-scope}
Is there a way to prevent the RTS from being exposed by using the keyword
|this|?

% \subsubsection*{Numeric object indices}
% When a datatype without record selectors is converted into a \js object, the
% object's attribute name becomes an integer $\geq{1}$ with an underscore prefix.
% Ideally this would be a numeric index $\geq{0}$.
 
\subsection*{Deployment}
JavaScript code is usually downloaded, hence compact representation as well as
avoiding or delaying loading of code is important. Although UHC allows pruning
of unused code as to achieve a relative compact representation, it provides no
mechanism for dynamic loading of modules. This is left for future
implementation. In addition UHC is able to perform whole program analysis
further compacting the JavaScript code and producing a single output JavaScript
file.

%\todo{Code compactification, module loading, whole prog, ...}
\subsection*{Packages and The Haskell ecosystem}
Targeting Haskell to a different platform means that some assumptions following
from using a single platform only are no longer valid. First, a different
platform means a different runtime environment. Almost all of the UNIX
functionality is available for the usual Haskell UNIX runtime, but is naturally
not available inside a web browser and, vice verse, specific JavaScript
libraries like jQuery are not available on a UNIX platform. Some library modules
of a package (partially) cannot be build on some platforms, while others
(partially) can. To cater for this, UHC rather ad-hoc marks modules to be
unavailable for a backend by a pragma \verb|{-# EXCLUDE_IF_TARGET js #-}|. Of
course |cpp| can still be used to select functionality inside a module. However,
in general, awareness of platform permeates all aspects of a language system,
from the compiler itself to the library build system like |Cabal|.

In particular, |Cabal| needs a specification mechanism for such variation in
target and platform to allow for selective compilation of a collection of
variants. Currently this means that UHC compilation for the JavaScript backend
cannot be done through |Cabal|.

A second aspect has more to do with the evolution of Haskell as an ecosystem.
Many libraries go far beyond the Haskell standard by making use of GHC
extensions. Currently, such libraries evolve to use type families, a feature not
yet available in UHC. For (non GHC) Haskell compiler writers to keep with this
pace of evolution poses a considerable challenge; yet in our opinion there is
value in the availability of compiler alternatives as well as variation in what
those compilers are good at.

%\todo{Mismatch: Cabal does not deal with multiple backend of one compiler.}

%\todo{Mismatch: Libraries take GHC as standard, not Haskell2010 (or H98).}

%\todo{Unix based library is useless, basically other OS to run on, what about shared code, ...}

\subsection*{Type system absence}
JavaScript has no type system, the absence of which can be dealt with by using
phantom types in wrapper functions around untyped FFI calls. More problematic
are for example DOM functions returning objects with a different interface, like
a DOM element or attribute. A sum type defining all possible result types could
be used, but data types are not extensible, which might be too limiting in
practice. Dynamics might be used as result values, but require assistance from
the runtime system as well as knowledge about types (e.g. in the form of
|TypeRep|). Existentially quantified data types and classes might be used
(similar to extensible exceptions \cite{marlow06extensible-exception}), but then
knowledge about the class system also seeps into the runtime system. Currently
this has not yet been further addressed.
%\todo{Typing the untyped.}

%%]


%%[relatedWork
\label{related}

% \paragraph{Other approaches.}
The idea of running Haskell in a browser is not new. To our knowledge first
attempts to do so using JavaScript were done in the context of the York Haskell
Compiler (YHC) \cite{www07yhc-javascript}. The Document Object Model (DOM)
inside a browser was accessed via wrapper code generated from HTML standard
definitions \cite{www07haskell-in-browser}. However, YHC is no longer maintained
and direct interfacing to DOM nowadays is replaced by libraries built on top of
the multiple DOM variations.

The idea of running functional programs in a browser even goes further back to
the availability of Java applets. The workflow framework |iTasks|, built on top
of the Clean system \cite{www11clean-system}, uses a minimal platform
independent functional language, SAPL, which is interpreted in the browser by
code written in Java. The latest interpreter incarnations are written in
JavaScript
\cite{jansen10phd-itasks-sapl-funcweb,bruel10sapl-javascript,plasmeijer08clientside-itasks-ajax}.
Although currently a Haskell front-end exists for Clean, the use of it in a
browser seems to be tied up to the iTasks system. The intermediate language SAPL
also does not provide the facilities as provided by our Haskell FFI.
%This limits used code to that which is generated by the iTasks system.

Of the GHC a version exists which generates JavaScript \cite{www11ghcjs-git},
based on the GHC API, supporting the use of primitives but not the FFI.
Further down we elaborate on some consequences of multiple platforms and backends
relevant for this GHC backend variant as well.

Both ``Functional javascript'' \cite{www07functional-javascript} and ``Haskell
in Javascript'' \cite{www10haskellinjavascript} do not use a separate Haskell
compiler. Instead, JavaScript is used directly in a functional style,
respectively a small compiler for a subset of Haskell has been written in
JavaScript.

\subsection{Object orientation.}

Object Oriented behaviour itself can be realised inside Haskell by exploiting the
class system \cite{shields01haskell-oo-overloading,kiselyov05haskell-oo}.
However, we aim to access libraries written in JavaScript, not \emph{mimic}
JavaScript or OO mechanism in general inside Haskell.

% todo: sounds shaky en niet meer helemaal waar voor ons ding?
However, when functionality of the libraries would have to be (re)written in
Haskell some form of OO mechanism should be available. This issue arises when
one would code in Haskell a platform independent part of an otherwise OO GUI
library, say |wxHaskell|. For now we limit ourselves to accessing JavaScript
libraries via the FFI, hiding OO idiom inside FFI import entities.

%\todo{Mapping to OO: FFI or other mechanism.}

%\todo{Records in JS vs HS.}



% \paragraph{Side effects.}
% 
% All access to JavaScript values is done in the IO monad, so side effect can be properly modelled.
% For now it is assumed that no threads exist.
% Since JavaScript's worker thread mechanism can be used safely we currently do not need
%  semaphores, STM, or other shared data access machinery.
% Some values like the globally available @window@ in a browser could be accessed without the use of the IO monad because its value does not change.
% However, if and when this assumption would not hold in a near future it would break our wrapping code as well.

%\todo{All in IO, what can be done without IO, threads? STM?.}

%\todo{Onderstaande twee paragrafen zijn een beetje bloat maar er zit misschien nog wel wat in voor later.}

% \paragraph{Mapping to OO runtime environments.}
% 
% In general, it is attractive to map onto available virtual machines for popular OO languages,
% in particular because of the availability of a wealth of libraries.
% Targeting the Java virtual machine (JVM) has been experimented with
% \cite{wakeling98haskell-to-java,func:lazy:java:parser-combinator,stewart02mthesis-multiparadigm-jit,tullsen96haskell-to-java},
% as well as with the @.NET@ platform \cite{monteiro05functional-to-dotnet,www04haskell-dotnet,meijer07mondrian,meijer01dotnet-scripting-mondrian};
% UHC also provides a backend to the JVM \cite{func:lazy:java:parser-combinator}
% using the same technique as described here.
% However, interfacing to libraries is still lacking in UHC, and in general library access and other
% runtime oriented features (threads, exceptions)
% is where the real work lies \cite{www12ghc-faq}.
% Wrapping and interfacing to libraries has to be done manually or by tools interpreting library code which requires substantial effort and is 
% suffering from misinterpretation.
% In the case of JavaScript lack of typing annotations even precludes automatic FFI wrapper generation,
% unless type annotations in comments could be trustworthy and formal enough to be used instead.

% Efficient code generation is also an issue.
% Usually non standard OO language constructs are used to implement
% standard idiom of (lazy) functions.
% For now, with UHC we have taken the approach to first make it work and not bother about efficiency,
% generating code from an early stage in the compiler pipeline.
% We expect exploitation of the results of a strictness analyser to speed up the code considerably,
% especially because the existing JavaScript compilers to be better able to analyse the provided code.
%%]

\section{More info, download.}

For the variant of the JCU application as implemented for this paper more info
(download, how to install, etc) is available, via the UHC www site
\cite{www09uhc} or directly \cite{www12uhc-js-backend}.



%%[conclusion
\label{conclusion}
We have shown that the UHC is capable of supporting the development of complete
client-side web applications. This opens the door to Haskell-only web
development. Better abstractions are still required to reduce the amount of
code that lives in the |IO| monad directly, and to give programming with the
UHC JavaScript backend a more functional feel. While in most cases performance
is acceptable, it needs to be improved if computationally heavy functions are
to be run on the client. In order for most of the frequently used Hackage
libraries to be run on the client, UHC will need some more work as well.
%%]

%%[XX
%%]

