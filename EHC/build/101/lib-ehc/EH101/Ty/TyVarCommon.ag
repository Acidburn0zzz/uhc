ATTR AllTy [ | | frTvSL USE {++} {[]}: {[TyVarIdS]} ]

SEM TyAGItf
  | AGItf       loc         .   frTvS       =   head @ty.frTvSL

SEM Ty
  | Var         loc         .   frTvS       =   if tvCatIsPlain @categ.self then Set.singleton @tv else Set.empty
  | App         loc         .   frTvSL      =   @arg.frTvSL ++ @func.frTvSL
                            .   frTvS       =   Set.unions @frTvSL
                lhs         .   frTvSL      =   if @isSpineRoot then [@frTvS] else @frTvSL
  | TBind
    Lam
                loc         .   frTvS       =   head @ty.frTvSL `Set.difference` @introTVarS
  | Any Con     loc         .   frTvS       =   Set.empty
  | TBind Var Any Con
    Lam
                lhs         .   frTvSL      =   [@frTvS]

SEM Ty
  | Ext         loc         .   frTvSL      =   @extTy.frTvSL ++ @ty.frTvSL

SEM Ty
  | App         (loc.frRowTvS,loc.frTvSL)   :=  if @argIsRow
                                                then hdAndTl (reverse @arg.frTvSL)
                                                else (Set.empty,@arg.frTvSL ++ @func.frTvSL)
                loc         .   frTvS       :=  Set.unions (@frRowTvS : @frTvSL)
  | Pred        loc         .   frTvS       =   Set.unions @pr.frTvSL
  | Impls       loc         .   frTvS       =   Set.unions @impls.frTvSL
  | Pred Impls  lhs         .   frTvSL      =   [@frTvS]

SEM Impls
  | Tail Nil    lhs         .   frTvSL      =   []
  | Cons        lhs         .   frTvSL      =   @pr.frTvSL ++ @tl.frTvSL

SEM Ty
  | Pred Var App TBind
                loc         .   frTvS       :   TyVarIdS
  | App         loc         .   frTvSL		: 	{[TyVarIdS]}
                loc         .   frRowTvS    :   TyVarIdS

ATTR AllTy [ pol : Polarity | | ]

SEM Ty
  | App         func        .   pol         =   @lhs.pol
                arg         .   pol         =   if          @appIsLikeProd  then  @lhs.pol
                                                else  if    @isArrowRoot    then  @polArrowRes
                                                else  if    @isArrowArg     then  polContravariant
                                                                            else  polInvariant
                loc         .   polArrowRes =   if @func.isPred then @lhs.pol else polCovariant

SEM Ty
  | Pred        pr          .   pol         =   polInvariant

SEM Pred
  | Pred        ty          .   pol         =   polCovariant
  | Class       ty          .   pol         =   polInvariant


ATTR Ty [ | | isQuLoc USE {&&} {False}: Bool ]

SEM Ty
  | Var         loc         .   isQuLoc     =   polIsCovariant @lhs.pol && @isQuLocExtraHook
  | TBind       loc         .   isQuLoc     =   not (polIsInvariant @lhs.pol) && @isQuLocExtraHook
  | App         loc         .   isQuLoc     =   (  polIsCovariant @lhs.pol
                                                || (polIsContravariant @lhs.pol
                                                    && (@isProdRoot
                                                        || @isArrowRoot
                                                           && (not @func.isPred || @arg.isQuLoc)
                                                   )   )
                                                ) && @isQuLocExtraHook
                lhs         .   isQuLoc     =   if @isArrowArg then @arg.isQuLoc else @isQuLoc

SEM Ty
  | Pred        loc         .   isQuLoc     =   polIsCovariant @lhs.pol && @isQuLocExtraHook

SEM Ty
  | App Pred Var TBind
                loc         .   isQuLoc     :   Bool

{
tvarSOccurCount :: [TyVarIdS] -> AssocL TyVarId Int
tvarSOccurCount = map (\vl@(v:_) -> (v,length vl)) . group . sort . concat . map Set.toList

tvarSOccurGE2 :: [TyVarIdS] -> TyVarIdS
tvarSOccurGE2 =  Set.fromList . map fst . filter ((>1).snd) . tvarSOccurCount

}
SEM TyAGItf
  | AGItf       loc         .   qHereTvS        =   Set.empty

SEM Ty
  | Var TBind   loc         .   qHereTvS        =   if @isQuLoc then {- filter (tvIsPlain @lhs.fxTvM) -} @frTvS else Set.empty
  | App         loc         .   qHereTvS        =   if @isQuLoc
                                                    then  if    @appIsArrow || @appIsLikeProd
                                                          then  let fv = Set.unions (tvarSOccurGE2 @frTvSL : [@qOrphanTvS])
                                                                in  {- if @appIsArrow
                                                                    then filter (tvIsPlain @lhs.fxTvM) fv
                                                                    else -} fv
                                                          else  @frTvS
                                                    else  Set.empty

SEM Ty
  | App         loc         .   qHereTvS        :=  if @isQuLoc
                                                    then  if    @appIsArrow || @appIsLikeProd
                                                          then  Set.unions [tvarSOccurGE2 @frTvSL, @frRowTvS, @qOrphanTvS]
                                                          else  @frTvS
                                                    else  Set.empty
  | Pred        loc         .   qHereTvS        =   @frTvS `Set.difference` @pr.qInsideTvS

SEM Ty
  | App         loc         .   qHereTvS        :   TyVarIdS
                loc         .   qOrphanTvS      :   TyVarIdS

ATTR
  Ty
  Pred Impls
    [ | | qOrphanTvS: TyVarIdS ]

SEM Ty
  | App         loc         .   qOrphanTvS      =   @arg.qOrphanTvS `Set.union` @func.qOrphanTvS
  | Ext         loc         .   qOrphanTvS      =   @extTy.qOrphanTvS `Set.union` @ty.qOrphanTvS

SEM Ty
  | App         lhs         .   qOrphanTvS      =   if @isSpineRoot && @isQuLoc then Set.empty else @qOrphanTvS
  | Var         lhs         .   qOrphanTvS      =   if @isQuLoc then Set.empty else @frTvS
  | * - App Var
    Ext
    Pred Impls
                lhs         .   qOrphanTvS      =   Set.empty

SEM Impls
  | Cons		lhs			.	qOrphanTvS      =   @pr.qOrphanTvS `Set.union` @tl.qOrphanTvS
  | * - Cons	lhs			.	qOrphanTvS      =   Set.empty

SEM Pred
  | Var
    Preds
  				lhs			.	qOrphanTvS      =   Set.empty

ATTR AllTy [ | | qInsideTvS USE {`Set.union`} {Set.empty}: TyVarIdS ]

SEM Ty
  | App         lhs         .   qInsideTvS      =   @qHereTvS

ATTR AllTy [ qSurrTvS: TyVarIdS | | ]

SEM TyAGItf
  | AGItf       loc         .   qSurrTvS                =   @qHereTvS

SEM Ty
  | App Var TBind
                loc         .   qSurrTvS                =   @qHereTvS `Set.union` @lhs.qSurrTvS

ATTR AllTy [ | | gathFxTvM USE {`Map.union`} {Map.empty}: TvCatMp ]
ATTR AllTy [ fxTvM: TvCatMp | | ]

SEM Ty
  | Var         lhs         .   gathFxTvM   =   @tv `Map.singleton` mkTvInfoTy @categ.self

SEM TyAGItf
  | AGItf       loc         .   fxTvM       =   @ty.gathFxTvM

