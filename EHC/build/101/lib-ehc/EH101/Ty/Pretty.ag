MODULE {EH101.Ty.Pretty} {ppTyWithCfg', ppTyWithCfg, ppTy
, CfgPPTy
, ppTyPr
, ppImplsWithCfg
, ppPredOccId'
, ppTyDt
, cfgPPTyDT}
{
import EH.Util.Utils
import EH.Util.Pretty
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Ty
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Char
import EH101.Scanner.Common(hiScanOpts)
import EH101.Base.CfgPP

}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Ty/AbsSyn.ag"
INCLUDE "Ty/CommonAG.ag"
WRAPPER TyAGItf

{
ppTyWithCfg' :: CfgPP x => x -> Ty -> PP_Doc
ppTyWithCfg' x ty = pp_Syn_TyAGItf $ synTyWithCfg (cfgPPTy x) ty

synTyWithCfg :: CfgPPTy -> Ty -> Syn_TyAGItf
synTyWithCfg c ty
  =  wrap_TyAGItf
       (sem_TyAGItf (TyAGItf_AGItf ty))
       (Inh_TyAGItf {cfg_Inh_TyAGItf = c})

ppTyWithCfg :: CfgPPTy -> Ty -> PP_Doc
ppTyWithCfg c ty = pp_Syn_TyAGItf $ synTyWithCfg c ty

ppTy :: Ty -> PP_Doc
ppTy = ppTyWithCfg cfgPPTyDflt

}
{
ppImplsWithCfg :: CfgPPTy -> Impls -> PP_Doc
ppImplsWithCfg c i = ppTyWithCfg c (Ty_Impls i)

}
{
ppTyDt :: Ty -> PP_Doc
ppTyDt = ppTyWithCfg cfgPPTyDT

}
{
instance PP Ty where
  pp t = ppTy t

}
{
ppTyPr :: Ty -> PP_Doc
ppTyPr = ppTyWithCfg cfgPPTyPred


}
{
instance PP FIMode where
  pp m = pp (show m)

}
{
instance PP InstTo where
  pp  InstTo_Plain       = pp "_"
  pp (InstTo_Qu q v t k) = t >|< "/" >|< v >|< "@" >|< tyquMetaLev q

}
{
ppPredOccId' :: CfgPP x => x -> PredOccId -> PP_Doc
ppPredOccId' x poi
  = ppi (poiId poi)
  where ppi = cfgppUID x

}
{
ppPredOccId :: PredOccId -> PP_Doc
ppPredOccId poi = "Poi" >|< ppPredOccId' CfgPP_Plain poi

}
{
instance PP TyKiKey where
  pp = pp . show

}
{
instance PP Pred where
  pp p = ppTyWithCfg cfgPPTyPred (Ty_Pred p)

instance PP Impls where
  pp i = ppTy (Ty_Impls i)

instance PP PredOccId where
  pp = ppPredOccId

instance PP PredOcc where
  pp po = pp (poPr po) >|< "/" >|< pp (poPoi po) >|< "/" >|< pp (poScope po)

instance PP CHRPredOccCxt where
  pp (CHRPredOccCxt_Scope1 sc) = pp sc

instance PP CHRPredOcc where
  pp po = ppParensCommas
            [ pp (cpoPr po), pp (cpoCxt po)
            , pp (cpoRange po)
            ]

instance PP PredScope where
  pp (PredScope_Lev l) = ppListSep "<" ">" "," $ rllToList l
  pp (PredScope_Var v) = "<sc_" >|< v >|< ">"

instance PP ImplsProveOcc where
  pp o = ipoId o >|< "/" >|< ipoScope o

}
{
instance PP PredSeq where
  pp (PredSeq_Cons hd tl) = pp hd >#< ":" >#< pp tl
  pp (PredSeq_Nil       ) = pp "[]"
  pp (PredSeq_Var u     ) = pp u

}
{
instance PP LabelOffset where
  pp = pp . show

}
WRAPPER LabelAGItf

{
instance PP Label where
  pp l = pp_Syn_LabelAGItf t
       where t =  wrap_LabelAGItf
                    (sem_LabelAGItf (LabelAGItf_AGItf l))
                    (Inh_LabelAGItf)

}
{
data CfgPPTy
  = CfgPPTy
      { cfgPPTyPPHsn                :: HsName -> PP_Doc
      , cfgPPTyPPCon                :: CfgPPTy -> HsName -> PP_Doc
      , cfgPPTyPPVar                :: CfgPPTy -> UID -> Int -> PP_Doc
      , cfgPPTyPPVarDflt            :: CfgPPTy -> String -> UID -> PP_Doc
      , cfgPPTyPPImplsPred          :: PP_Doc -> PP_Doc -> PP_Doc -> PP_Doc
      , cfgPPTyPPImplsTailCons      :: PP_Doc -> PP_Doc -> PP_Doc
      , cfgPPTyPPImplsAppWrap       :: (PP_Doc -> PP_Doc) -> PP_Doc -> PP_Doc
      , cfgPPTyCtxt                 :: TyCtxt
      , cfgPPTyFollowAST            :: Bool
      , cfgPPTyLhsSafe              :: String -> String
      , cfgPPTyElimEmptyImpls       :: Bool
      }

}
{
cfgPPTy' :: CfgPP x => x -> CfgPPTy -> CfgPPTy
cfgPPTy' x c
  = c { cfgPPTyPPHsn        = cfgppHsName x
      , cfgPPTyPPVar        = \c u i -> cfgppVarHsName x Nothing (Just u) (Just i)
      , cfgPPTyPPCon        = \c n -> cfgppConHsName x n
      , cfgPPTyFollowAST    = cfgppFollowAST x
      }

cfgPPTy :: CfgPP x => x -> CfgPPTy
cfgPPTy x = cfgPPTy' x cfgPPTyDflt

}
{
cfgPPTyDflt :: CfgPPTy
cfgPPTyDflt
  = CfgPPTy
      { cfgPPTyPPHsn                = pp
      , cfgPPTyPPCon                = \_ -> ppCon
      , cfgPPTyPPVar                = \c _ i -> ppTnUniq c i
      , cfgPPTyPPVarDflt            = \cfg pre tv -> cfgPPTyPPHsn cfg $ mkHNm $ pre ++ "_" ++ show tv
      , cfgPPTyPPImplsPred          = \iv pr pv -> iv >|< "=" >|< pr >|< "/" >|< pv
      , cfgPPTyPPImplsTailCons      = \pr occs -> pr >|< occs
      , cfgPPTyPPImplsAppWrap       = ($)
      , cfgPPTyCtxt                 = TyCtxt_Ty
      , cfgPPTyFollowAST            = False
      , cfgPPTyLhsSafe              = id
      , cfgPPTyElimEmptyImpls       = False
      }


}
{
cfgPPTyDT :: CfgPPTy
cfgPPTyDT
  = cfgPPTyDflt
      { cfgPPTyPPHsn                = pp . hsnQualified
      , cfgPPTyPPCon                = \_ -> ppCon . hsnQualified
      , cfgPPTyPPImplsPred          = \_ pr _ -> pr
      , cfgPPTyPPImplsTailCons      = \pr _ -> pr
      , cfgPPTyPPImplsAppWrap       = \_ pr -> pr
      , cfgPPTyElimEmptyImpls       = True
      , cfgPPTyLhsSafe              = let safe '|' = "||"
                                          safe '@' = "@@"
                                          safe x   = [x]
                                      in  concatMap safe
      }

}
{
cfgPPTyPred :: CfgPPTy
cfgPPTyPred
  = cfgPPTyDflt
      { cfgPPTyCtxt         = TyCtxt_Pred
      }

}
{
cfgPPTyExtraForHI :: CfgPPTy -> CfgPPTy
cfgPPTyExtraForHI c
  = c { cfgPPTyPPVarDflt    = \cfg pre tv -> cfgPPTyPPVar cfg cfg tv 0
      }

}
{
cfgppAside :: (PP a, PP b) => CfgPPTy -> a -> b -> PP_Doc
cfgppAside c a b = if cfgPPTyFollowAST c then a >-< b else a >#< b

}
{
ppExts :: CfgPPTy -> HsName -> PP_Doc -> [PP_Doc] -> (PP_Doc,PP_Doc)
ppExts cfg appFunNm appFunPP appArgPPL
  = (ppNice,ppCfg)
  where ppNice = ppAppTop (hsnRow,mkPPAppFun' sep appFunNm appFunPP)
                          appArgPPL empty
        ppCfg  = if cfgPPTyFollowAST cfg
                 then let (e:es) = appArgPPL
                      in  hv ([hsnORow >#< appFunPP,sep >#< e] ++ map ("," >#<) es ++ [pp hsnCRow])
                 else ppNice
        sep = cfgPPTyLhsSafe cfg "|"

}
ATTR TyAGItf AllTyAndFlds [ cfg: CfgPPTy | | ]

SEM Pred
  | Pred        loc         .   cfg             =   @lhs.cfg { cfgPPTyCtxt = TyCtxt_Pred }
  | * - Pred    loc         .   cfg             =   @lhs.cfg { cfgPPTyCtxt = TyCtxt_Ty   }

SEM LabelAGItf
  | AGItf       loc         .   cfg             =   cfgPPTyDflt

{
type TVarNameMap
  = Map.Map TyVarId
            PP_Doc

}
{
tnLookupPP :: TyVarId -> TVarNameMap -> Maybe PP_Doc
tnLookupPP = Map.lookup

}
{
tnMapInsert = Map.insert

}
{
tnUniqRepr :: Int -> String
tnUniqRepr
  = lrepr
  where lrepr i     =  if i <= 26
                       then  [repr i]
                       else  let  (d,r) = i `divMod` 26
                             in   (repr d : lrepr r)
        repr        =  (chr . (97+))

}
{
ppTnUniq :: CfgPPTy -> Int -> PP_Doc
ppTnUniq c = cfgPPTyPPHsn c . mkHNm . tnUniqRepr

}
{
mkDefaultTvNmPP :: CfgPPTy -> String -> TyVarId -> PP_Doc
mkDefaultTvNmPP cfg pre tv = cfgPPTyPPHsn cfg $ mkHNm $ pre ++ "_" ++ show tv

}
{
tvCategPrefix :: TyVarCateg -> String
tvCategPrefix TyVarCateg_Fixed = "c"
tvCategPrefix TyVarCateg_Plain = "v"
tvCategPrefix TyVarCateg_Meta  = "m"

}
ATTR AllTyAndFlds [ | tnUniq: {Int}  tnMap: TVarNameMap | ]

SEM TyAGItf
  | AGItf           ty      .   tnUniq      =   0
                            .   tnMap       =   Map.empty

SEM LabelAGItf
  | AGItf           loc     .   tnUniq      =   0
                            .   tnMap       =   Map.empty

SEM Ty
  | TBind
    Lam
                    loc     .   tnPP        =   ppTnUniq @lhs.tnUniq
                            .   tnUniq      =   @lhs.tnUniq + 1
                            .   tnMap       =   tnMapInsert @tv @tnPP @lhs.tnMap
                    lhs     .   tnMap       =   Map.filterWithKey (\v _ -> v /= @tv) @ty.tnMap

SEM Ty
  | TBind
    Lam
                    loc     .   tnPP        :=  cfgPPTyPPVar @lhs.cfg @lhs.cfg @tv @lhs.tnUniq

ATTR
  TyAGItf AllTyAndFlds
  LabelAGItf
    [ | | pp USE {>#<} {empty}: PP_Doc
    ]

SEM Ty
  | Con             loc     .   pp      =   ppCon @nm
  | App             loc     .   ppDflt  =   @func.pp >#< @arg.pp
                            .   ppAppTop=   ppAppTop (@appFunNm,@appFunPP) @appArgPPL @ppDflt
                            .   ppNice  =   ppParNeed  @parNeed @lhs.parNeed @ppAppTop
                            .   pp      =   if @isSpineRoot then @ppNice else @ppDflt
  | Any             loc     .   pp      =   pp hsnUnknown
  | Ann             loc     .   pp      =   @ann.pp >#< @ty.pp
  | Dbg             loc     .   pp      =   "DBG<<<" >#< @info >#< ">>>"

SEM Ty
  | Con             loc     .   pp      :=  cfgPPTyPPCon @lhs.cfg @lhs.cfg @nm
  | App             loc     .   ppDflt  :=  if cfgPPTyFollowAST @lhs.cfg then ppParens @func.pp >#< ppParens @arg.pp else @func.pp >#< @arg.pp
                            .   ppAST   :=  hv ([ppParens @appFunPP] ++ map ((" " >|<) . ppParens) @appArgPPL)
                            .   pp      :=  if @isSpineRoot
                                            then if cfgPPTyFollowAST @lhs.cfg
                                                 then @ppAST
                                                 else @ppNice
                                            else @ppDflt

SEM Ty
  | App             loc     .   ppAppTop:=  ppAppTop' (@appFunNm,@appFunPP) @appArgPPL @appArgIsEmptyImplsL @ppDflt

SEM Ty
  | Var             loc     .   pp      :=  maybe (cfgPPTyPPVarDflt @lhs.cfg @lhs.cfg (tvCategPrefix @categ.self) @tv) id (tnLookupPP @tv @lhs.tnMap)

SEM Ty
  | TBind           loc     .   ppQu    =   pp "forall"
                            .   ppTv    =   @tnPP
                            .   ppTvPre =   empty
                            .   ppTvPost=   empty
                            .   pp      =   ppParNeed  @parNeed @lhs.parNeed
                                                       (@ppQu >#< @ppTvPre >|< @ppTv >|< @ppTvPost >#< "." >#< @ty.pp)

SEM Ty
  | TBind           loc     .   ppQu 	:=	@qu.pp


SEM Ty
  | TBind           inst    .   l1'     :   Ty
                    inst    .   l1'     =   @l1
                    loc     .   ppL1    :=  @l1'.pp
                            .   ppTvPost:=  if maybe False (== hsnKindStar) $ tyMbCon @l1 then empty else ppParens @ppL1

SEM Ty
  | TBind           loc     .   pp      :=  ppParNeed  @parNeed @lhs.parNeed
                                                       (cfgppAside @lhs.cfg (@ppQu >#< @ppTvPre >|< @ppTv >|< @ppTvPost) ("." >#< @ty.pp))

SEM TyQu
  | *   			lhs     .   pp      =   text (showTyQu @self)

SEM Ty
  | Ext             loc     .   ppNice  =   ppExts @appFunNm @appFunPP @appArgPPL
                            .   pp      =   @ppNice

SEM Ty
  | Ext             loc     .   (ppNice,ppCfg)
                                        :=  ppExts @lhs.cfg @appFunNm @appFunPP @appArgPPL
                            .   pp      :=  if @isSpineRoot then @ppCfg else @ppNice

SEM Ty
  | Pred Impls      loc     .   wrapPP  =   if cfgPPTyCtxt @lhs.cfg == TyCtxt_Pred then id else (\pp -> hsnOImpl >#< pp >#< hsnCImpl)
  | Pred            loc     .   pp      =   cfgPPTyPPImplsAppWrap @lhs.cfg @wrapPP @pr.pp
  | Impls           loc     .   pp      =   cfgPPTyPPImplsAppWrap @lhs.cfg @wrapPP @impls.pp
  | Con             loc     .   pp      :=  if cfgPPTyCtxt @lhs.cfg == TyCtxt_Pred && hsnIsArrow @nm
                                            then cfgPPTyPPCon @lhs.cfg @lhs.cfg hsnPrArrow
                                            else cfgPPTyPPCon @lhs.cfg @lhs.cfg @nm

SEM Impls
  | Tail Cons       loc     .   ppIv    =   cfgPPTyPPImplsTailCons @lhs.cfg
                                              (maybe (cfgPPTyPPVarDflt @lhs.cfg @lhs.cfg "i" @iv) id (tnLookupPP @iv @lhs.tnMap))
                                              (ppBracketsCommas @proveOccs)
  | Tail            lhs     .   pp      =   @ppIv
  | Cons            loc     .   ppPv    =   maybe (cfgPPTyPPVarDflt @lhs.cfg @lhs.cfg "p" (poiId @pv)) id (tnLookupPP @iv @lhs.tnMap)
                    lhs     .   pp      =   cfgPPTyPPImplsPred @lhs.cfg @ppIv @pr.pp @ppPv >|< "," >|< @tl.pp
  | Nil             lhs     .   pp      =   pp "_"

SEM Pred
  | Var             lhs     .   pp      =   maybe (cfgPPTyPPVarDflt @lhs.cfg @lhs.cfg "p" @pv) id (tnLookupPP @pv @lhs.tnMap)

SEM Label
  | Lab             lhs     .   pp      =   cfgPPTyPPHsn @lhs.cfg @nm
  | Var             lhs     .   pp      =   maybe (cfgPPTyPPVarDflt @lhs.cfg @lhs.cfg "l" @lv) id (tnLookupPP @lv @lhs.tnMap)

SEM Pred
  | Lacks           lhs     .   pp      =   @ty.pp >|< "\\" >|< @lab.pp

ATTR PredSeq [ | | ppL: {[PP_Doc]} ]

SEM PredSeq
  | Cons            lhs     .   ppL     =   @hd.pp :  @tl.ppL
  | Var             lhs     .   ppL     =   [maybe (cfgPPTyPPVarDflt @lhs.cfg @lhs.cfg "prsq" @av) id (tnLookupPP @av @lhs.tnMap)]
  | Nil             lhs     .   ppL     =   []

SEM Pred
  | Arrow           lhs     .   pp      =   ppParensCommas @args.ppL >#< "=>" >#< @res.pp
  | Preds           lhs     .   pp      =   ppParensCommas @seq.ppL

SEM Ty
  | Lam             loc     .   pp      =   ppParNeed  @parNeed @lhs.parNeed
                                                       (cfgppAside @lhs.cfg ("\\" >|< @tnPP) ("->" >#< @ty.pp))

SEM Pred
  | Eq              lhs     .   pp      =   @tyL.pp >#< hsnEqTilde >#< @tyR.pp

SEM TyAnn
  | Empty			loc		.	pp		=	empty
  | Strictness      loc     .   pp      =   "@" >|< show @s
  | Mono			loc		.	pp		=	pp "MONO "

ATTR Ty [ | positionalFldNmL: {[HsName]} | ]

SEM TyAGItf
  | AGItf           ty      .   positionalFldNmL    =   positionalFldNames

SEM Ty
  | Ext             (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @ty.positionalFldNmL
                    extTy   .   positionalFldNmL    =   positionalFldNames
  | * - Ext         lhs     .   positionalFldNmL    =   @lhs.positionalFldNmL

SEM Pred
  | *               loc     .   positionalFldNmL    =   positionalFldNames

SEM Ty
  | App             loc     .  recSep       =   cfgPPTyLhsSafe @lhs.cfg "|"

ATTR
  Ty [ | | appFunPP: PP_Doc      appArgPPL: {[PP_Doc]}
     ]

SEM Ty
  | App             loc     .  (appFunPP,appArgPPL)
                                            :=  mkExtAppPP' @recSep
                                                            (@appFunNm,@func.appFunPP,@func.appArgPPL)
                                                            (@arg.appFunNm,@arg.appFunPP,@arg.appArgPPL,@arg.pp)
  | Ext             loc     .  fldPP        =   ppFld "::" (Just @positionalNm) @nm (pp @nm) @extTy.pp
                            .  appArgPPL    :=  @ty.appArgPPL ++ [@fldPP]
                            .  appFunPP     :=  @ty.appFunPP
  | * - App Ext     lhs     .  appArgPPL    :=  []
                            .  appFunPP     :=  @pp

SEM Ty
  | App             loc     .  (appFunPP,appArgPPL)
                                            :=  if cfgPPTyFollowAST @lhs.cfg
                                                then (@func.appFunPP,@func.appArgPPL ++ [@arg.pp])
                                                else mkExtAppPP' @recSep
                                                                 (@appFunNm,@func.appFunPP,@func.appArgPPL)
                                                                 (@arg.appFunNm,@arg.appFunPP,@arg.appArgPPL,@arg.pp)
  | Ext             loc     .  fldPP        :=  let pn = if cfgPPTyFollowAST @lhs.cfg then Nothing else Just @positionalNm
                                                in  ppFld "::" pn @nm (cfgPPTyPPHsn @lhs.cfg @nm) @extTy.pp


ATTR Ty [ parNeed: ParNeed  parNeedL: ParNeedL | | ]

SEM TyAGItf
  | AGItf       ty      .   parNeed             =   ParNotNeeded
                        .   parNeedL            =   []

SEM Ty
  | App         loc     .   (parNeed,argsParNeedL)
                                                =   if @isSpineRoot
                                                    then  parNeedApp @appFunNm
                                                    else  (ParNotNeeded,@lhs.parNeedL)
                (arg.parNeed,func.parNeedL)
                                                =   hdAndTl @argsParNeedL

SEM Ty
  | TBind       loc     .   parNeed             =   ParNotNeeded

SEM Ty
  | Ext         ty      .   parNeed             =   ParNotNeeded
                extTy   .   parNeed             =   ParNotNeeded
                loc     .   parNeed             =   ParNotNeeded

SEM Pred
  | Pred        loc     .   parNeed             =   ParNeeded
                        .   parNeedL            =   []
  | * - Pred    loc     .   parNeed             =   ParNotNeeded
                        .   parNeedL            =   []

SEM Ty
  | Lam         loc     .   parNeed             =   ParNotNeeded

ATTR Ty Impls [ | | isEmptyImpls: Bool ]

SEM Impls
  | Nil             lhs     .   isEmptyImpls            =   cfgPPTyElimEmptyImpls @lhs.cfg
  | * - Nil         lhs     .   isEmptyImpls            =   False

SEM Ty
  | * - Impls       lhs     .   isEmptyImpls            =   False

ATTR Ty [ | | appArgIsEmptyImplsL: {[Bool]} ]

SEM Ty
  | App             loc     .   appArgIsEmptyImplsL     =   @func.appArgIsEmptyImplsL ++ [@arg.isEmptyImpls]
  | * - App         lhs     .   appArgIsEmptyImplsL     =   []

