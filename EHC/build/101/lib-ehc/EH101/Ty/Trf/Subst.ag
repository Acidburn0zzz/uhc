MODULE {EH101.Ty.Trf.Subst} {tyAppVarLookup, tyAppVarLookup2}
{
import EH101.Base.Common
import EH101.Ty
import EH101.VarMp
import EH.Util.Utils
import qualified Data.Map as Map
import EH101.VarLookup
import EH101.Base.Debug
import EH.Util.Pretty
import EH101.Ty.Pretty

}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Ty/AbsSyn.ag"
WRAPPER TyAGItf

{
tyAppVarLookup' :: VarLookup m TyVarId VarMpInfo => SubstOpts -> m -> TVUseMp -> Ty -> (Ty,VarMp)
tyAppVarLookup' opts m usemp ty
  = (repl_Syn_TyAGItf t,cycVarMp_Syn_TyAGItf t)
  where t = wrap_TyAGItf
              (sem_TyAGItf (TyAGItf_AGItf ty))
              (Inh_TyAGItf
                 { substOpts_Inh_TyAGItf 	= opts
                 , tvUseMp_Inh_TyAGItf 		= usemp
                 , lkup_Inh_TyAGItf 		= mkLkup m
                 })

tyAppVarLookup :: VarLookup m TyVarId VarMpInfo => m -> Ty -> Ty
tyAppVarLookup m ty
  = ty'
  where (ty',_) = tyAppVarLookup' defaultOpts m Map.empty ty

tyAppVarLookup2 :: VarLookup m TyVarId VarMpInfo => m -> Ty -> (Ty,VarMp)
tyAppVarLookup2 m ty
  = tyAppVarLookup' defaultOpts m Map.empty ty

}
{
data SubstOpts
  = SubstOpts

defaultOpts :: SubstOpts
defaultOpts = SubstOpts

}
-- PRAGMA novisit

{
type Lkup = MetaLev -> TyVarId -> Maybe VarMpInfo

mkLkup :: VarLookup m TyVarId VarMpInfo => m -> Lkup
mkLkup m = \mlev v -> {- trm "Subst.lkup" (\r -> mlev >#< v >#< r) $ -} varlookupWithMetaLev mlev v m

}
ATTR TyAGItf AllTy [ lkup: Lkup | | ]

SEM Ty
  | TBind
    Lam
                    ty      .   lkup        =   \mlev v -> if v == @tv then Nothing else @lhs.lkup mlev v
  | TBind           l1'     .   lkup        =   \mlev v -> @lhs.lkup (mlev+1) v

ATTR LabelAGItf Label [ lkup: Lkup | | ]

{
data TVUse
  = TVFree      -- is still free
  | TVBound     -- is already bound
  | TVSubst     -- is being substituted (for occur check implementation)

type TVUseMp = Map.Map TyVarId TVUse

tvUse :: TyVarId -> TVUseMp -> TVUse
tvUse tv = maybe TVFree id . Map.lookup tv

}
{
type IsBound = TyVarId -> Bool

}
{
tvRepl3 :: TyVarId -> TVUse -> (TyVarId -> x -> VarMp) -> x -> x -> x -> VarMp -> (x,VarMp)
tvRepl3 tv tvuse mk repl replv replho cycmpho
  = case tvuse of
      TVFree  -> (replho,cycmpho)
      TVBound -> (repl,emptyVarMp)
      TVSubst -> (repl,mk tv replv)

}
SEM Ty
  | Var             inst    .   repl'       :   Ty
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ vmiMbTy $? @lhs.lkup 0 @tv
		    loc     .   needRepl    =   case @tvUse of
		    	    		    	   TVFree -> @isRepl
						   _      -> False
                    inst    .   repl'       =   if @needRepl then @replv else Ty_Any

SEM Impls
  | Tail            inst    .   repl'       :   Impls
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ vmiMbImpls $? @lhs.lkup 0 @iv
		    loc     .   needRepl    =   case @tvUse of
		    	    		           TVFree -> @isRepl
						   _      -> False
                    inst    .   repl'       =   if @needRepl then @replv else Impls_Nil

SEM Pred
  | Var             inst    .   repl'       :   Pred
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ vmiMbPred $? @lhs.lkup 0 @pv
		    loc     .   needRepl    =   case @tvUse of
		    	    		           TVFree -> @isRepl
						   _      -> False
                    inst    .   repl'       =   if @needRepl then @replv else Pred_Pred Ty_Any

SEM Label
  | Var             inst    .   repl'       :   Label
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ vmiMbLabel $? @lhs.lkup 0 @lv
		    loc     .   needRepl    =   case @tvUse of
		    	    		           TVFree -> @isRepl
						   _      -> False
                    inst    .   repl'       =   if @needRepl then @replv else Label_Lab (HsName_Base "")

SEM PredSeq
  | Var             inst    .   repl'       :   PredSeq
                    (loc.replv,loc.isRepl)  =   maybe (@repl,False) (\t -> (t,True)) $ vmiMbPredSeq $? @lhs.lkup 0 @av
		    loc     .   needRepl    =   case @tvUse of
		    	    		           TVFree -> @isRepl
						   _      -> False
                    inst    .   repl'       =   if @needRepl then @replv else PredSeq_Nil

SEM Ty
  | TBind			inst	.	l1'			: 	Ty
                    inst    .   l1'	       	=   @l1

ATTR
  AllTyAndFlds
  TyAGItf
  LabelAGItf
    [ tvUseMp: TVUseMp | | ]


SEM Ty
  | TBind
    Lam
                    ty      .   tvUseMp     =   Map.insert @tv TVBound @lhs.tvUseMp

SEM Ty
  | Var             repl'   .   tvUseMp     =   Map.insert @tv TVSubst @lhs.tvUseMp
                    loc     .   tvUse       =   tvUse @tv @lhs.tvUseMp

SEM Ty
  | TBind			l1'     .   tvUseMp     =   Map.empty

SEM Pred
  | Var             repl'   .   tvUseMp     =   Map.insert @pv TVSubst @lhs.tvUseMp
                    loc     .   tvUse       =   tvUse @pv @lhs.tvUseMp

SEM Impls
  | Tail            repl'   .   tvUseMp     =   Map.insert @iv TVSubst @lhs.tvUseMp
                    loc     .   tvUse       =   tvUse @iv @lhs.tvUseMp

SEM Label
  | Var             repl'   .   tvUseMp     =   Map.insert @lv TVSubst @lhs.tvUseMp
                    loc     .   tvUse       =   tvUse @lv @lhs.tvUseMp

SEM PredSeq
  | Var             repl'   .   tvUseMp     =   Map.insert @av TVSubst @lhs.tvUseMp
                    loc     .   tvUse       =   tvUse @av @lhs.tvUseMp

ATTR TyAGItf AllTyAndFlds  [ | | cycVarMp USE {`varmpPlus`} {emptyVarMp}: VarMp ]

ATTR AllTyAndFlds   [               | | repl: SELF  ]
ATTR TyAGItf        [               | | repl: Ty    ]

ATTR TyAGItf AllTy [ substOpts: SubstOpts | | ]

ATTR LabelAGItf        [               | | repl: Label    ]

SEM Ty
  | Ann             lhs     .   repl        =   tyCanonAnn @repl

SEM Ty
  | Var             lhs     .   repl        =   tyCanonAnn $ maybe @repl id (@lhs.lkup 0 @tv)

SEM Ty
  | Var             lhs     .   repl        :=  tyCanonAnn $ tvRepl @tv @lhs.lkup @lhs.tvUseMp @repl

SEM Ty
  | Var             lhs     .   (repl,cycVarMp)
                                            :=  if @isRepl
                                                then tvRepl3 @tv @tvUse varmpTyUnit @repl @replv @repl'.repl @repl'.cycVarMp
                                                else (@repl,emptyVarMp)

SEM Ty
  | TBind			lhs		.	repl 		=	Ty_TBind @qu.repl @tv @l1'.repl @ty.repl
  							.	cycVarMp	=	varmpIncMetaLev @l1'.cycVarMp `varmpPlus` @ty.cycVarMp

SEM Impls
  | Tail            lhs     .   (repl,cycVarMp)
                                            :=  if @isRepl
                                                then let replrepl = case @repl'.repl of
                                                                      Impls_Tail i occs -> Impls_Tail i (occs ++ @proveOccs)
                                                                      r                 -> r
                                                     in  tvRepl3 @iv @tvUse varmpImplsUnit @repl @replv replrepl @repl'.cycVarMp
                                                else (@repl,emptyVarMp)

SEM Pred
  | Var             lhs     .   (repl,cycVarMp)
                                            :=  if @isRepl
                                                then tvRepl3 @pv @tvUse varmpPredUnit @repl @replv @repl'.repl @repl'.cycVarMp
                                                else (@repl,emptyVarMp)

SEM Label
  | Var             lhs     .   (repl,cycVarMp)
                                            :=  if @isRepl
                                                then tvRepl3 @lv @tvUse varmpLabelUnit @repl @replv @repl'.repl @repl'.cycVarMp
                                                else (@repl,emptyVarMp)

SEM PredSeq
  | Var             lhs     .   (repl,cycVarMp)
                                            :=  if @isRepl
                                                then tvRepl3 @av @tvUse varmpPredSeqUnit @repl @replv @repl'.repl @repl'.cycVarMp
                                                else (@repl,emptyVarMp)

