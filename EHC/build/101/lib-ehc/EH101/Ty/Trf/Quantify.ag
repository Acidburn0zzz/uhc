MODULE {EH101.Ty.Trf.Quantify} {tyQuantify, tyQuantifyClosed
, TyQuOpts (..), defaultTyQuOpts
, TyQuOut (..)
, tyQuantifyOuter
, tyKiQuantify, valTyQuantify
, tyQuantifyRank, tyQuantifyRank'}
{
import EH.Util.Utils
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Ty
import EH101.VarMp
import EH101.Substitutable
import EH101.Base.Debug
import EH.Util.Pretty
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.List as List
import Data.Maybe
import EH.Util.Utils
import EH.Util.Pretty

}
{
}
{
}
{
}
INCLUDE "Ty/AbsSyn.ag"
INCLUDE "Ty/CommonAG.ag"
INCLUDE "Ty/TyVarCommon.ag"
WRAPPER TyAGItf

{
}
{
}

{
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantifyRank [1..]

tyQuantifyRank' :: TvIsBound -> [Int] -> Ty -> Ty
tyQuantifyRank' tvIsBound rL ty
  = tqoTy (tyQuantifyWithOpts (defaultTyQuOpts {tqoptQuRanks = rL, tqoptBaseQuant = tyQu_Forall, tqoptTvIsBound = tvIsBound}) ty)

tyQuantifyRank :: [Int] -> Ty -> Ty
tyQuantifyRank = tyQuantifyRank' (const False)

}
{
tyQuantify :: TvIsBound -> Ty -> Ty
tyQuantify tvIsBound ty = tyQuantify' tvIsBound tyQu_Forall ty

}
{
tyQuantifyOuter :: (TyVarId -> Ty) -> TvIsBound -> Ty -> Ty
tyQuantifyOuter tvKi tvIsBound ty
  = tqoTy tqo
  where tqo = tyQuantifyWithOpts
                (defaultTyQuOpts
                  { tqoptAllowInnerQuant = False
                  , tqoptTvIsBound       = tvIsBound
                  , tqoptBaseQuant       = tyQu_Forall
                  , tqoptTvL1       	 = tvKi
                  }
                )
                ty

}
{
tyKiQuantify :: TvIsBound -> Ty -> Ty
tyKiQuantify tvIsBound ty -- = tyQuantify' tvIsBound tyQu_Forall {- tyQu_KiForall -} ty
  = tqoTy $ tyQuantifyWithOpts opts ty
  where opts = defaultTyQuOpts
                  { tqoptAllowInnerQuant = False
                  , tqoptTvIsBound       = tvIsBound
                  , tqoptBaseQuant       = tyQu_Forall
                  }

valTyQuantify :: (TyVarId -> Ty) -> TvIsBound -> Ty -> Ty
valTyQuantify tvKi tvIsBound ty
  = tqoTy $ tyQuantifyWithOpts opts ty
  where opts = defaultTyQuOpts
                  { tqoptAllowInnerQuant = False
                  , tqoptTvIsBound       = tvIsBound
                  , tqoptTvL1       	 = tvKi
                  }

}
{
tyQuantify' :: TvIsBound -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty
  = tqoTy tqo
  where tqo = tyQuantifyWithOpts
                (defaultTyQuOpts
                  { tqoptTvIsBound       = tvIsBound
                  , tqoptBaseQuant       = baseQuant
                  }
                )
                ty

}
{
data TyQuOpts
  = TyQuOpts
      { tqoptTvIsBound			:: TvIsBound
      , tqoptAllowInnerQuant	:: Bool
      , tqoptBaseQuant			:: TyQu
      , tqoptTvL1				:: TyVarId -> Ty		-- mapping of tvar to 1 higher metalevel ty (i.e. kind)
      , tqoptQuRanks 			:: [Int]
      }

defaultTyQuOpts :: TyQuOpts
defaultTyQuOpts
  = TyQuOpts
      (const False)
      True
      tyQu_Forall
      (const kiStar)
      [1..]

}
{
data TyQuOut
  = TyQuOut   { tqoTy               ::  Ty
              }

}
{
tyQuantifyWithOpts :: TyQuOpts -> Ty -> TyQuOut
tyQuantifyWithOpts opts ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { opts_Inh_TyAGItf          = opts
                                , baseQu_Inh_TyAGItf        = tqoptBaseQuant opts
                                })
    in   TyQuOut
            { tqoTy                 = quTy_Syn_TyAGItf t
            }

}
SEM TyAGItf
  | AGItf       ty          .   pol         =   polCovariant

ATTR TyAGItf AllTy [ opts: TyQuOpts | | ]

SEM TyAGItf
  | AGItf       loc         .   opts        =   @lhs.opts
                                                  { tqoptQuRanks = take 5 (tqoptQuRanks @lhs.opts)
                                                  }

SEM Ty
  | *           loc         .   isQuLocExtraHook
  											=   @lhs.isAtTop || tqoptAllowInnerQuant @lhs.opts

ATTR AllTy [ rank: Int | | ]

SEM Ty
  | App         arg         .   rank        =   @lhs.rank + (if @isArrowArg then 1 else 0)

SEM TyAGItf
  | AGItf       loc         .   rank        =   1

SEM TyAGItf
  | AGItf       loc         .   isQuRank    =   @rank `elem` tqoptQuRanks @opts

SEM Ty
  | Var App Pred TBind
                loc         .   isQuRank    =   @lhs.rank `elem` tqoptQuRanks @lhs.opts


SEM Ty
  | App         loc         .   isQuFxLoc   =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt == TyQuCtxtOther
                                                        )
  | Var TBind   loc         .   isQuFxLoc   =   False

SEM Ty
  | Pred        loc         .   isQuFxLoc   =   False

{
type TvIsBound = TyVarId -> Bool
type TvLevIsBound = MetaLev -> TvIsBound

tvIsBound2L :: MetaLev -> TvIsBound -> TvLevIsBound
tvIsBound2L mlev b = \mlev' -> if mlev' == mlev then b else const False

tvIsBound2L0, tvIsBound2L1 :: TvIsBound -> TvLevIsBound
tvIsBound2L0 = tvIsBound2L 0
tvIsBound2L1 = tvIsBound2L 1

}
{
type TyVarIdsToBind = AssocL TyVarId Ty

}
{
tvBoundAddS :: MetaLev -> TyVarIdS -> TvLevIsBound -> TvLevIsBound
tvBoundAddS mlev tvS tvIsBound = \mlev' v -> (mlev == mlev' && v `Set.member` tvS) || tvIsBound mlev' v

tvNotBound :: MetaLev -> TvLevIsBound -> TyVarIdS -> TyVarIdS
tvNotBound mlev tvIsBound = Set.filter (\tv -> not (tvIsBound mlev tv))

}
{
tvarsToQuantL1 :: TyVarIdsToBind -> TvLevIsBound -> (TyVarIdsToBind,TyVarIdS,TvLevIsBound)
tvarsToQuantL1 boundablesL tvIsBound
  = (boundablesL1L,boundablesL1S,tvBoundAddS 1 boundablesL1S tvIsBound)
  where boundablesL1S = tvNotBound 1 tvIsBound $ Set.unions [ varFreeSet l1 | (_,l1) <- boundablesL ]
        boundablesL1L = [ (v,kiStar) | v <- Set.toList boundablesL1S ]

}
{
tvarsToQuant :: TyQuOpts -> Bool -> TvCatMp -> (TyVarId -> Bool) -> TvLevIsBound -> TyVarIdS -> (TyVarIdsToBind,TyVarIdsToBind,TyVarIdsToBind,TvLevIsBound)
tvarsToQuant opts isQuLoc _ mayQuFx tvIsBound tvS
  =  if isQuLoc
     then  let boundablesS = tvNotBound 0 tvIsBound tvS
               boundablesL                = [ (v,{- trm "tvarsToQuant" (\k -> v >|< "::" >|< k) $ -} tqoptTvL1 opts v) | v <- Set.toList boundablesS ]
               (boundablesL1L,_,tvIsBound') = tvarsToQuantL1 boundablesL (tvBoundAddS 0 boundablesS tvIsBound)
               -- tvIsBound'  = tvBoundAddS (boundablesS `Set.union` boundablesL1S) tvIsBound
           in ( boundablesL
              , []
              , boundablesL1L
              , tvIsBound'
              )
     else  ([],[],[],tvIsBound)

}
{
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = False -- isQuFxLoc -- True

}
ATTR AllTy [ tvIsBound: {TvLevIsBound} | | ]

SEM TyAGItf
  | AGItf       loc         .   (qBndTvs,qBndExTvs,qBndL1Tvs,tvIsBound)
                                                        =   tvarsToQuant @lhs.opts True @fxTvM
                                                                         (const False)
                                                                         (tvIsBound2L0 $ tqoptTvIsBound @lhs.opts) @qHereTvS

SEM Ty
  | App Var     loc         .   (qBndTvs,qBndExTvs,qBndL1Tvs,tvIsBound)
                                                        =   tvarsToQuant @lhs.opts @isQuLoc @lhs.fxTvM
                                                                         (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc)
                                                                         @lhs.tvIsBound @qHereTvS
  | TBind       loc         .   tvIsBoundQu             =   tvBoundAddS 0 @introTVarS @lhs.tvIsBound
                            .   (qBndTvs,qBndExTvs,qBndL1TvsOther,tvIsBound)
                                                        =   tvarsToQuant @lhs.opts @isQuLoc @lhs.fxTvM
                                                                         (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc)
                                                                         @tvIsBoundQu @qHereTvS
                            .   qBndL1Tvs               =   @qBndL1TvsOther

SEM Ty
  | TBind       loc         .   (qBndL1TvsQu,tvIsBoundQu)
                                                        :=  let (qBndL1Tvs,_,isB) = tvarsToQuantL1 [(@tv,@l1)] @lhs.tvIsBound
                                                            in  (qBndL1Tvs, tvBoundAddS 0 @introTVarS isB)
                            .   qBndL1Tvs               :=  {- trm "Quant" (\v -> @tv >|< "::" >|< @l1 >#< show v >#< "=" >#< show @qBndL1TvsOther >|< "++" >|< show @qBndL1TvsQu) $ -} @qBndL1TvsOther ++ @qBndL1TvsQu

SEM Ty
  | App Var     loc         .   (qBndTvs,qBndExTvs,qBndL1Tvs,tvIsBound)
                                                        :=  tvarsToQuant @lhs.opts @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound @qHereTvS

SEM Ty
  | Pred        loc         .   (qBndTvs,qBndExTvs,qBndL1Tvs,tvIsBound)
                                                        =   tvarsToQuant @lhs.opts @isQuLoc @lhs.fxTvM (const False) @lhs.tvIsBound @qHereTvS

SEM Ty
  | Lam         loc         .   tvIsBound               =   tvBoundAddS 0 @introTVarS @lhs.tvIsBound

SEM TyAGItf
  | AGItf       loc         .   hereQu          =   tyQu_Forall

SEM Ty
  | App         loc         .   qAsExist        =   @appIsLikeProd || polIsContravariant @lhs.pol && not @appIsArrow
  | Var         loc         .   qAsExist        =   polIsContravariant @lhs.pol
  | App Var     loc         .   hereQu          =   if @qAsExist then tyQu_Exists else tyQu_Forall
  | TBind       loc         .   hereQu          =   tyQu_Forall -- @qu.self

ATTR TyAGItf AllTy [ baseQu: TyQu | | ]

SEM TyAGItf
  | AGItf       loc         .   hereQu          :=  @lhs.baseQu

SEM Ty
  | App Var     loc         .   hereQu          :=  if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu

SEM Ty
  | App         loc         .   qAsExist        :=  (@appIsLikeProd || polIsContravariant @lhs.pol && not @appIsArrow)
  | Var         loc         .   qAsExist        :=  polIsContravariant @lhs.pol

SEM Ty
  | Pred        loc         .   qAsExist        =   polIsContravariant @lhs.pol
                            .   hereQu          =   if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu

{
mkTyQuEx :: TyQuOpts -> TyQu -> TyVarIdsToBind -> TyVarIdsToBind-> TyVarIdsToBind -> Ty -> Ty
mkTyQuEx opts q tvsL1 tvs tvsEx t
  =
    mkTyQu (TyQu_Forall (tyquMetaLev q + 1)) tvsL1 $
    mkTyQu q tvs $
    mkTyQu (tyquExists q) tvsEx t

}
SEM TyAGItf
  | AGItf       loc         .   quTyBase        =   @ty.quTy

SEM Ty
  | Var         loc         .   quTyBase        =   Ty_Var @tv @categ.quTy
  | App         loc         .   quTyBase        =   Ty_App @func.quTy @arg.quTy
  | TBind       loc         .   quTyBase        =
                                                    Ty_TBind @qu.self @tv @l1 @ty.quTy

ATTR TyAGItf [ | | quTy: Ty ]
ATTR AllTyAndFlds [ | | quTy: SELF ]

SEM TyAGItf
  | AGItf       lhs         .   quTy            =   mkTyQuEx @lhs.opts @hereQu @qBndL1Tvs @qBndTvs @qBndExTvs @quTyBase

SEM Ty
  | Var App TBind
  				lhs         .   quTy            =   mkTyQuEx @lhs.opts @hereQu @qBndL1Tvs @qBndTvs @qBndExTvs @quTyBase

{
mkTyQuForRank :: TyQuOpts -> Bool -> TyQu -> TyVarIdsToBind -> TyVarIdsToBind -> TyVarIdsToBind -> Ty -> Ty
mkTyQuForRank opts allow q tvsL1 tvs tvsEx t
  | allow     = mkTyQuEx opts q tvsL1 tvs tvsEx t
  | otherwise = t

}
SEM TyAGItf
  | AGItf       lhs         .   quTy            :=  mkTyQuForRank @lhs.opts @isQuRank @hereQu @qBndL1Tvs @qBndTvs @qBndExTvs @quTyBase

SEM Ty
  | Var TBind   lhs         .   quTy            :=  mkTyQuForRank @lhs.opts @isQuRank @hereQu @qBndL1Tvs @qBndTvs @qBndExTvs @quTyBase
  | App         lhs         .   quTy            :=  let  (rwYTvS,rwNTvS) = partition (\(v,_) -> v `Set.member` @frRowTvS) @qBndTvs
                                                    in   mkTyQuForRank @lhs.opts @isQuRank @hereQu @qBndL1Tvs rwNTvS @qBndExTvs
                                                         $  mkTyQuForRank @lhs.opts @isQuRank @lhs.baseQu [] rwYTvS []
                                                         $  @quTyBase
  | Pred        lhs         .   quTy            =   mkTyQuForRank @lhs.opts @isQuRank @hereQu @qBndL1Tvs @qBndTvs @qBndExTvs (mkTyPr @pr.quTy)

SEM Ty
  | Lam         lhs         .   quTy            =   Ty_Lam @tv @ty.quTy

