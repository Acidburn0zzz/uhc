MODULE {EH101.Ty.Trf.Canonic} {TyCanonicOut
, TyCanonicOpts (..), emptyTyCanonicOpts
, tyCanonic
, tyCanonicFFI'
, tyCanonicFFI
, predCanonic
, tyCanonic'
, predCanonic'}
{
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Ty
import EH101.VarMp
import EH101.Substitutable
import EH101.Ty.FitsInCommon2
import Data.Maybe
import qualified Data.Set as Set
import EH101.Opts
import EH101.Ty.Trf.BetaReduce
import EH.Util.Utils
import EH101.Gam.Full
import EH.Util.Debug
import EH.Util.Pretty
import EH101.Base.Builtin
import Control.Applicative
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Ty/AbsSyn.ag"
INCLUDE "Ty/CommonAG.ag"
WRAPPER TyAGItf

PRAGMA strictcase

{
type TyCanonicOut' x = TyBetaRedOut' x
type TyCanonicOut    = TyBetaRedOut

mkCanonicOut x y = emptyTyBetaRedOut {tbroutRes = x, tbroutVarMp = y}

mkDfltTyCanonicOut :: x -> TyCanonicOut' x
mkDfltTyCanonicOut = mkDfltTyBetaRedOut

}
{
data TyCanonicOpts
  = TyCanonicOpts
      { tcoTyBetaRedFullMb  :: Ty -> Maybe TyCanonicOut
      }

emptyTyCanonicOpts :: TyCanonicOpts
emptyTyCanonicOpts
  = TyCanonicOpts
      { tcoTyBetaRedFullMb  = \t -> Nothing
      }

}
{
tcoTyBetaRedFull :: TyCanonicOpts -> Ty -> TyCanonicOut
tcoTyBetaRedFull tco ty = maybe (mkDfltTyCanonicOut ty) id $ tcoTyBetaRedFullMb tco ty

}
{
tyCanonicMb' :: TyCanonicOpts -> Ty -> Maybe TyCanonicOut
tyCanonicMb' opts ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf
                   { opts_Inh_TyAGItf = opts
                   }
                 )
     in   if isReplaced_Syn_TyAGItf t then Just (mkCanonicOut (repl_Syn_TyAGItf t) (varMp_Syn_TyAGItf t)) else Nothing

tyCanonic' :: TyCanonicOpts -> Ty -> TyCanonicOut
tyCanonic' opts ty = maybe (mkDfltTyCanonicOut ty) id $ tyCanonicMb' opts ty

}
{
predCanonic' :: TyCanonicOpts -> Pred -> (Pred,VarMp)
predCanonic' opts pr
  = case tyCanonicMb' opts $ mkTyPr pr of
      -- Just (Ty_Pred pr',m) -> (pr', m)
      Just (r@(TyBetaRedOut {tbroutRes = Ty_Pred pr'})) -> (pr', tbroutVarMp r)
      _                    -> (pr, emptyVarMp)

}
{
tyCanonic
  :: (VarLookup gm TyVarId VarMpInfo, VarLookupCmb VarMp gm)
     => TyBetaRedEnv gm -> Ty
     -> Ty
tyCanonic fi
  = tbroutRes . tyCanonic' opts
  where opts = emptyTyCanonicOpts
                  {tcoTyBetaRedFullMb = tyBetaRedFullMb fi canonLkupTy (tyCanonicMb' opts)}

}
{
tyCanonicFFI'
  :: (VarLookup gm TyVarId VarMpInfo, VarLookupCmb VarMp gm)
     => Bool			-- expand newtypes
     -> TyBetaRedEnv gm
     -> Ty
     -> Ty
tyCanonicFFI' expNewtype renv
  = tbroutRes . tyCanonic' opts
  where opts = emptyTyCanonicOpts
                  {tcoTyBetaRedFullMb = tyBetaRedFullMb renv canonLkupTy' (tyCanonicMb' opts)}
        canonLkupTy' renv nm = -- tr "tyCanonicFFI" (pp nm) $
                             newtypeLamLkup <|> canonLkupTy renv nm
                     where newtypeLamLkup | not expNewtype = Nothing
                                          | ehcOptBuiltin ehcopts ehbnIO == nm
                                                           = Nothing
                                          | otherwise      = fmap mkDfltTyCanonicOut (dgiMbNewtype $? dataGamLookup nm $ feDataGam fe)
        fe      = fiEnv fi
        fi      = tbredFI renv
        ehcopts = feEHCOpts fe

}
{
tyCanonicFFI
  :: (VarLookup gm TyVarId VarMpInfo, VarLookupCmb VarMp gm)
     => TyBetaRedEnv gm
     -> Ty
     -> Ty
tyCanonicFFI = tyCanonicFFI' False

}
{
predCanonic
  :: (VarLookup gm TyVarId VarMpInfo, VarLookupCmb VarMp gm)
     => TyBetaRedEnv gm -> Pred
     -> (Pred,VarMp)
predCanonic renv
  = predCanonic' opts
  where opts = emptyTyCanonicOpts
                  {tcoTyBetaRedFullMb = tyBetaRedFullMb renv canonLkupTy (tyCanonicMb' opts)}

}
{
canonLkupTy :: TyBetaRedLkup gm
canonLkupTy = betaRedTyLookup

}
ATTR TyAGItf AllTy [ opts: TyCanonicOpts | | ]

ATTR TyAGItf [ | | varMp: VarMp ]
ATTR AllTy [ | varMp: VarMp | ]

SEM TyAGItf
  | AGItf           loc     .   varMp           =   emptyVarMp

SEM Impls
  | Tail            lhs     .   varMp           =   varmpImplsUnit @iv Impls_Nil `varUpd` @lhs.varMp

SEM Ty
  | App             lhs     .   varMp           =   @replVarMp `varUpd` @arg.varMp
  | Con             lhs     .   varMp           =   @replVarMp `varUpd` @lhs.varMp

{
type MbPredL = Maybe [Pred]

mbPredLCmb :: MbPredL -> MbPredL -> MbPredL
mbPredLCmb Nothing Nothing = Nothing
mbPredLCmb m1      m2      = Just $ concat $ maybeToList m1 ++ maybeToList m2

}
ATTR Ty Impls Pred [ | | mbPredL USE {`mbPredLCmb`} {Nothing}: MbPredL ]

SEM Impls
  | Tail            lhs     .   mbPredL         =   Just []

SEM Pred
  | *               lhs     .   mbPredL         =   Just [@repl]

ATTR TyAGItf AllTyAndFlds [ | | isReplaced USE {||} {False}: Bool ]

SEM Ty
  | App             loc     .   isReplaced      =   isJust @mbReplNoImplNil || isJust @mbRepl
  | Con Ext         loc     .   isReplaced      =   isJust @mbRepl
  | Ann             loc     .   isReplaced      =   True
--  | Lam             loc     .   isReplaced      =   isJust @mbRepl

SEM Ty
  | App             lhs     .   isReplaced      =   @isReplaced || @func.isReplaced || @arg.isReplaced
  | Ext             lhs     .   isReplaced      =   @isReplaced || @ty.isReplaced || @extTy.isReplaced
--  | Lam             lhs     .   isReplaced      =   @isReplaced || @ty.isReplaced

-- If implicits, remove them, otherwise reconstruct the App
SEM Ty
  | App             loc     .   mbReplNoImplNil =   let r = {- tyPred2DataTy -} @arg.repl
                                                    in  case @func.mbPredL of
                                                          Nothing | @func.isPred -> Just r
                                                          Just [] | @func.isPred -> Just r
                                                          _ -- | isJust @mbReplPred -> fmap (`mk1Arrow` r) @mbReplPred
                                                            | otherwise          -> Nothing

SEM Ty
  | Ext             loc     .   mbRepl          =   if @isSpineRoot
                                                    then let (row,exts) = tyRowExtsUnAnn $ tyRowExts @repl
                                                         in  if tyRowIsCanonOrdered exts
                                                             then Nothing
                                                             else Just $ mkDfltTyCanonicOut $ mkTyRow row $ tyRowCanonOrder exts
                                                    else Nothing

SEM Ty
  | App             loc     .   mbRepl          =   if @isSpineRoot
                                                    then tcoTyBetaRedFullMb @lhs.opts @replNoImplNil
                                                    else Nothing
  | Con             loc     .   mbRepl          =   tcoTyBetaRedFullMb @lhs.opts @repl
--  | Lam             loc		.	mbRepl		    =   fmap mkDfltTyBetaRedOut $ tyLamEtaRed @repl

ATTR Ty [ | | appArgReplL: {[Ty]} ]

SEM Ty
  | App             loc     .   appArgReplL     =   @arg.repl : @func.appArgReplL
  | * - App Ann     lhs     .   appArgReplL     =   []

ATTR AllTyAndFlds [ | | repl: SELF ]
ATTR TyAGItf  [ | | repl: Ty ]

SEM Ty
  | App             loc     .   replNoImplNil   =   maybe @repl id @mbReplNoImplNil
                    lhs     .   repl            =   @replNoImplNil
  | Ann             lhs     .   repl            =   @ty.repl

SEM Ty
  | Ext             lhs     .   repl            =   maybe @repl tbroutRes @mbRepl

{
extr :: TyCanonicOut -> (Ty,VarMp)
extr o = (tbroutRes o, tbroutVarMp o)

}
SEM Ty
  | App             (lhs.repl,loc.replVarMp)    :=  maybe (@replNoImplNil,emptyVarMp) extr @mbRepl
  | Con             (lhs.repl,loc.replVarMp)    =   maybe (@repl,emptyVarMp) extr @mbRepl
--  | Lam             (lhs.repl,loc.replVarMp)    =   maybe (@repl,emptyVarMp) extr @mbRepl

