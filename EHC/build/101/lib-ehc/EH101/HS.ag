MODULE {EH101.HS} {module UU.Scanner.Position
, AGItf (..), Module (..), Body (..), Declaration (..), Declarations, MaybeDeclarations, Type (..), Types, MaybeType, Expression (..), Expressions, MaybeExpression, FunctionBinding (..), FunctionBindings, LeftHandSide (..), RightHandSide (..), Pattern (..), Patterns, Literal (..), Name, Names, MaybeName, MaybeNames, Strings, Range (..), Fixity (..)
, TypeAnnotation (..), ExpressionAnnotation (..), PatternAnnotation (..)
, mkRngNm, mkRngNm', mkRngStr
, TypeLeftHandSide (..), TypePattern (..), TypePatterns
, Constructor (..), Constructors
, GuardedExpression (..), GuardedExpressions, Alternative (..), Alternatives, Qualifier (..), Qualifiers
, Kind (..), Kinds, KindAnnotation (..)
, FieldDeclaration (..), FieldDeclarations
, RecordPatternBinding (..), RecordPatternBindings
, RecordExpressionBinding (..), RecordExpressionBindings
, RowRecordExpressionUpdate (..), RowRecordExpressionUpdates, RowRecordPatternBinding (..), RowRecordPatternBindings, RowTypeUpdate (..), RowTypeUpdates
, module EH101.Base.Target
, ContextItem (..), ContextItems
, Statement (..), Statements
, ContextedExpression (..), ContextedExpressions, ContextedPattern (..), ContextedPatterns
, FunctionalDependency (..), FunctionalDependencies
, Export (..), Exports, MaybeExports, ImportDeclaration (..), ImportDeclarations, ImportSpecification (..), MaybeImportSpecification, Import (..), Imports
, Deriving (..), Derivings
, Pragma (..), Pragmas}
{
import EH101.Base.Common
import UU.Scanner.Position
import EH.Util.ScanUtils
import EH101.Scanner.Token
import EH101.Base.Target (FFIWay)

}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "HS/AbsSyn.ag"
{
type Name = HsName
type Names = [Name]
type MaybeName = Maybe Name
type MaybeNames = Maybe Names

}
{
}
{
mkRngNm' :: (Position t,HSNM t) => (Range -> HsName -> r) -> t -> (r,Range)
mkRngNm' ast t
  = (ast r (mkHNm t),r)
  where r = mkRange1 t

mkRngNm :: (Position t,HSNM t) => (Range -> HsName -> r) -> t -> r
mkRngNm ast t = fst (mkRngNm' ast t)

mkRngStr :: (Range -> String -> r) -> Token -> r
mkRngStr ast t = ast (mkRange1 t) (tokMkStr t)

}
{
}
{
instance SemApp Type where
  semApp        = \e1 e2 -> Type_NormalApplication emptyRange e1 [e2]
  semAppTop     = id
  semCon        = mkRngNm Type_Constructor
  semParens     = Type_Parenthesized emptyRange
  mkApp (a:as)  = if null as then a else Type_NormalApplication emptyRange a as
  semRngCon r n = Type_Constructor r (mkHNm n)
}
{
  semRngVar r n = Type_Variable r (mkHNm n)

}
{
instance SemApp Expression where
  semApp            = \e1 e2 -> Expression_NormalApplication emptyRange e1 [e2]
  semAppTop         = id
  semCon            = mkRngNm Expression_Constructor
  semParens         = Expression_Parenthesized emptyRange
  mkApp (a:as)      = if null as then a else Expression_NormalApplication emptyRange a as
  semRngCon r n     = Expression_Constructor r (mkHNm n)
  semRngVar r n     = Expression_Variable r (mkHNm n)

}
