MODULE {EH101.GrinCode.Trf.EvalElim} {grEvalElim}
{
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import EH101.Base.Builtin
import EH101.Base.Target
import EH101.Base.Common
import EH101.Opts
import EH101.GrinCode.Common
import EH101.GrinCode
import qualified EH101.Config as Cfg
import EH.Util.Pretty
import EH.Util.Utils
import EH101.Base.Debug

}
INCLUDE "GrinCode/AbsSyn.ag"
{
}
{
}
{
}
{
}
INCLUDE "GrinCode/Trf/CommonAliasAG.ag"
INCLUDE "GrinCode/Trf/CommonFreeVar.ag"
INCLUDE "GrinCode/Trf/CommonWillEval.ag"
{
}
{
}
{
grEvalElim :: EHCOpts -> GrModule -> GrModule
grEvalElim opts grmod
  = trf_Syn_GrAGItf t
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ (Inh_GrAGItf
                 { opts_Inh_GrAGItf = opts
                 })

}
WRAPPER GrAGItf

{
optsAllowNodePtrMix :: EHCOpts -> Bool
optsAllowNodePtrMix opts = targetIsGrinBytecode (ehcOptTarget opts)

}
ATTR GrAGItf GrModule AllDef AllGrExpr AllGrVal AllGrPat [ opts: EHCOpts | | ]

{
data IsEval
  = IsEval_EvalToNode                       -- eval to node
  | IsEval_EvalToNodeNm !HsName             -- eval to node, but under different name
  | IsEval_EvalToPointer
  | IsEval_Apply        !HsName !GrValL     -- eval to apply, reconstruct with name and argument values
  | IsEval_None
  deriving Eq

isEvalEvaluated :: EHCOpts -> IsEval -> Bool
isEvalEvaluated opts IsEval_None          = False
isEvalEvaluated opts IsEval_EvalToPointer = optsAllowNodePtrMix opts
isEvalEvaluated opts _                    = True

type IsEvalMp = Map.Map HsName IsEval -- (IsEval,HsName)

isEvalNm :: IsEval -> HsName -> HsName
isEvalNm (IsEval_EvalToNodeNm n) _ = n
isEvalNm _                       n = n

}
{
instance Show IsEval where
  show IsEval_EvalToNode        = "IsEval_EvalToNode"
  show (IsEval_EvalToNodeNm n)  = "IsEval_EvalToNodeNm" ++ show n
  show IsEval_EvalToPointer     = "IsEval_EvalToPointer"
  show IsEval_None              = "IsEval_None"
  show (IsEval_Apply f _)       = "IsEval_Apply " ++ show f

}
ATTR AllExpr [ isEvalMp: IsEvalMp | | ]

SEM GrExpr
  | Seq         -- loc         .   isEvalMp        =   Map.unions [@expr.gathIsEvalMp,@lhs.isEvalMp]
                body        .   isEvalMp        =   -- trace ("pat=" ++ show @pat.trf ++ " alias=" ++ show @pat.nmAlias ++ " isEval: " ++ show @expr.isEval) $
                                                    let mp = Map.unions [@expr.gathIsEvalMp,@lhs.isEvalMp] -- @isEvalMp
                                                    in  case @pat.nmAlias of
                                                          NmAlias_Nm nmp | isJust @expr.mbMkPatSeq && isEvalEvaluated @lhs.opts @expr.isEval
                                                            -> Map.insert nmp @expr.isEval mp
                                                          _ -> mp `Map.difference` Map.fromList (zip @pat.introNmL @pat.introNmL)

SEM GrBind
  | Bind        expr        .   isEvalMp        =   Map.empty

SEM GrGlobal
  | Global      val         .   isEvalMp        =   Map.empty

SEM GrAlt
  | Alt         expr        .   isEvalMp        =   @lhs.isEvalMp `Map.difference` Map.fromList (zip @pat.introNmL @pat.introNmL)

ATTR GrExpr GrVal [ | | gathIsEvalMp USE {`Map.union`} {Map.empty} : IsEvalMp ]

SEM GrExpr
  | Eval App    loc         .   newDelIsEvalMp  =   Map.unions [Map.fromList @delayedIsEvals, @delayedIsEvalMp]

SEM GrExpr
  | Eval        lhs         .   gathIsEvalMp    =   Map.unions [maybe Map.empty (\n -> Map.singleton @nm (IsEval_EvalToNodeNm n)) @lhs.mbIntroNm, @newDelIsEvalMp]
  | App         lhs         .   gathIsEvalMp    =   @newDelIsEvalMp

ATTR GrExpr GrVal [ | | isEval: IsEval ]

SEM GrExpr
  | Call Eval
                lhs         .   isEval          =   IsEval_EvalToNode
  | App         lhs         .   isEval          =   case @appTrf of
                                                      GrExpr_App f as -> IsEval_Apply f as
  | * - Call Eval App FFI
        Store Unit
                lhs         .   isEval          =   IsEval_None

SEM GrVal
  | LitInt      lhs         .   isEval          =   IsEval_EvalToPointer
  | Var         lhs         .   isEval          =   maybe IsEval_None
                                                          id
                                                          (Map.lookup @nm @lhs.isEvalMp)
  | * - Node LitInt Var
                lhs         .   isEval          =   IsEval_None

SEM GrExpr
  | FFI         lhs         .   isEval          =   if grFFIAnnotIsResEvaluated @ffiAnnot then IsEval_EvalToNode else IsEval_None

{
type MkSeq    = GrExpr -> GrExpr
type MkPatSeq = GrPatLam -> MkSeq

emptyMkPatSeq :: MkPatSeq
emptyMkPatSeq _ e = e

mkPatSeq :: GrExpr -> MkPatSeq
mkPatSeq = GrExpr_Seq

mkMbPatSeq :: GrExpr -> Maybe MkPatSeq
mkMbPatSeq = Just . mkPatSeq

mkSeq :: HsName -> GrExpr -> MkSeq
mkSeq n e = mkPatSeq e (GrPatLam_Var n)

}
ATTR GrExpr [ | | mbMkPatSeq: {Maybe MkPatSeq} ]

SEM GrExpr
  | * - Store Unit
                lhs         .   mbMkPatSeq      =   mkMbPatSeq @trfNew
  | Store Unit  lhs         .   mbMkPatSeq      =   maybeOr (mkMbPatSeq @trf) (mkMbPatSeq) (const Nothing) @val.mbGrExpr @val.mbDelayedExpr

ATTR GrExpr [ mbIntroNm: {Maybe HsName} | | ]

SEM GrExpr
  | Seq         loc         .   mbIntroNm       =   case @pat.nmAlias of
                                                      NmAlias_Nm nmp -> Just nmp
                                                      _              -> Nothing
                body        .   mbIntroNm       =   Nothing

SEM GrAlt
  | Alt         expr        .   mbIntroNm       =   Nothing

SEM GrBind
  | Bind        expr        .   mbIntroNm       =   Nothing

ATTR GrExpr [ fviMp: FvInfoMp | | ]

SEM GrExpr
  | Seq         expr        .   fviMp           =   @gathBodyFviMp

SEM GrAlt
  | Alt         expr        .   fviMp           =   @expr.gathFviMp

SEM GrBind
  | Bind        expr        .   fviMp           =   @expr.gathFviMp


{
type Delayed x = (x,IsEval,IsEvalMp)
type DelayedExpr = Delayed GrExpr
type DelayedEval = Delayed MkSeq
type DelayedEvalMp = Map.Map HsName DelayedEval

del2del :: (x -> y) -> Delayed x -> Delayed y
del2del f (x,i,m) = (f x,i,m)

}
ATTR GrExpr AllAlt [ | delayedEvalMp: DelayedEvalMp | ]

SEM GrBind
  | Bind        expr        .   delayedEvalMp   =   Map.empty

SEM GrExpr
  | Seq         body        .   delayedEvalMp   =   Map.unions [maybeAnd Map.empty (\n e -> Map.singleton n (del2del (mkSeq n) e)) @mbIntroNm @expr.mbDelayedExpr, @expr.delayedEvalMp]
  | App Eval    (loc.delayedMkSeq,lhs.delayedEvalMp,loc.delayedIsEvals,loc.delayedIsEvalMp)
                                                =   let (here,furtheron) = Map.partitionWithKey (\n _ -> willUseForEval n @willUseForMp) @lhs.delayedEvalMp
                                                        (evals,isevals,isevalmps) = unzip3 [ (e,(n,ie),iem) | (n,(e,ie,iem)) <- Map.toList here ]
                                                    in  (foldr (.) id evals,furtheron,isevals,Map.unions isevalmps)

ATTR GrExpr [ | | alsoWillUseForMp: WillUseForMp ]

SEM GrExpr
  | Call App    lhs         .   alsoWillUseForMp=   Map.map (const $ Set.singleton WillUseFor_NodeField) @argL.gathFviMp
  | Store Unit  lhs         .   alsoWillUseForMp=   Map.map (const $ Set.singleton WillUseFor_NodeField) @gathFviMp
  | * - Call App Store Unit
                lhs         .   alsoWillUseForMp=   Map.empty

SEM GrExpr
  | Seq         lhs         .   willUseForMp    =   @willUseForMp `willUseUnion` @expr.alsoWillUseForMp `willUseUnion` @body.alsoWillUseForMp

SEM GrBind
  | Bind        expr        .   willUseFor      =   Set.empty
                expr        .   gathFviMp       <   expr.willUseFor

ATTR GrAGItf [ | | trf: GrModule ]
ATTR AllNT [ | | trf: SELF ]

ATTR GrVal [ | | mbGrExpr: {Maybe GrExpr} ]
ATTR GrExpr GrVal [ | | mbDelayedExpr: {Maybe DelayedExpr} ]

SEM GrVal
  | Node        loc         .   willOnlyUseForEval
                                                =   WillUseFor_Eval `Set.member` @lhs.willUseFor && not (WillUseFor_NodeField `Set.member` @lhs.willUseFor)
                (loc.mbGrExpr,lhs.isEval,lhs.gathIsEvalMp,loc.mbDelayedExpr)
                                                =   case (@tag.trf,@fldL.trf) of
                                                      (GrTag_Fun nm,_)
                                                        | @willOnlyUseForEval                  -- a to be evaluated saturated call closure -> immediate call
                                                        -> (Nothing, IsEval_None, Map.empty, Just (repl, IsEval_EvalToNode, Map.empty))
                                                        where repl = GrExpr_Call nm @fldL.trf
                                                      (GrTag_App _,(GrVal_Var f:fs))
                                                        | @willOnlyUseForEval      -- a to be evaluated apply closure -> immediate apply
                                                        -> ( Nothing
                                                           , IsEval_None
                                                           , Map.empty
                                                           , Just (repl,IsEval_Apply fRepl fs,Map.singleton f (IsEval_EvalToNodeNm f'))
                                                           )
                                                        where f' = hsnUniqifyEval f
                                                              fRepl = f' -- if optsAllowNodePtrMix @lhs.opts then f' else f
                                                              repl = GrExpr_Seq (GrExpr_Eval f) (GrPatLam_Var f') (GrExpr_App fRepl fs)
                                                      (GrTag_Con _ _ _,_)                               -- constructor node is evaluated
                                                        -> (Nothing, IsEval_EvalToPointer, Map.empty, Nothing)
                                                      (GrTag_Rec ,_)                                    -- record as well
                                                        -> (Nothing, IsEval_EvalToPointer, Map.empty, Nothing)
                                                      (GrTag_PApp nMiss nm,_)                           -- partial app also, cannot be evaluated further, unless 0 missing
                                                        | @willOnlyUseForEval && nMiss == 0
                                                          -> (Nothing, IsEval_None, Map.empty, Just (GrExpr_Call nm @fldL.trf, IsEval_EvalToNode, Map.empty))
                                                        | otherwise
                                                          -> (Nothing, IsEval_EvalToPointer, Map.empty, Nothing)
                                                      (t,_)
                                                        -> (Nothing, IsEval_None, Map.empty, Nothing)
  | * - Node    loc         .   mbDelayedExpr   =   Nothing
                            .   mbGrExpr        =   Nothing

SEM GrExpr
  | * - Store Unit
                loc         .   mbDelayedExpr   =   Nothing

SEM GrExpr
  | Eval        loc         .   trfNew          =   let a = Map.lookup @nm $ Map.union @newDelIsEvalMp @lhs.isEvalMp
                                                    in  -- trace ("isEval: " ++ show @nm ++ " = " ++ show a) $
                                                        @delayedMkSeq $
                                                        case a of
                                                          Just e | isEvalEvaluated @lhs.opts e
                                                            -> GrExpr_Unit (GrVal_Var $ isEvalNm e @nm) GrType_None
                                                          _ -> @trf
  | App         loc         .   appTrf          =   case Map.lookup @nm $ Map.union @newDelIsEvalMp @lhs.isEvalMp of
                                                      Just (IsEval_Apply f as) | not $ @nm `Map.member` @lhs.fviMp
                                                        -> GrExpr_App f (as ++ @argL.trf)
                                                      _ -> @trf
                            .   trfNew          =   @delayedMkSeq @appTrf
                loc         .   appTrf          :   GrExpr
  | Seq         loc         .   trfNew          =   {- @delayedMkSeq $ -} maybe (id) (\mk -> mk @pat.trf) @expr.mbMkPatSeq $ @body.trf
  | * - Store Unit Eval App Seq
                loc         .   trfNew          =   @trf

SEM GrExpr
  | * - Store Unit
                lhs         .   trf             =   @trfNew

