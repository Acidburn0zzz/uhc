MODULE {EH101.GrinCode.Trf.FlattenSeq} {grFlattenSeq}
{
import qualified Data.Map as Map
import qualified EH.Util.FastSeq as FastSeq
import EH101.Base.Common
import EH101.GrinCode.Common
import EH101.GrinCode

}
{
}
INCLUDE "GrinCode/AbsSyn.ag"
{
}
{
}
WRAPPER GrAGItf

{
grFlattenSeq :: GrModule -> GrModule
grFlattenSeq grmod
  = trf_Syn_GrAGItf t
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf

}
-- synthesize a modified copy
ATTR GrAGItf [ | | trf: GrModule ]
ATTR AllNT   [ | | trf: SELF     ]

-- split each expression in a sequence of (Expr,Pat) pairs, and the last expression

ATTR GrExpr  [ | | trfPairs: {FastSeq.FastSeq (GrExpr,GrPatLam)}
                   trfLast:  GrExpr                          ]

SEM GrExpr
  | Seq         lhs.trfPairs  =  @expr.trfPairs
                                 FastSeq.:++: FastSeq.singleton (@expr.trfLast,@pat.trf)
                                 FastSeq.:++: @body.trfPairs
  | * - Seq     lhs.trfPairs  =  FastSeq.empty

SEM GrExpr
  | Seq         lhs.trfLast   =  @body.trfLast
  | * - Seq     lhs.trfLast   =  @trf

-- then from the sequence, rebuild the tree in a right-associative way

SEM GrExpr
  | Seq         lhs.trf       =  foldr (\(e,p) b -> GrExpr_Seq e p b)
                                       (GrExpr_Seq @expr.trfLast @pat.trf @body.trf)
                                       (FastSeq.toList @expr.trfPairs)
