MODULE {EH101.GrinCode.Trf.AliasElim} {grAliasElim}
{
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.GrinCode.Common
import EH101.GrinCode
import qualified EH101.Config as Cfg
import EH101.Foreign.Extract

}
INCLUDE "GrinCode/AbsSyn.ag"
{
}
{
}
{
}
{
}
{
}
INCLUDE "GrinCode/Trf/CommonAliasAG.ag"
INCLUDE "GrinCode/CommonForGen.ag"
INCLUDE "GrinCode/Trf/CommonRenameAG.ag"
{
grAliasElim :: GrModule -> GrModule
grAliasElim grmod
  = trf_Syn_GrAGItf t
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf

}
WRAPPER GrAGItf

PRAGMA nocycle

SEM GrAGItf
  | AGItf		loc			.	mkNewNm			=	id

SEM GrExpr
  | Seq         body        .   nmAliasMp       =   @newNmAliasMp `Map.union` @lhs.nmAliasMp

ATTR GrAGItf [ | | trf: GrModule ]

{
nmAliasOne :: NmAliasMp -> NmAlias -> NmAlias -> (GrExpr->GrExpr,NmAliasMp)
nmAliasOne mpGlob e p
  = case (e,p) of
      (NmAlias_Nm ne, NmAlias_Nm np)
        -> (id,Map.singleton np $ nmAliasRepl' mpGlob ne)
      (NmAlias_Const _ c, NmAlias_Nm np)
        -> (GrExpr_Seq (GrExpr_Unit c GrType_None) (GrPatLam_Var np),Map.empty)
      _ -> (id,Map.empty)

nmAliasGrp :: NmAliasMp -> [NmAlias] -> [NmAlias] -> (GrExpr->GrExpr,NmAliasMp)
nmAliasGrp mpGlob eAliL pAliL
  = (foldr (.) id mkel, Map.unions mpl)
  where (mkel,mpl) = unzip $ zipWith (nmAliasOne mpGlob) eAliL pAliL

}
SEM GrExpr
  | Seq         loc         .   (seqTrf,mkExtraSeq,newNmAliasMp)
                                                =   case (@expr.nmAlias,@pat.nmAlias,@body.nmAlias) of
                                                      (_,NmAlias_Nm p,NmAlias_Nm b) | p == b						-- last unit in body yields p, without intermediate computation, may well remove it. See note at begin.
                                                        -> (@expr.trf,id,Map.empty)
                                                      {-
                                                      (NmAlias_Eval e,pp@(NmAlias_Nm p),_)							-- allow reference to evaluated value instead
                                                        -> (@trf,id,Map.singleton e pp)
                                                      -}
                                                      -- (c@(NmAlias_Const _ _),pp@(NmAlias_Nm p),_)					-- allow reference to constant instead
                                                      --   -> (@trf,id,Map.singleton p c)
                                                      (e@(NmAlias_Nm _),p@(NmAlias_Nm _),_)							-- p is alias for e, map p to e
                                                        -> (@body.trf,mke,mp)
                                                        where (mke,mp) = nmAliasOne @lhs.nmAliasMp e p
                                                      (NmAlias_Grp _ es,NmAlias_Grp _ ps,_)							-- node is directly matched -> fields are aliases
                                                        -> (@body.trf,mke,mp)
                                                        where (mke,mp) = nmAliasGrp @lhs.nmAliasMp es ps
                                                      (e@(NmAlias_Grp _ _),NmAlias_Nm p,_)							-- this + next is equivalent to previous, but delayed
                                                        -> (@trf,id,Map.singleton p (e {naliNm = p}))
                                                      (NmAlias_Nm e,NmAlias_Grp _ ps,_) | isJust mbAli				-- name mapping to structure, accessing fields
                                                        -> case mbAli of
                                                             Just (NmAlias_Grp _ es)
                                                               -> (@body.trf,mke,mp)
                                                               where (mke,mp) = nmAliasGrp @lhs.nmAliasMp es ps
                                                             _ -> (@trf,id,Map.empty)
                                                        where mbAli = Map.lookup e @lhs.nmAliasMp
                                                      (NmAlias_Nm e,NmAlias_Basic _ p ann,_) | isJust mbAli			-- name mapping to structure holding single basic value, accessing the field
                                                        -> case mbAli of
                                                             Just (NmAlias_Grp _ [e])
                                                               -> (@body.trf,mke,mp)
                                                               where (mke,mp) = nmAliasOne @lhs.nmAliasMp e p
                                                             _ -> (@trf,id,Map.empty)
                                                        where mbAli = Map.lookup e @lhs.nmAliasMp
                                                      _ -> (@trf,id,Map.empty)
                lhs         .   trf             =   @mkExtraSeq @seqTrf
