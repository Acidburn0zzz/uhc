MODULE {EH101.GrinCode.Trf.Inline} {grInline}
{
import qualified EH.Util.FastSeq as Seq
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.GrinCode.Common
import EH101.GrinCode
import EH.Util.Pretty
import EH.Util.Utils
import EH101.GrinCode.Trf.AliasRename
import qualified EH101.Config as Cfg
import EH.Util.Pretty
import EH.Util.Utils
import EH101.Base.Debug
import EH101.GrinCode.FreeVars

}
INCLUDE "GrinCode/AbsSyn.ag"
{
}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "GrinCode/Trf/CommonAliasAG.ag"
INCLUDE "GrinCode/Trf/CommonFreeVar.ag"
INCLUDE "GrinCode/Trf/CommonWillEval.ag"
{
}
{
}
WRAPPER GrAGItf

{
grInline :: Bool -> HsNameS -> GrInlMp -> GrModule -> (GrModule,GrInlMp)
grInline allow expNmS inlMp grmod
  = (trf_Syn_GrAGItf t,gathInlMp_Syn_GrAGItf t)
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf
                { expNmS_Inh_GrAGItf = expNmS
                , inlMp_Inh_GrAGItf = inlMp
                , allowOmitBind_Inh_GrAGItf = allow
                }

}
PRAGMA nocycle

ATTR GrAGItf GrModule AllBind [ expNmS: HsNameS | | ]

ATTR AllBind [ | | introNmS USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]

SEM GrBind
  | Bind        lhs         .   introNmS        =   Set.singleton @nm

ATTR AllBind [ fviMp: FvInfoMp | | ]

SEM GrModule
  | Mod         bindL       .   fviMp           =   @bindL.gathFviMp

SEM GrBind
  | Bind        expr        .   willUseFor      =   Set.empty

ATTR GrAGItf GrModule AllBind [ allowOmitBind : {Bool} | | ]

ATTR AllBind [ | | gathInlMp USE {`Map.union`} {Map.empty}: GrInlMp ]
ATTR AllGrExpr AllBind [ inlMp: GrInlMp | | ]

SEM GrBind
  | Bind        (lhs.gathInlMp,loc.omitBind)    =   case Map.lookup @nm @lhs.fviMp of
                                                      -- a once used function can be inlined and its binding removed
                                                      Just (FvInfo 1 use)
                                                        | not @isCAF
                                                          && FvUse_Call `Set.member` use
                                                          && not (@nm `Set.member` @lhs.expNmS)         -- only inline if not exported as global value
                                                          -> (Map.singleton @nm (GrInl_Call @argNmL @expr.trf), True)
                                                      Just (FvInfo 1 use)                               -- a once used, evaluated value can be inlined and its binding removed
                                                        | @isCAF
                                                          && willUseForEval @nm @expr.willUseForMp
                                                          && FvUse_Val `Set.member` use
                                                          && not (@nm `Set.member` @lhs.expNmS)         -- only inline if not exported as global value
                                                          -> (Map.singleton @nm (GrInl_CAF @expr.trf), True)
                                                      _ | not @isCAF
                                                          && (  @expr.isFFIWrapper                  -- wrappers are inlined
                                                             || @expr.isConWrapper
                                                             || @expr.inlineCost <= 10              -- and low cost values as well
                                                             )
                                                          -> (Map.singleton @nm (GrInl_Call @argNmL @expr.trf), False)
                                                        | otherwise
                                                          -> (Map.empty, False)
  | Rec         lhs         .   gathInlMp       =   Map.empty

ATTR GrExpr [ | | isFFIWrapper USE {||} {False}: Bool ]

SEM GrExpr
  | FFI         lhs         .   isFFIWrapper    =   True

ATTR GrExpr [ | | isConWrapper: Bool ]

SEM GrExpr
  | Unit         lhs        .   isConWrapper    =   True
  | * - Unit     lhs        .   isConWrapper    =   False

ATTR AllGrExpr [ | | inlineCost USE {+} {1}: Int ]

{
inlMayExport :: HsNameS -> HsNameS -> HsName -> GrInl -> Bool
inlMayExport onlyInThisModule expNmS n inl
  = case inl of
      GrInl_Call _ e
        -> n `Set.member` expNmS
           && Set.null (onlyInThisModule `Set.intersection` Map.keysSet (grFreeVars e))
      _ -> False

}
ATTR GrAGItf GrModule [ inlMp: GrInlMp | | gathInlMp: GrInlMp ]

SEM GrModule
  | Mod         bindL       .   inlMp           =   @bindL.gathInlMp `Map.union` @lhs.inlMp
                lhs         .   gathInlMp       =   let onlyInThisModule = @bindL.introNmS `Set.difference` @lhs.expNmS
                                                    in  Map.filterWithKey (inlMayExport onlyInThisModule @lhs.expNmS) @bindL.gathInlMp

ATTR AllGrExpr AllBind [ | | gathInlNmS USE {`Set.union`} {Set.empty}: FvS ]
ATTR AllBind [ inlNmS: FvS | | ]

SEM GrModule
  | Mod         loc         .   inlNmS          =   @bindL.gathInlNmS

ATTR AllGrVal [ | | asNmL USE {++} {[]}: {[Maybe HsName]} ]

SEM GrVal
  | Var         lhs         .   asNmL           =   [Just @nm]
  | * - Var     lhs         .   asNmL           =   [Nothing]

-- TODO: How to handle NodeAdapt?

ATTR AllGrExpr [ isCAF: Bool | | ]

SEM GrBind
  | Bind        loc         .   isCAF           =   null @argNmL

ATTR AllGrExpr AllBind [ | uniq: Int | ]

SEM GrExpr
  | Call		lhs			.	uniq			=	@lhs.uniq+1

SEM GrModule
  | Mod         loc         .   uniq            =   0

ATTR GrAGItf [ | | trf: GrModule ]
ATTR AllNT [ | | trf: SELF ]

{
inlGrVar :: GrInlMp -> [HsName] -> (GrExpr -> GrExpr,FvS)
inlGrVar inlMp nmL
  = (foldr (.) id mks,Set.unions inls)
  where inl nm = case Map.lookup nm inlMp of
                   Just (GrInl_CAF e) -> (GrExpr_Seq e (GrPatLam_Var nm),Set.singleton nm)
                   _ -> (id,Set.empty)
        (mks,inls) = unzip $ map inl nmL

inlNmsAreInlineable :: [Maybe HsName] -> Bool
inlNmsAreInlineable = and . map isJust

inlRename :: Int -> [Maybe HsName] -> [HsName] -> GrExpr -> GrExpr
inlRename uniq asFrom as e
  = grAliasRename (Just $ (hsnUniqifyInt HsNameUniqifier_Inline uniq)) (mkNmAliasMp $ zip as (map fromJust asFrom)) e

}
SEM GrExpr
  | Call        loc         .   (grVarTrf,grVarInlNmS)
                                                =   if @lhs.isCAF
                                                    then inlGrVar @lhs.inlMp (Map.keys @argL.gathFviMp)
                                                    else (id,Set.empty)

SEM GrExpr
  | Call        (lhs.trf,loc.gathInlNmS)        =   case Map.lookup @nm @lhs.inlMp of
                                                      Just (GrInl_Call as e) | inlNmsAreInlineable @argL.asNmL
                                                        -> ( @grVarTrf $ inlRename @lhs.uniq @argL.asNmL as e
                                                           , Set.insert @nm @grVarInlNmS
                                                           )
                                                      _ -> (@grVarTrf @trf, @grVarInlNmS)
  | App         (lhs.trf,loc.gathInlNmS)        =   if @lhs.isCAF
                                                    then let (grVarTrf,grVarInlNmS) = inlGrVar @lhs.inlMp (@nm : Map.keys @argL.gathFviMp)
                                                         in  (grVarTrf @trf, grVarInlNmS)
                                                    else (@trf, Set.empty)
  | Eval        (lhs.trf,loc.gathInlNmS)        =   case Map.lookup @nm @lhs.inlMp of
                                                      Just (GrInl_CAF e) | @lhs.isCAF
                                                        -> (e, Set.singleton @nm)
                                                      _ -> (@trf, Set.empty)

ATTR AllBind [ | | trfSq USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq GrBind} ]

SEM GrModule
  | Mod         lhs         .   trf             =   GrModule_Mod @moduleNm @globalL.trf (Seq.toList @bindL.trfSq) @tagsMp

SEM GrBind
  | Bind        lhs         .   trfSq           =   if @lhs.allowOmitBind && @loc.omitBind && @nm `Set.member` @lhs.inlNmS
                                                    then Seq.empty
                                                    else Seq.singleton @trf
  | Rec         lhs         .   trfSq           =   Seq.singleton $ GrBind_Rec $ Seq.toList @bindL.trfSq
