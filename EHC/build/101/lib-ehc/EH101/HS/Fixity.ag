ATTR
  AllDeclaration
  Qualifier
  Statement
  AllModule AGItf
    [ | | gathFixityGam USE {`gamAddGam`} {emptyGam}: FixityGam ]

ATTR
  AllDeclaration AllExpression AllPattern AllType
  AGItf AllModule
  AllConstructor
    [ fixityGam: FixityGam | | ]

SEM Declaration
    | Fixity
        lhs             .   gathFixityGam   =   let p = maybe (fgiPrio defaultFixityGamInfo) id @priority
                                                    mk n = (n,FixityGamInfo p @fixity)
                                                in  assocLToGam $ map mk $ @oprefnames

SEM Body
    | Body
        declarations    .   fixityGam       =   @declarations.gathFixityGam `gamUnion` @lhs.fixityGam

SEM Expression
    | Let
        loc             .   fixityGam       =   @declarations.gathFixityGam `gamUnion` @lhs.fixityGam

SEM RightHandSide
    | Expression
      Guarded
        loc             .   fixityGam       =   @where.gathFixityGam `gamUnion` @lhs.fixityGam

SEM Qualifiers
    | Cons
        loc             .   fixityGam       =   @hd.gathFixityGam `gamUnion` @lhs.fixityGam

SEM Statements
    | Cons
        loc             .   fixityGam       =   @hd.gathFixityGam `gamUnion` @lhs.fixityGam

ATTR
  Expression
  Type
    [ | | operatorName: MaybeName ]

SEM
  Expression
  Type
    | Variable Constructor
        lhs         .   operatorName    =   Just @refname
    | * - Variable Constructor
        lhs         .   operatorName    =   Nothing

SEM
  Expression
  Type
    | InfixApplication
        loc         .   fgi             =   case @operator.operatorName of
                                              Just n
                                                -> fixityGamLookup n @lhs.fixityGam
                                              _ -> defaultFixityGamInfo


{
data OpChain leaf
  = OpChain_Op   leaf PP_Doc Fixity Int Range (OpChain leaf) (OpChain leaf)
  | OpChain_Leaf leaf

opChainReArrange :: OpChain e -> (OpChain e,[Err])
opChainReArrange opChain
  = case opChain of
      OpChain_Op op1 pp1 f1 p1 pos1 l1 r1
        -> case opChainReArrange r1 of
             (OpChain_Op op2 pp2 f2 p2 pos2 l2 r2,rerr)
               | p1  > p2 -> (lvariant,lerr)
               | p1  < p2 -> (rvariant,rerr)
               | p1 == p2 -> case (f1,f2,lvariant,rvariant) of
                               (Fixity_Infixr,Fixity_Infixr,_,r) -> (r,rerr)
                               (Fixity_Infixl,Fixity_Infixl,l,_) -> (l,lerr)
                               (Fixity_Infix ,_            ,l,_) -> (l,[rngLift pos2 Err_Fixity pp1 pp2] ++ lerr)
               where (lrearr,lerr) = opChainReArrange (OpChain_Op op1 pp1 f1 p1 pos1 l1 l2)
                     lvariant = OpChain_Op op2 pp2 f2 p2 pos2 lrearr r2
                     rvariant = OpChain_Op op1 pp1 f1 p1 pos1 l1 (OpChain_Op op2 pp2 f2 p2 pos2 l2 r2)
             (r1l@(OpChain_Leaf _),rerr) -> (OpChain_Op op1 pp1 f1 p1 pos1 l1 r1l,rerr)
      _ -> (opChain,[])

unOpChain :: SemApp e => OpChain e -> e
unOpChain opChain
  = un opChain
  where un ch
          = case ch of
              OpChain_Op op _ _ _ rng l r
                -> mkRngParApp rng [op,un l,un r]
              OpChain_Leaf leaf
                -> leaf

}
SEM Expression [ | | opChain: {OpChain EH.Expr} ]
    | InfixApplication
        lhs         .   opChain         =   OpChain_Op @operator.eh @operator.pp (fgiFixity @fgi) (fgiPrio @fgi) @range @leftExpression.opChain @rightExpression.opChain
    | * - InfixApplication
        lhs         .   opChain         =   OpChain_Leaf @eh

SEM Expression
    | InfixApplicationChainTop
        loc         .   (ehRearrOpChain,errRearr)
                                        =   opChainReArrange @expression.opChain
                    .   ehFromOpChain   =   unOpChain @ehRearrOpChain

SEM Type [ | | opChain: {OpChain EH.TyExpr} ]
    | InfixApplication
        lhs         .   opChain         =
                                            if @isPredOp
                                            then OpChain_Leaf @eh
                                            else
                                                 OpChain_Op @operator.eh @operator.pp (fgiFixity @fgi) (fgiPrio @fgi) @range @leftType.opChain @rightType.opChain
    | * - InfixApplication
        lhs         .   opChain         =   OpChain_Leaf @eh

SEM Type
    | InfixApplicationChainTop
        loc         .   (ehRearrOpChain,errRearr)
                                        =   opChainReArrange @type.opChain
                    .   ehFromOpChain   =   unOpChain @ehRearrOpChain

