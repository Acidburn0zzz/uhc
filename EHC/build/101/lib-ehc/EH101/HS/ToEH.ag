ATTR AGItf [ | | eh: {EH.AGItf} ]

SEM AGItf
    | AGItf
        lhs         .   eh          =   EH.AGItf_AGItf @module.eh

{
ehSection :: SemApp eh
  => UID -> Range
  -> RngLiftArg (HsName -> eh)
  -> RngLiftArg (HsName -> ehp)
  -> RngLiftArg (ehp -> eh -> eh)
  -> Maybe eh -> eh -> Maybe eh
  -> eh
ehSection uniq range semvar sempatvar semlam left op right
  = case (left,right) of
      -- (Just l ,Just r ) -> mkRngParApp range [op,l,r]
      (Nothing,Just r ) -> rngLift range semlam np (mkRngParApp range [op,ne,r])
      (Just l ,Nothing) -> mkRngParApp range [op,l]
      (Nothing,Nothing) -> op
  where n  = mkHNmHidden $ mkHNm ("x_" ++ show uniq)
        ne = rngLift range semvar n
        np = rngLift range sempatvar n

}
{
ehTupleConstructor
  :: SemApp eh
     => Range -> Int -> RngLiftArg (HsName -> eh) -> RngLiftArg (HsName -> ehp) -> RngLiftArg (ehp -> eh -> eh)
     -> ([ehp] -> eh -> eh) -> RngLiftArg (r -> eh) -> RngLiftArg (r -> Maybe HsName -> eh -> r) -> RngLiftArg r
     -> eh
ehTupleConstructor range arity semvar sempatvar semlam
        semtop semrecd semrecdext semrecdempty
  = foldr (rngLift range semlam) recd ps
  where ns     = take arity hsnLclSupply
        ps     = map (rngLift range sempatvar) ns
        recd   = mkt (map (rngLift range semvar) ns)
        mkt ns = semtop ps
                 $ rngLift range semrecd
                 $ foldl (\r e -> rngLift range semrecdext r Nothing e)
                         (rngLift range semrecdempty)
                         ns

}
ATTR Module [ | | eh: {EH.Expr} ]

ATTR Body [ | | eh: {EH.Expr} ]

SEM Body
    | Body
        lhs         .   eh          =   @mkSccLet (if @lhs.isMainMod then rngLift @range EH.Expr_Var hsnMain
                                                                     else rngLift @range EH.Expr_IConst 0
                                                  )

SEM Body
    | Body
        loc         .   ehMainDecl  =   rngLift @range EH.Decl_Val
                                            (rngLift @range EH.PatExpr_Var hsnMain)
                                            (mkRngParApp @range [rngLift @range EH.Expr_Var (@mainrefnames !! 2),rngLift @range EH.Expr_Var @mainrefname])
                    .   ehMainSig   =   rngLift @range EH.Decl_TySig
                                            hsnMain
                                            (mkRngParApp @range [rngLift @range EH.TyExpr_Con (@mainrefnames !! 1),rngLift @range EH.TyExpr_Wild])

ATTR MaybeDeclarations [ | | eh USE {`const`} {Nothing}: {Maybe [EH.Decl]} ]

ATTR Declarations [ | | eh USE {++} {[]}: {[EH.Decl]} ]

ATTR Declaration [ | | eh: {[EH.Decl]} ]

SEM MaybeDeclarations
    | Just
        lhs         .   eh          =   Just @just.eh

SEM Declaration
    | FunctionBindings
        lhs         .   eh          =   @bindings.eh
    | PatternBinding
        loc         .   eh          =   rngLift @range EH.Decl_Val @pattern.eh @righthandside.eh
        lhs         .   eh          =   [@eh]
    | TypeSignature
        loc         .   mkEHSig     =   \n -> rngLift @range EH.Decl_TySig n @type.eh
        lhs         .   eh          =   map @mkEHSig @refnames
    | Fixity
        lhs         .   eh          =   []
    | Empty
        lhs         .   eh          =   []
    | Data
      GADT
        loc         .   eh          =   rngLift @range EH.Decl_Data False @typerefname (map (rngLift @range EH.TyVar_Var) @typelefthandside.typevariables) @constructors.eh
                                                (if ehcOptGenGenerics @lhs.opts then Just @generMaxRemArity else Nothing)
        lhs         .   eh          =   [@eh]
    | Newtype
        loc         .   eh          =   rngLift @range EH.Decl_Data True @typerefname (map (rngLift @range EH.TyVar_Var) @typelefthandside.typevariables) [@constructors.eh]
                                                (if ehcOptGenGenerics @lhs.opts then Just @generMaxRemArity else Nothing)
        lhs         .   eh          =   [@eh]
    | Data Newtype GADT
        loc         .   ehGener     =   rngLift @range EH.Decl_GenerRep @generMaxRemArity @typerefname @constructors.conrefnames @constructors.conAndFldrefnames
    | FusionDeclaration
        loc         .   eh          =   rngLift @range EH.Decl_FusionDecl @reffusename
    | FusionConversion
        loc         .   eh          =   rngLift @range EH.Decl_FusionConv (@refnames !! 0) (@refnames !! 1)
    | FusionDeclaration FusionConversion
        lhs         .   eh          =   [@eh]
    | KindSignature
        loc         .   mkEHSig     =   \n -> rngLift @range EH.Decl_KiSig n @kind.eh
        lhs         .   eh          =   map @mkEHSig @refnames
    | ForeignImport
        loc         .   eh          =   rngLift @range EH.Decl_FFI @callconvention (maybe "safe" id @safety) @ent @refname @type.eh
        lhs         .   eh          =   [@eh]
    | Class
        loc         .   (eh,ehInst) =   let h = rngLift @range EH.TyExpr_Pred
                                                $ rngLift @range EH.PrExpr_Class @classrefname (map (rngLift @range EH.TyExpr_Var) @typelefthandside.typevariables)
                                            c = map (rngLift @range EH.TyExpr_Pred) @context.eh
                                            a = mkArrow c h
                                            (vals,sigs) = partition EH.ehIsDeclVal $ concat @ehReorderedDecls
                                        in  ( rngLift @range EH.Decl_Class a
                                                      @dependencies.eh
                                                      (Just @instancerefname) sigs
                                                      @generDerivInfoL
                                            , rngLift @range EH.Decl_Instance (Just (@instancerefname,False)) InstDefault a vals
                                            )
        lhs         .   eh          =   [@eh,@ehInst]
    | Instance
        loc         .   eh          =   let -- h = rngLift @range EH.TyExpr_Pred $ rngLift @range EH.PrExpr_Class @classrefname @types.eh
                                            h = rngLift @range EH.TyExpr_Pred $ panicJust "HS.ToEH.Instance.eh.type.ehMbAsPr" @type.ehMbAsPr
                                            c = map (rngLift @range EH.TyExpr_Pred) @context.eh
                                        in  rngLift @range EH.Decl_Instance (Just (@instancerefname,@useimplicitly)) @instVariant (mkArrow c h) (concat @ehReorderedDecls)
        lhs         .   eh          =   [@eh]
    | InstanceUseImplicitly
        loc         .   eh          =   let h = rngLift @range EH.PrExpr_Class @classrefname @types.eh
                                        in  rngLift @range EH.Decl_InstanceIntro (Just @instancerefname) @expression.eh h
        lhs         .   eh          =   [@eh]
    | Default
        loc         .	ignoredecl	=	null @classrefnames
                    .   eh          =   rngLift @range EH.Decl_Default @classrefname @types.eh
        lhs         .   eh          =   [@eh]
    | Type
        loc         .   eh          =   rngLift @range EH.Decl_Type @typerefname (foldr (rngLift @range EH.TyExpr_Lam) @type.eh @typelefthandside.typevariables)
        lhs         .   eh          =   [@eh]
    | ForeignExport
        loc         .   nmForParse 	=	maybe "" id @exportname
                    .   (ent,entErrs)
                                    =   parseForeignEnt ForeignDirection_Export @callconvention (Just $ show @name) @nmForParse
                    .   eh          =   rngLift @range EH.Decl_FFE @exportrefname @callconvention @ent (rngLift @range EH.Expr_Var @refname) @type.eh
        lhs         .   eh          =   [@eh]
    | Pragma Module
        loc         .   eh          =   undefined
        lhs         .   eh          =   []

ATTR FunctionalDependencies [ | | eh USE {:} {[]}: {[EH.FuncDep]} ]

ATTR FunctionalDependency [ | | eh: {EH.FuncDep} ]

SEM FunctionalDependency
    | Dependency
        lhs         .   eh          =   rngLift @range EH.FuncDep_Dep
                                          (map (rngLift @range EH.TyVar_Var) @fromtypevariables)
                                          (map (rngLift @range EH.TyVar_Var) @totypevariables)

ATTR AllDeriving [ ehDataTyExpr: {EH.TyExpr} | | ]

SEM Declaration
    | Data Newtype GADT
        derivings   .   ehDataTyExpr=   mkApp (rngLift @range EH.TyExpr_Con @typerefname : map (rngLift @range EH.TyExpr_Var) @typelefthandside.typevariables)

SEM Deriving
    | Deriving
        loc         .   eh          =   let h = rngLift @range EH.TyExpr_Pred
                                                $ rngLift @range EH.PrExpr_Class @refname [rngLift @range EH.TyExpr_Parens @lhs.ehDataTyExpr]
                                        in  rngLift @range EH.Decl_Instance (Just (@instancerefname,@useimplicitly)) (InstDeriving InstDerivingFrom_Datatype) h []

ATTR Kinds [ | | eh USE {:} {[]}: {[EH.KiExpr]} ]

ATTR Kind [ | | eh: {EH.KiExpr} ]

SEM Kind
    | NormalApplication
        lhs         .   eh          =   mkApp (@function.eh : @arguments.eh)
    | InfixApplication
        loc         .   eh          =   mkRngParApp @range [@operator.eh,@leftKind.eh,@rightKind.eh]
    | Constructor
        lhs         .   eh          =   rngLift @range EH.KiExpr_Con @refname
    | Parenthesized
        lhs         .   eh          =   rngLift @range EH.KiExpr_Parens @kind.eh
    | Variable
        lhs         .   eh          =   rngLift @range EH.KiExpr_Var @name
    | Forall
        lhs         .   eh          =   {- foldr (rngLift @range EH.KiExpr_Quant tyQu_Forall) -} @kind.eh {- @kindvariables -}
	| Annotate
		loc			.	eh			=	rngLift @range EH.KiExpr_Ann @annotation.eh @kind.eh

{
ehTyExprArg :: EH.TyExpr -> EH.TyExpr
ehTyExprArg = snd . panicJust "HS.ToEH.ehTyExprArg" . isApp1 . unTop

}
ATTR Types [ | | eh USE {:} {[]}: {[EH.TyExpr]} ]

ATTR Type [ | | eh: {EH.TyExpr} ]

ATTR MaybeType [ | | eh USE {`const`} {Nothing}: {Maybe EH.TyExpr} ]

SEM MaybeType
    | Just
        lhs         .   eh          =   Just @just.eh

SEM Type
    | NormalApplication
        loc         .   eh          =   mkApp (@function.eh : @arguments.eh)
    | InfixApplication
        loc         .   (eh,ctxtFormErrs,isPredOp)
                                    =   if not @lhs.isAsPred && @operator.tyConIs == TyConIsPrArrow
                                        then let t = foldr mk1Arrow @rightType.eh [ pr | (Just pr) <- @leftType.ehMbAsTyPrL ]
                                             in  if all isJust @leftType.ehMbAsTyPrL
                                                 then (t, []                                                  , True )
                                                 else (t, [rngLift @range Err_MalformedPred @leftType.pp]     , False)
                                        else (mkRngParApp @range [@operator.eh,@leftType.eh,@rightType.eh], [], False)
    | InfixApplicationChainTop
        loc         .   eh          =   @ehFromOpChain
    | SectionApplication
        loc         .   eh          =   ehSection
                                            @lUniq_1_nm @range
                                            EH.TyExpr_Var
                                            (rngAntilift id)
                                            EH.TyExpr_Lam
                                            @leftType.eh @operator.eh @rightType.eh
        loc         .   lUniq_1_nm  :   UNIQUEREF gUniq
    | Constructor
        loc         .   eh          =   rngLift @range EH.TyExpr_Con @refname
    | Parenthesized
        loc         .   eh          =   rngLift @range EH.TyExpr_Parens @type.eh
	| Annotate
		loc			.	eh			=	rngLift @range EH.TyExpr_Ann @annotation.eh @type.eh
    | Wildcard
        loc         .   eh          =   rngLift @range EH.TyExpr_Wild
    | MonoWildcard
        loc         .   eh          =   rngLift @range EH.TyExpr_Mono
    | Variable
        loc         .   eh          =   rngLift @range (if @lhs.doGenVarWild then EH.TyExpr_VarWild else EH.TyExpr_Var) @name
    | NamedWildcard
        loc         .   eh          =   rngLift @range EH.TyExpr_VarWild @name
    | Forall
        loc         .   eh          =   foldr (rngLift @range EH.TyExpr_Quant tyQu_Forall) @type.eh @typevariables
    | Exists
        loc         .   eh          =   foldr (rngLift @range EH.TyExpr_Quant tyQu_Exists) @type.eh @typevariables
    | RowUpdate
        loc         .   eh          =   foldl (flip ($)) @type.eh @rowTypeUpdates.eh
    | RowEmpty
        loc         .   eh          =   rngLift @range EH.TyExpr_Row (rngLift @range EH.RowTyExpr_Empty)
    | RowRecUpdate
        loc         .   eh          =   foldl (\e u -> mk1ConApp hsnRec $ u $ ehTyExprArg $ e) @type.eh @rowTypeUpdates.eh
    | RowRecEmpty
        loc         .   eh          =   mk1ConApp hsnRec $ rngLift @range EH.TyExpr_Row (rngLift @range EH.RowTyExpr_Empty)
    | RowSumUpdate
        loc         .   eh          =   foldl (\e u -> mk1ConApp hsnSum $ u $ ehTyExprArg $ e) @type.eh @rowTypeUpdates.eh
    | RowSumEmpty
        loc         .   eh          =   mk1ConApp hsnSum $ rngLift @range EH.TyExpr_Row (rngLift @range EH.RowTyExpr_Empty)
    | Qualified
        loc         .   eh          =   foldr mk1Arrow @type.eh @context.ehTy
    | TupleConstructor
        loc         .   eh          =   ehTupleConstructor @range @arity EH.TyExpr_Var (rngAntilift id)
                                            EH.TyExpr_Lam
                                            (\ps r -> {- mkArrow (map (rngLift @range EH.TyExpr_Var) ps) -} r)
                                            (rngAntilift $ \row -> mk1ConApp hsnRec (rngLift @range EH.TyExpr_Row row))
                                            EH.RowTyExpr_Ext EH.RowTyExpr_Empty

{
}
ATTR ContextItems [ | | eh USE {:} {[]}: {[EH.PrExpr]}  ehTy USE {:} {[]}: {[EH.TyExpr]} ]

ATTR ContextItem [ | | eh: {EH.PrExpr}  ehTy: {EH.TyExpr} ]

SEM ContextItem
    | Class
        loc         .   eh          =   rngLift @range EH.PrExpr_Class @refname @types.eh
    | Implicits NoImplicits
        loc         .   eh          =   undefined -- may not occur nested
    | RowLacksLabel
        loc         .   eh          =   rngLift @range EH.PrExpr_Lacks (rngLift @range EH.RowTyExpr_Var @rowvariable) @name
    | Arrow
        loc         .   eh          =   rngLift @range EH.PrExpr_Arrow @argument.eh @result.eh
    | Forall
        loc         .   eh          =   foldr (rngLift @range EH.PrExpr_Forall) @context.eh @typevariables
    | Equal
        loc         .   eh          =   rngLift @range EH.PrExpr_Eq @type1.eh @type2.eh

SEM ContextItem
    | * - Implicits NoImplicits
        loc         .   ehTy        =   rngLift @range EH.TyExpr_Pred @eh
    | Implicits
        loc         .   ehTy        =   rngLift @range EH.TyExpr_Impls
    | NoImplicits
        loc         .   ehTy        =   rngLift @range EH.TyExpr_NoImpls

ATTR Constructors [ | | eh USE {:} {[]}: {[EH.DataConstr]} ]

ATTR Constructor [ | | eh: {EH.DataConstr} ]

{
ehPlainDataField :: Range -> EH.TyExpr -> EH.DataField
ehPlainDataField r
  = rngLift r EH.DataField_Field Nothing

}
SEM Constructor
    | Constructor
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
                                                Nothing
                                                (map (ehPlainDataField emptyRange) @types.eh)
                                                Nothing
    | GADTFunction
        loc			.	(ehArgs,ehRes)
        							=	unArrow @type.eh
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
                                                Nothing
                                                (map (ehPlainDataField emptyRange) @ehArgs)
                                                (Just @ehRes)
    | Infix
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
                                                -- (Just $ fgiPrio $ fixityGamLookup @conrefname @lhs.fixityGam)
                                                (let fgi = fixityGamLookup @conrefname @lhs.fixityGam
                                                  in Just (fgiPrio fgi, fgiFixity fgi)
                                                )
                                                (map (ehPlainDataField emptyRange) [@leftType.eh,@rightType.eh])
                                                Nothing
    | Record
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
                                                Nothing
                                                @fieldDeclarations.eh
                                                Nothing
	| Contexted
		lhs			.	eh			=	@constructor.eh			-- for now: ignore

ATTR FieldDeclarations [ | | eh USE {:} {[]}: {[EH.DataField]} ]

ATTR FieldDeclaration [ | | eh: {EH.DataField} ]

SEM FieldDeclaration
    | FieldDeclaration
        lhs         .   eh          =   rngLift @range EH.DataField_Field (Just @fldrefnames) @type.eh

ATTR Type [ | | ehMbAsPr: {Maybe EH.PrExpr} ]

SEM Type
    | NormalApplication
        loc         .   ehMbAsPr    =   case @function.mbRefConNm of
                                          Just conNm | @lhs.isAsPred
                                            -> Just $ rngLift @range EH.PrExpr_Class conNm @arguments.eh
                                          _ -> Nothing
    | Forall
        loc         .   ehMbAsPr    =   foldr (\tv pr -> fmap (rngLift @range EH.PrExpr_Forall tv) pr) @type.ehMbAsPr @typevariables
    | InfixApplication
        loc         .   ehMbAsPr    =   case (@leftType.ehMbAsPr,@rightType.ehMbAsPr) of
                                          (Just l,Just r) | @operator.tyConIs == TyConIsPrArrow && @lhs.isAsPred
                                            -> Just $ rngLift @range EH.PrExpr_Arrow l r
                                          (Nothing,Nothing) | @lhs.isAsPred
                                            -> case @operator.tyConIs of
                                                 TyConIsPrArrow -> Just $ rngLift @range EH.PrExpr_Class (fromJust @operator.mbRefConNm) [@leftType.eh,@rightType.eh]
                                                 TyConIsEqTilde -> Just $ rngLift @range EH.PrExpr_Eq @leftType.eh @rightType.eh
                                                 TyConIsOther   -> Just $ rngLift @range EH.PrExpr_Class (fromJust @operator.mbRefConNm) [@leftType.eh,@rightType.eh]
                                          _ -> Nothing
    | InfixApplicationChainTop Parenthesized Annotate
        loc         .   ehMbAsPr    =   @type.ehMbAsPr
    | * - NormalApplication Forall InfixApplication InfixApplicationChainTop Parenthesized Annotate
        loc         .   ehMbAsPr    =   Nothing

ATTR Type AllRowTypeUpdate [ | | ehMbAsPrL USE {++} {[]}: {[Maybe EH.PrExpr]} ]

SEM Type
    | RowRecUpdate
        loc         .   ehMbAsPrL   =   @rowTypeUpdates.ehMbAsPrL
    | Parenthesized Annotate
        loc         .   ehMbAsPrL   =   @type.ehMbAsPrL
    | * - RowRecUpdate Parenthesized Annotate
        loc         .   ehMbAsPrL   =   [@ehMbAsPr]

SEM RowTypeUpdate
    | Extends
        loc         .   ehMbAsPrL   =   [@type.ehMbAsPr]

ATTR Type [ | | ehMbAsTyPr: {Maybe EH.TyExpr} ]

SEM Type
	| Wildcard MonoWildcard
		loc			.	ehMbAsTyPr	=	Just $ rngLift @range EH.TyExpr_Impls
	| * - Wildcard MonoWildcard
		loc			.	ehMbAsTyPr	=	fmap (rngLift @range EH.TyExpr_Pred) @ehMbAsPr

ATTR Type AllRowTypeUpdate [ | | ehMbAsTyPrL USE {++} {[]}: {[Maybe EH.TyExpr]} ]

SEM Type
    | RowRecUpdate
        loc         .   ehMbAsTyPrL =   @rowTypeUpdates.ehMbAsTyPrL
	| Wildcard MonoWildcard
		loc			.	ehMbAsTyPrL	=	[@ehMbAsTyPr]
	| * - Wildcard MonoWildcard Parenthesized RowRecUpdate
		loc			.	ehMbAsTyPrL	=	map (fmap (rngLift @range EH.TyExpr_Pred)) @ehMbAsPrL

{
ehExpLitInt :: Range -> Int -> String -> Int -> [HsName] -> (EH.Expr,Maybe SrcConst)
ehExpLitInt r b s sign litrefnames
  | sign < 0  = mk (\e -> ehExpVarApp r (litrefnames !! 1) [e], negate)
  | otherwise = mk (id                                        , id    )
  where i = intDenot2Integer b s
        mk (neg,negconst)
          = (neg $ ehExpVarApp r (litrefnames !! 0) [rngLift r EH.Expr_IIConst i], Just $ SrcConst_Int $ negconst i)

ehExpLitFloat :: Range -> String -> Int -> [HsName] -> (EH.Expr,Maybe SrcConst)
ehExpLitFloat r s sign litrefnames
  | sign < 0  = mk (\e -> ehExpVarApp r (litrefnames !! 2) [e], \(n,d) -> (negate n, d))
  | otherwise = mk (id                                        , id                     )
  where nd@(n,d) = floatDenot2NomDenom s
        mk (neg,negconst)
          = ( neg $ ehExpVarApp r (litrefnames !! 1)
                  $ [rngLift r EH.Expr_Parens $ ehExpVarApp r (litrefnames !! 0) [rngLift r EH.Expr_IIConst n,rngLift r EH.Expr_IIConst d]]
            , Just $ uncurry SrcConst_Ratio $ negconst nd
            )

}
{
ehExpApp' :: (EH.Expr -> a -> EH.Expr) -> Range -> EH.Expr -> [a] -> EH.Expr
ehExpApp' app r f as
  = rngLift r EH.Expr_AppTop
    $ foldl app (ehExpUnTop f) as

ehExpConApp :: Range -> HsName -> [EH.Expr] -> EH.Expr
ehExpConApp r n as
  = mkRngParApp r (rngLift r EH.Expr_Con n : as)

ehExpVarApp :: Range -> HsName -> [EH.Expr] -> EH.Expr
ehExpVarApp r n as
  = mkRngParApp r (rngLift r EH.Expr_Var n : as)

ehExpUnTop :: EH.Expr -> EH.Expr
ehExpUnTop (EH.Expr_AppTop _ e) = e
ehExpUnTop e                    = e

}
{
ehExpProd :: Range -> [EH.Expr] -> EH.Expr
ehExpProd r as
  = ehExpConApp r (hsnProd a) as
  where a = length as

}
ATTR Expressions [ | | eh USE {:} {[]}: {[EH.Expr]} ]

ATTR MaybeExpression [ | | eh USE {`const`} {Nothing}: {Maybe EH.Expr} ]

ATTR Expression [ | | eh: {EH.Expr} ]

SEM MaybeExpression
    | Just
        lhs         .   eh          =   Just @just.eh

SEM Expression
    | Literal
        loc         .   eh          =   case @literal.eh of
                                          Literal_Int    r b s -> fst $ ehExpLitInt r b s 1 @litrefnames
                                          Literal_Char   r s -> rngLift r EH.Expr_CConst (head s)
                                          Literal_String r s -> rngLift r EH.Expr_SConst s
                                          Literal_Float  r s -> fst $ ehExpLitFloat r s 1 @litrefnames
    | Variable
        loc         .   eh          =   rngLift @range EH.Expr_Var @refname
    | Constructor
        loc         .   eh          =   rngLift @range EH.Expr_Con @refname
    | TupleConstructor
        loc         .   eh          =   ehTupleConstructor @range @arity EH.Expr_Var EH.PatExpr_Var EH.Expr_Lam
                                            (\_ x -> x) EH.Expr_Rec EH.RecExpr_Ext EH.RecExpr_Empty
    | Parenthesized
        loc         .   eh          =   rngLift @range EH.Expr_Parens @expression.eh
    | NormalApplication
        loc         .   eh          =   mkRngApp @range (@function.eh : @arguments.eh)
    | InfixApplication
        loc         .   eh          =   mkRngParApp @range [@operator.eh,@leftExpression.eh,@rightExpression.eh]
    | InfixApplicationChainTop
        loc         .   eh          =   @ehFromOpChain
    | SectionApplication
        loc         .   eh          =   ehSection
                                            @lUniq_1_nm @range
                                            EH.Expr_Var EH.PatExpr_Var EH.Expr_Lam
                                            @leftExpression.eh @operator.eh @rightExpression.eh
        loc         .   lUniq_1_nm  :   UNIQUEREF gUniq
    | Lambda
        loc         .   eh          =   foldr (rngLift @range EH.Expr_Lam) @expression.eh @patterns.eh
    | Let
        loc         .   eh          =   @mkSccLet @expression.eh
    | Tuple
        loc         .   eh          =   ehExpConApp @range (hsnProd (length @expressions.eh)) @expressions.eh
    | Typed
        loc         .   eh          =   rngLift @range EH.Expr_TypeAs @type.eh @expression.eh
    | Negate
        loc         .   eh          =   ehExpVarApp @range @refname [@expression.eh]
	| Annotate
		loc			.	eh			=	rngLift @range EH.Expr_Ann @annotation.eh @expression.eh
    | ImpredicativeApplication
        loc         .   eh          =   ehExpApp' (rngLift @range EH.Expr_AppImpred) @range @function.eh @arguments.eh
    | If
        loc         .   eh          =   EH.mkIf' (@typerefname : @valrefnames) @range @guardExpression.eh @thenExpression.eh @elseExpression.eh
    | Case
        loc         .   eh          =   EH.mkCase' @range @expression.eh (Just $ Set.singleton @caseId) Set.empty False @alternatives.eh
    | List
        loc         .   eh          =   foldr (\l r -> ehExpConApp @range (@refnames !! 0) [l,r]) (rngLift @range EH.Expr_Con (@refnames !! 1)) @expressions.eh
    | Enum
        loc         .   enumNm      =   case (@from.eh,@then.eh,@to.eh) of
                                          (fr,Just th,Just to) -> hsnEnumFromThenTo
                                          (fr,Just th,Nothing) -> hsnEnumFromThen
                                          (fr,Nothing,Just to) -> hsnEnumFromTo
                                          (fr,Nothing,Nothing) -> hsnEnumFrom
                    .   eh          =   case (@from.eh,@then.eh,@to.eh) of
                                          (fr,Just th,Just to) -> ehExpVarApp @range @refname [fr,th,to]
                                          (fr,Just th,Nothing) -> ehExpVarApp @range @refname [fr,th   ]
                                          (fr,Nothing,Just to) -> ehExpVarApp @range @refname [fr   ,to]
                                          (fr,Nothing,Nothing) -> ehExpVarApp @range @refname [fr      ]
    | Comprehension
        loc         .   eh          =   foldr ($) @expression.eh @qualifiers.eh
    | RecordConstruction
        loc         .   eh          =   rngLift @range EH.Expr_DataFields $ foldl (flip ($)) (rngLift @range EH.DataFieldExpr_Con @refname) @recordExpressionBindings.eh
    | RecordUpdate
        loc         .   eh          =   case @recordExpressionBindings.eh of
                                          b@(_:_) -> rngLift @range EH.Expr_DataFields $ foldl (flip ($)) (rngLift @range EH.DataFieldExpr_Expr @expression.eh) b
                                          _       -> @expression.eh
    | RowRecordUpdate
        loc         .   eh          =   foldl (flip ($)) @expression.eh @rowRecordExpressionUpdates.eh
    | RowRecordEmpty
        loc         .   eh          =   rngLift @range EH.Expr_Rec (rngLift @range EH.RecExpr_Empty)
    | RowRecordSelect
        loc         .   eh          =   rngLift @range EH.Expr_Sel @expression.eh @name
    | Do
        loc         .   (eh,_)      =   foldr1 (\(_,s) (e,_) -> (s e,undefined)) @statements.eh
    | ImplicitApplication
        loc         .   eh          =   ehExpApp' (\f (e,p) -> rngLift @range EH.Expr_AppImpl f p e) @range @function.eh @arguments.eh
    | ImplicitLambda
        loc         .   eh          =   foldr (\(p,c) e -> rngLift @range EH.Expr_LamImpl c p e) @expression.eh @patterns.eh

ATTR ContextedExpressions [ | | eh USE {:} {[]}: {[(EH.Expr,EH.PrExpr)]} ]

ATTR ContextedExpression [ | | eh: {(EH.Expr,EH.PrExpr)} ]

SEM ContextedExpression
    | Contexted
        lhs         .   eh          =   (@expression.eh,@context.eh)

{
-- original with mono restriction
ehGenerator :: Range -> EH.PatExpr -> (EH.Expr -> EH.Expr) -> EH.Expr -> EH.Expr -> EH.Expr
ehGenerator r p mkRes fail e
  = EH.mkLet r
      (Just
         [ {- -} rngLift r EH.Decl_TySig ok ([mono] `mkArrow` mk1App mono mono)
         ,
           rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var ok)
             (rngLift r EH.Expr_Lam
               (rngLift r EH.PatExpr_Var x)
               (EH.mkCase r
                 (rngLift r EH.Expr_Var x)
                 [(p,e),(rngLift r EH.PatExpr_Var hsnWild,fail)]
             ) )
{-
         , rngLift r EH.Decl_TySig res mono
         , rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var res)
             (mkRes (rngLift r EH.Expr_Var ok))
-}
         ])
      (mkRes (rngLift r EH.Expr_Var ok))
      -- (rngLift r EH.Expr_Var res)
  where ok   = mkHNmHidden "ok"
        res  = mkHNmHidden "ok_app"
        x    = mkHNmHidden "x"
        mono = rngLift r EH.TyExpr_Mono

}
ATTR Statements [ | | eh USE {:} {[]}: {[(EH.Expr,EH.Expr -> EH.Expr)]} ]

ATTR Statement [ | | eh: {(EH.Expr,EH.Expr -> EH.Expr)} ]

SEM Statement
    | Expression
        lhs         .   eh          =   (@expression.eh,\e -> ehExpVarApp @range @refname [@expression.eh,e])
    | Let
        lhs         .   eh          =   (EH.mkUnit @range,@mkSccLet)
    | Generator
        lhs         .   eh          =   (@expression.eh
                                        ,ehGenerator
                                           @range @pattern.eh
                                           (\e -> ehExpVarApp @range (@refnames !! 0) [@expression.eh,e])
                                           (EH.mkError' (@refnames !! 1) @range "monadic bind")
                                        )
    | Empty
        lhs         .   eh          =   (undefined,id)

ATTR Qualifiers [ | | eh USE {:} {[]}: {[EH.Expr -> EH.Expr]} ]

ATTR Qualifier [ | | eh: {EH.Expr -> EH.Expr} ]

SEM Qualifier
    | Guard
        lhs         .   eh          =   \e -> EH.mkIf' (@typerefname : @valrefnames) @range @guard.eh e (semCon (@valrefnames !! 2))
    | Let
        lhs         .   eh          =   @mkSccLet
    | Generator
        lhs         .   eh          =   ehGenerator
                                           @range @pattern.eh
                                           (\e -> ehExpVarApp @range (@refnames !! 0) [e,@expression.eh])
                                           (semCon (@refnames !! 1))
    | Empty
        lhs         .   eh          =   \e -> ehExpConApp @range (@refnames !! 0) [e,semCon (@refnames !! 1)]

ATTR Alternatives [ | | eh USE {++} {[]}: {[EH.CaseAlt]} ]

ATTR Alternative [ | | eh: {[EH.CaseAlt]} ]

SEM Alternative
    | Alternative
        lhs         .   eh          =   [EH.mkAlt @range @pattern.eh @righthandside.eh]
    | Empty
        lhs         .   eh          =   []

ATTR GuardedExpressions [ | | eh USE {:} {[]}: {[UIDS -> EH.Expr -> EH.Expr]} ]
ATTR GuardedExpression [ | | eh: {UIDS -> EH.Expr -> EH.Expr} ]

SEM GuardedExpression -- ToDo: or _Guard?
    | GuardedExpression
        lhs         .   eh          =   \failS e -> EH.mkIf'' (@typerefname : @valrefnames) @range @guard.eh (ehMkEnforceMono @range @lhs.mustBeMono @expression.eh) e Nothing failS -- (Just @lhs.caseId)

ATTR RecordExpressionBindings [ | | eh USE {:} {[]}: {[EH.DataFieldExpr -> EH.DataFieldExpr]} ]

ATTR RecordExpressionBinding [ | | eh: {EH.DataFieldExpr -> EH.DataFieldExpr} ]

SEM RecordExpressionBinding
    | Binding
        lhs         .   eh          =   \df -> rngLift @range EH.DataFieldExpr_Upd df @refname @expression.eh

{
ehRowRecExprUpd :: Range -> nm -> (EH.RecExpr -> nm -> EH.Expr -> EH.RecExpr) -> EH.Expr -> EH.Expr -> EH.Expr
ehRowRecExprUpd rng nm mk updE recE
  = case recE of
      EH.Expr_Rec _ r
        -> mkUpd  r
      _ -> mkUpd (r2e recE)
  where r2e     = rngLift rng EH.RecExpr_Expr
        mkUpd r = rngLift rng EH.Expr_Rec (mk r nm updE)

ehRowRecPatExprUpd :: Range -> nm -> (EH.RecPatExpr -> nm -> EH.PatExpr -> EH.RecPatExpr) -> EH.PatExpr -> EH.PatExpr -> EH.PatExpr
ehRowRecPatExprUpd rng nm mk updE recE
  = case recE of
      EH.PatExpr_Rec _ r
        -> mkUpd  r
      _ -> mkUpd (r2e recE)
  where r2e     = rngLift rng EH.RecPatExpr_Expr
        mkUpd r = rngLift rng EH.PatExpr_Rec (mk r nm updE)

}
{
ehRowRowTyExprUpd :: Range -> nm -> (EH.RowTyExpr -> nm -> EH.TyExpr -> EH.RowTyExpr) -> EH.TyExpr -> EH.TyExpr -> EH.TyExpr
ehRowRowTyExprUpd rng nm mk updE recE
  = case recE of
      EH.TyExpr_Row _ r
        -> mkUpd  r
      EH.TyExpr_Var _ v
        -> mkUpd (rngLift rng EH.RowTyExpr_Var v)
      _ -> mkUpd (rngLift rng EH.RowTyExpr_Empty)
  where mkUpd r = rngLift rng EH.TyExpr_Row (mk r nm updE)

}
ATTR RowRecordExpressionUpdates [ | | eh USE {:} {[]}: {[EH.Expr -> EH.Expr]} ]

ATTR RowRecordExpressionUpdate [ | | eh: {EH.Expr -> EH.Expr} ]

SEM RowRecordExpressionUpdate
    | Extends
        lhs         .   eh          =   ehRowRecExprUpd @range @name (rngLift @range EH.RecExpr_Ext) @expression.eh
    | Update
        lhs         .   eh          =   ehRowRecExprUpd @range @name (rngLift @range EH.RecExpr_Upd) @expression.eh

ATTR RowRecordPatternBindings [ | | eh USE {:} {[]}: {[EH.PatExpr -> EH.PatExpr]} ]

ATTR RowRecordPatternBinding [ | | eh: {EH.PatExpr -> EH.PatExpr} ]

SEM RowRecordPatternBinding
    | Binding
        lhs         .   eh          =   ehRowRecPatExprUpd @range @name (rngLift @range EH.RecPatExpr_Ext) @pattern.eh

ATTR RowTypeUpdates [ | | eh USE {:} {[]}: {[EH.TyExpr -> EH.TyExpr]} ]

ATTR RowTypeUpdate [ | | eh: {EH.TyExpr -> EH.TyExpr} ]

SEM RowTypeUpdate
    | Extends
        lhs         .   eh          =   ehRowRowTyExprUpd @range @name (rngLift @range EH.RowTyExpr_Ext) @type.eh

ATTR RecordPatternBindings [ | | eh USE {:} {[]}: {[EH.DataFieldPatExpr -> EH.DataFieldPatExpr]} ]

ATTR RecordPatternBinding [ | | eh: {EH.DataFieldPatExpr -> EH.DataFieldPatExpr} ]

SEM RecordPatternBinding
    | Binding
        lhs         .   eh          =   \df -> rngLift @range EH.DataFieldPatExpr_Ext df @fldrefname @pattern.eh
    | Pun
        lhs         .   eh          =   \df -> rngLift @range EH.DataFieldPatExpr_Ext df @fldrefname (rngLift @range EH.PatExpr_Var @refname)

ATTR FunctionBindings [ | | eh USE {:} {[]}: {[EH.Decl]} ]

ATTR FunctionBinding [ | | eh: {EH.Decl} ]

SEM FunctionBinding
    | FunctionBinding
        lhs         .   eh          =   let (h,t) = hdAndTl @lefthandside.eh
                                        in  rngLift @range EH.Decl_Val h						-- this def is not used, instead it is constructed via IdAsp_Val_Fun
                                              (foldr (rngLift @range EH.Expr_Lam)
                                                     (@lefthandside.ehTyMk @righthandside.eh)
                                                     t)

{
-- | enforce monomorphism
ehMkEnforceMono :: Range -> Bool -> EH.Expr -> EH.Expr
ehMkEnforceMono r True e = rngLift r EH.Expr_TypeAs (rngLift r EH.TyExpr_Mono) e
ehMkEnforceMono _ _    e =                                                     e

}
ATTR LeftHandSide [ | | eh: {[EH.PatExpr]} ]

SEM LeftHandSide
    | Function
        lhs         .   eh          =   rngLift @range EH.PatExpr_Var
                                                (@lhs.patchEhNmInInstance @refname)
                                          : @patterns.eh
    | Infix
        lhs         .   eh          =   [ rngLift @range EH.PatExpr_Var
                                                  (@lhs.patchEhNmInInstance @refname)
                                        , @leftPattern.eh
                                        , @rightPattern.eh
                                        ]
    | Parenthesized
        lhs         .   eh          =   @lefthandside.eh ++ @patterns.eh
    | Typed
        lhs         .   eh          =   @lefthandside.eh

ATTR LeftHandSide [ | | ehTyMk: {EH.Expr -> EH.Expr} ]

SEM LeftHandSide
    | Typed
        lhs         .   ehTyMk      =   rngLift @range EH.Expr_TypeAs @type.eh
    | * - Typed
        lhs         .   ehTyMk      =   id

ATTR RightHandSide [ | | eh: {EH.Expr} ]

SEM RightHandSide
    | Expression
        lhs         .   eh          =   @mkSccLet
                                        $ ehMkEnforceMono @range @lhs.mustBeMono
                                          @expression.eh
    | Guarded
        lhs         .   eh          =   @mkSccLet (foldr (\(mk,failS) e -> mk failS e)
                                                         (rngLift @range EH.Expr_CaseAltFail @lhs.caseId)
                                                         (zip @guardedexpressions.eh (Set.singleton @lhs.caseId : repeat Set.empty)))

ATTR TypeLeftHandSide [ | | eh: {[EH.TyVar]} ]

SEM TypeLeftHandSide
    | Function
        lhs         .   eh          =   rngLift @range EH.TyVar_Var @name : @patterns.eh
    | Infix
        lhs         .   eh          =   [ rngLift @range EH.TyVar_Var @operator
                                        , @leftPattern.eh
                                        , @rightPattern.eh
                                        ]
    | Parenthesized
        lhs         .   eh          =   @lefthandside.eh ++ @patterns.eh

{
ehPatConApp r n as
  = rngLift r EH.PatExpr_AppTop
    $ foldl (rngLift r EH.PatExpr_App) (rngLift r EH.PatExpr_Con n) as

}
{
ehPatProd :: Range -> [EH.PatExpr] -> EH.PatExpr
ehPatProd r as
  = ehPatConApp r (hsnProd a) as
  where a = length as

}
ATTR Patterns [ | | eh USE {:} {[]}: {[EH.PatExpr]} ]

ATTR Pattern [ | | eh: {EH.PatExpr} ]

SEM Pattern
    | Literal
        lhs         .   eh          =   let
                                            mkc r = \c -> mke r (rngLift r EH.Expr_CConst c, Just $ SrcConst_Char c)
                                            mke r = uncurry (rngLift r EH.PatExpr_Expr)
                                        in  case @literal.eh of
                                              Literal_Char   r   s -> mkc r $ head s
                                              Literal_Int    r b s -> mke r (ehExpLitInt r b s @sign @litrefnames)
                                              Literal_String r   s -> foldr (\c p -> ehPatConApp r (@litrefnames !! 0) [mkc r c,p]) (ehPatConApp r (@litrefnames !! 1) []) s
                                              Literal_Float  r   s -> mke r (ehExpLitFloat r s @sign @litrefnames)
    | Variable
        lhs         .   eh          =   rngLift @range EH.PatExpr_Var
                                                (@lhs.patchEhNmInInstance @refname)
    | Constructor
        lhs         .   eh          =   ehPatConApp @range @refname @patterns.eh
    | Parenthesized
        lhs         .   eh          =   rngLift @range EH.PatExpr_Parens @pattern.eh
    | Tuple
        lhs         .   eh          =   foldl (\eh (n,p) -> ehRowRecPatExprUpd @range (Just n) (rngLift @range EH.RecPatExpr_Ext) p eh)
                                              (rngLift @range EH.PatExpr_Rec $ rngLift @range EH.RecPatExpr_Empty)
                                        $ zip positionalFldNames @patterns.eh
    | As
        lhs         .   eh          =   rngLift @range EH.PatExpr_VarAs
                                                (@lhs.patchEhNmInInstance @refname)
                                                @pattern.eh
    | Wildcard
        lhs         .   eh          =   rngLift @range EH.PatExpr_Var hsnWild
	| Annotate
		loc			.	eh			=	rngLift @range EH.PatExpr_Ann @annotation.eh @pattern.eh
    | Typed
        lhs         .   eh          =   rngLift @range EH.PatExpr_TypeAs @type.eh @pattern.eh
    | InfixConstructor
        lhs         .   eh          =   ehPatConApp @range @refname [@leftPattern.eh,@rightPattern.eh]
    | List
        lhs         .   eh          =   foldr (\l r -> ehPatConApp @range (@refnames !! 0) [l,r]) (semCon (@refnames !! 1)) @patterns.eh
    | Record
        lhs         .   eh          =   rngLift @range EH.PatExpr_DataFields $ foldl (flip ($)) (rngLift @range EH.DataFieldPatExpr_Con @refname) @recordPatternBindings.eh
    | RowRecordBinding
        lhs         .   eh          =   foldl (flip ($)) @pattern.eh @rowRecordPattternBindings.eh
    | RowRecordEmpty
        lhs         .   eh          =   rngLift @range EH.PatExpr_Rec (rngLift @range EH.RecPatExpr_Empty)
    | Irrefutable
        lhs         .   eh          =   rngLift @range EH.PatExpr_Irrefutable @pattern.eh
    | Bang
        lhs         .   eh          =   rngLift @range EH.PatExpr_Bang        @pattern.eh
ATTR ContextedPatterns [ | | eh USE {:} {[]}: {[(EH.PatExpr,EH.PrExpr)]} ]

ATTR ContextedPattern [ | | eh: {(EH.PatExpr,EH.PrExpr)} ]

SEM ContextedPattern
    | Contexted
        lhs         .   eh          =   (@pattern.eh,@context.eh)

ATTR TypePatterns [ | | eh USE {:} {[]}: {[EH.TyVar]} ]

ATTR TypePattern [ | | eh: {EH.TyVar} ]

SEM TypePattern
    | Variable
        lhs         .   eh          =   rngLift @range EH.TyVar_Var @refname

ATTR
  AllExpression AllAlternative AllGuardedExpression AllFunctionBinding AllDeclarationPlain
    [ caseId: UID | | ]

SEM Expression
    | Case
        loc         .   caseId      =   @lUniq
		loc			.	lUniq		:	UNIQUEREF gUniq

SEM FunctionBinding
    | FunctionBinding
        loc         .   caseId      =   @lUniq

SEM Declaration
    | PatternBinding
        loc         .   caseId      =   @lUniq

SEM Body
    | Body
        loc         .   caseId      =   uidStart

ATTR TypeAnnotation [ | | eh: {EH.TyExprAnn} ]

SEM TypeAnnotation
    | Strict
        loc         .   eh          =   EH.TyExprAnn_Strictness (Strictness_Strict)
    | AnnotationName
        loc         .   eh          =   case show @name of
                                          "strict"    ->  EH.TyExprAnn_Strictness (Strictness_Strict)
                                          "nonStrict" ->  EH.TyExprAnn_Strictness (Strictness_NonStrict)
                                          _           -> EH.TyExprAnn_Empty
    | AnnotationVar
        loc         .   eh          =   case show @name of
                                          "strictness" -> EH.TyExprAnn_Strictness (Strictness_Var @var)
                                          _            -> EH.TyExprAnn_Empty

ATTR PatternAnnotation [ | | eh: {EH.PatExprAnn} ]

SEM PatternAnnotation
	| Empty
		loc			.	eh			=	EH.PatExprAnn_Empty

ATTR ExpressionAnnotation [ | | eh: {EH.ExprAnn} ]

SEM ExpressionAnnotation
	| Empty
		loc			.	eh			=	EH.ExprAnn_Empty

ATTR KindAnnotation [ | | eh: {EH.KiExprAnn} ]

SEM KindAnnotation
	| Empty
		loc			.	eh			=	EH.KiExprAnn_Empty

ATTR Literal [ | | eh: SELF ]

ATTR Strings [ | | eh USE {:} {[]}: {[String]} ]

