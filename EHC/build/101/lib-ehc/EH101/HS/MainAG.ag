MODULE {EH101.HS.MainAG} {Inh_AGItf (..), Syn_AGItf (..), sem_AGItf, wrap_AGItf
, tyGam2IdDefOccGam, kiGam2IdDefOccGam
, clGam2IdDefOccGam}
{
import Data.Char
import Data.Maybe
import Data.List as List
import qualified Data.Map as Map
import EH.Util.Pretty
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Opts
import EH101.Gam.Full
import EH101.Error
import EH101.Error.Pretty
import EH101.HS
import EH101.NameAspect
import EH.Util.DependencyGraph
import qualified EH.Util.FastSeq as Seq
import EH.Util.Utils
import qualified EH101.EH as EH
import qualified Data.Set as Set
import EH101.Ty (tyQu_Forall,tyQu_Exists)
import EH101.Base.Target
import EH101.Pred
import qualified EH.Util.Rel as Rel
import EH101.Module
import EH101.Foreign
import EH101.Foreign.Parser
import Data.Ratio
import EH101.Scanner.Common(floatDenot2NomDenom,intDenot2Integer)
import EH101.Base.Debug as Debug
import qualified EH101.Base.Pragma as Pragma
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "HS/AbsSyn.ag"
INCLUDE "HS/ToEH.ag"
INCLUDE "HS/Fixity.ag"
INCLUDE "HS/Pretty.ag"
INCLUDE "HS/GatherError.ag"
INCLUDE "HS/ExtraChecks.ag"
INCLUDE "HS/NameLevel.ag"
INCLUDE "HS/NameDef.ag"
INCLUDE "HS/NameAnalysis.ag"
INCLUDE "HS/Uniq.ag"
WRAPPER AGItf

INCLUDE "HS/Pragmas.ag"
PRAGMA novisit nocycle

ATTR AGItf AllNT [ opts: EHCOpts | | ]

ATTR AGItf Module Body [ modEntToOrig: ModEntRngMp | | gathIdGam: IdDefOccGam ]

SEM Body
    | Body
        lhs             .   gathIdGam   =   {- idDefOccGamStrip
                                              $ -}
                                                @declarations.idDefOccGam
                                                `gamUnion`
                                                assocLToGam [ (o {ioccNm = hsnSetQual @lhs.moduleNm (ioccNm o)},d)
                                                            | (o,d) <- gamToAssocL @lhs.idGam
                                                            , n <- Map.findWithDefault [] o @lhs.modEntToOrig
                                                            ]

ATTR Kind [ | | conNm: Name ]

SEM Kind
    | Constructor
        lhs         .   conNm       =   @name
    | * - Constructor
        lhs         .   conNm       =   hsnUnknown

ATTR AllKind [ | | freeTvarS USE {`Set.union`} {Set.empty}: HsNameS ]

SEM Kind
    | Variable
        lhs         .   freeTvarS   =   Set.singleton @name
    | Forall
        lhs         .   freeTvarS   =   @kind.freeTvarS `Set.difference` Set.fromList @kindvariables

ATTR
  AllType
  AllContextItem
  AllContextedPattern
    [ | | freeTvarS USE {`Set.union`} {Set.empty}: HsNameS ]

SEM Type
    | Variable NamedWildcard
        lhs         .   freeTvarS   =   Set.singleton @name
    | Forall Exists
        lhs         .   freeTvarS   =   @type.freeTvarS `Set.difference` Set.fromList @typevariables

SEM ContextItem
    | Forall
        lhs         .   freeTvarS   =   @context.freeTvarS `Set.difference` Set.fromList @typevariables
    | RowLacksLabel
        lhs         .   freeTvarS   =   Set.singleton @rowvariable

ATTR Type [ | | mbRefConNm: {Maybe Name} ]

SEM Type
    | Constructor
        lhs         .   mbRefConNm  =   Just @refname
    | * - Constructor
        lhs         .   mbRefConNm  =   Nothing

{
data TypeConFixedMeaning
  = TyConIsOther
  | TyConIsPrArrow
  | TyConIsEqTilde
  deriving Eq

}
ATTR Type [ | | tyConIs: TypeConFixedMeaning ]

SEM Type
    | Constructor
        loc         .   tyConIs     =   if      hsnIsPrArrow @name then TyConIsPrArrow
                                        else if hsnIsEqTilde @name then TyConIsEqTilde
                                        else                            TyConIsOther
    | NormalApplication
        lhs         .   tyConIs     =  	@function.tyConIs
    | * - Constructor NormalApplication Annotate
        lhs         .   tyConIs     =   TyConIsOther

ATTR Types Type AllRowTypeUpdate [ isAsPred: Bool | | ]

SEM Type
    | InfixApplication
        leftType    .   isAsPred    =   @lhs.isAsPred || @operator.tyConIs == TyConIsPrArrow
    | NormalApplication
        arguments   .   isAsPred    =   False
 	| * - InfixApplication NormalApplication Parenthesized Annotate RowRecUpdate InfixApplicationChainTop
 	      TupleConstructor
 		loc			.	isAsPred	=	False

SEM Constructor
    | Constructor Infix
      GADTFunction
        loc         .   isAsPred    =   False

SEM FieldDeclaration
    | FieldDeclaration
        loc         .   isAsPred    =   False

SEM Declaration
    | Instance
        loc         .   isAsPred    =   True -- False -- True
    | * - Instance
        loc         .   isAsPred    =   False

SEM MaybeType Pattern Expression
    | *
        loc         .   isAsPred    =   False

SEM ContextItem
    | Class
      Equal
        loc         .   isAsPred    =   False

SEM LeftHandSide
    | Typed
        loc         .   isAsPred    =   False

ATTR
  Type MaybeType
  AllRowTypeUpdate
    [ doGenVarWild: Bool | | ]

SEM LeftHandSide
    | Typed
        loc         .   doGenVarWild=   True

SEM Types
    | Cons
        loc         .   doGenVarWild=   False

SEM Pattern
    | Typed
        loc         .   doGenVarWild=   False

SEM Expression
    | Typed
        loc         .   doGenVarWild=   False

SEM Declaration
    | *
        loc         .   doGenVarWild=   False

SEM Constructor
    | Constructor Infix
      GADTFunction
        loc         .   doGenVarWild=   False

SEM FieldDeclaration
    | FieldDeclaration
        loc         .   doGenVarWild=   False

SEM ContextItem
    | Equal
        loc         .   doGenVarWild=   False

ATTR AllConstructor [ | | hasFlds USE {||} {False}: Bool ]

SEM Constructor
    | Record
        lhs         .   hasFlds     =   True

ATTR AllModule AGItf [ isTopMod : Bool | | ]
ATTR AllModule       [ isMainMod: Bool | | ]

SEM AGItf
    | AGItf
        loc         .   isMainMod   =   @module.mainValExists

-- to keep uuagc happy with a not-used dummy value
SEM Declaration
    | Module
        loc         .   isMainMod   =   False
                    .   isTopMod    =   False

ATTR Pattern [ | | isVar: Bool ]

SEM Pattern
    | Variable
        lhs         .   isVar       =   True
    | * - Variable As Parenthesized Annotate
          Typed
          Irrefutable Bang
        lhs         .   isVar       =   False

ATTR RightHandSide AllGuardedExpression [ mustBeMono: Bool | | ]

SEM Declaration
    | PatternBinding
        righthandside   .   mustBeMono  =   not @pattern.isVar

SEM FunctionBinding
    | FunctionBinding
        righthandside   .   mustBeMono  =   False

SEM Alternative
    | Alternative
        righthandside   .   mustBeMono  =   False

{
extrTopInstanceNm :: [HsName] -> (Maybe HsName,[HsName])
extrTopInstanceNm nms
  = case nms of
      (n:t) -> (Just n,t)
      _     -> (Nothing,[])

}
ATTR AllNT [ | topInstanceNmL: {[HsName]} | ]
ATTR AGItf [ topInstanceNmL: {[HsName]} | | ]

SEM Declaration
    | Class Instance InstanceUseImplicitly
        (loc.mbPrevInstancename,lhs.topInstanceNmL)
                                        =   extrTopInstanceNm @lhs.topInstanceNmL

SEM Deriving
    | Deriving
        (loc.mbPrevInstancename,lhs.topInstanceNmL)
                                        =   extrTopInstanceNm @lhs.topInstanceNmL

ATTR Body AllDeclaration AllExpression [ pragmas: {Set.Set Pragma.Pragma} | | ]

SEM Module
    | Module
        body            .   pragmas     =   @fileHeaderPragmas

SEM Body
    | Body
        loc             .   pragmas     =   @declarations.gathPragmas `Set.union` @lhs.pragmas

ATTR AllDeclaration AllExpression [ generDerivMp: {Map.Map HsName [(HsName,HsName)]} | | ]

SEM Body
    | Body
        declarations    .   generDerivMp=   let nm n = hsnSetLevQual @lhs.nmLev @lhs.moduleNm n
                                            in  Map.unionsWith (++)
                                                    [ Map.singleton (nm clNm) [(nm fldNm,nm dfltNm)]
                                                    | (Pragma.Pragma_Derivable clNm fldNm dfltNm) <- Set.toList @pragmas
                                                    ]

SEM Declaration
    | Class
        loc             .   generDerivInfoL
                                        =   Map.findWithDefault [] @classrefname @lhs.generDerivMp

SEM Declaration
    | ForeignImport
        loc         .   nmForParse 	=	maybe "" id @importname
                    . 	(ent,entErrs)
                                    =   parseForeignEnt ForeignDirection_Import @callconvention (Just $ show @name) @nmForParse
