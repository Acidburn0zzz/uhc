{
doccForUse ::Maybe IdDefOcc -> IdIsDef
doccForUse md
  = case md of
      Just d  -> IdIsDef (doccLev d)
      Nothing -> IdIsNotDef

}
{
mkBuiltinIdDefOcc :: HsName -> IdOccKind -> (IdOcc,IdDefOcc)
mkBuiltinIdDefOcc n k
  = (o,emptyIdDefOcc {doccOcc = o, doccLev = nmLevBuiltin, doccRange = builtinRange})
  where o = IdOcc n k

tyGam2IdDefOccGam :: TyGam -> IdDefOccGam
tyGam2IdDefOccGam = gamMap (\(n,_) -> mkBuiltinIdDefOcc n IdOcc_Type)

kiGam2IdDefOccGam :: KiGam -> IdDefOccGam
kiGam2IdDefOccGam = gamMap (\(n,_) -> mkBuiltinIdDefOcc n IdOcc_Kind)

clGam2IdDefOccGam :: ClGam -> IdDefOccGam
clGam2IdDefOccGam = gamMap (\(n,_) -> mkBuiltinIdDefOcc n IdOcc_Class)

}
{
data IdIsDef
  = IdIsDef             { idIsDefLev :: NmLev }
  | IdIsNotDef
  | IdIsInWrongModule   IdOcc
  deriving (Show)

idIsDef :: IdIsDef -> Bool
idIsDef (IdIsDef _) = True
idIsDef _           = False

instance PP IdIsDef where
  pp (IdIsDef _)            = pp "Def'd"
  pp IdIsNotDef             = pp "Undef'd"
  pp (IdIsInWrongModule o)  = "Wrong" >#< o

}
{
data IdUseOcc
  = IdUseOcc
      { uoccOcc     :: IdOcc
      , uoccAsp     :: IdAspect
      , uoccRange   :: Range
      , uoccIsDef   :: IdIsDef
      }
  deriving (Show)

instance PP IdUseOcc where
  pp o = uoccOcc o >|< "/" >|< uoccIsDef o

type IdUseOccGam = Gam    IdOcc  IdUseOcc
type IdUseOccAsc = AssocL IdOcc [IdUseOcc]

}
{
splitIdUseOccGam :: Int -> IdUseOccGam -> (IdUseOccGam, IdUseOccAsc, IdUseOccAsc, IdUseOccGam)
splitIdUseOccGam level g
  = (assocDupLToGam o,h,i,assocDupLToGam e)
  where (o,h,i,e)
          = foldr
              (\x@(k,occs) (o,h,i,e)
                 -> case partition (idIsDef . uoccIsDef) occs of
                      (occ:_,[]) -> case compare (idIsDefLev $ uoccIsDef $ occ) level of
                                      LT -> (x:o,  h,  i,  e)
                                      EQ -> (  o,x:h,  i,  e)
                                      GT -> (  o,  h,x:i,  e)
                      (_,(_:_))  ->         (  o,  h,  i,x:e)
              )
              ([],[],[],[])
              (gamToAssocDupL g)

}
{
mkDefOccGam'' :: NmLev -> Range -> (x -> IdOcc -> IdAspect) -> AssocL x IdOcc -> IdDefOccGam
mkDefOccGam'' l r mka os
  = assocLToGamWithDups [ (o,mkIdDefOcc o (mka x o) l r) | (x,o) <- os ]

mkDefOccGam' :: NmLev -> Range -> (IdOcc -> IdAspect) -> [IdOcc] -> IdDefOccGam
mkDefOccGam' l r mka os
  = mkDefOccGam'' l r (\_ -> mka) (zip (repeat undefined) os)

mkDefOccGam :: NmLev -> Range -> IdAspect -> [IdOcc] -> IdDefOccGam
mkDefOccGam l r a os
  = mkDefOccGam' l r (const a) os

}
{
varL2IdDefOccGam :: IdOccKind -> IdAspect -> NmLev -> Range -> [HsName] -> IdDefOccGam
varL2IdDefOccGam k a l r ns
  = mkDefOccGam l r a [ IdOcc n k | n <- ns ]

tvarL2IdDefOccGam :: NmLev -> Range -> [HsName] -> IdDefOccGam
tvarL2IdDefOccGam
  = varL2IdDefOccGam IdOcc_Type IdAsp_Type_Var

varS2IdDefOccGam :: IdOccKind -> IdAspect -> NmLev -> Range -> HsNameS -> IdDefOccGam
varS2IdDefOccGam k a l r ns
  = varL2IdDefOccGam k a l r (Set.toList ns)

tvarS2IdDefOccGam :: NmLev -> Range -> HsNameS -> IdDefOccGam
tvarS2IdDefOccGam
  = varS2IdDefOccGam IdOcc_Type IdAsp_Type_Var

}
{
kvarL2IdDefOccGam :: NmLev -> Range -> [HsName] -> IdDefOccGam
kvarL2IdDefOccGam
  = varL2IdDefOccGam IdOcc_Kind IdAsp_Kind_Var

kvarS2IdDefOccGam :: NmLev -> Range -> HsNameS -> IdDefOccGam
kvarS2IdDefOccGam
  = varS2IdDefOccGam IdOcc_Kind IdAsp_Kind_Var

}
ATTR
  AllPattern
  AllDeclaration AllFunctionBinding
  LeftHandSide
  TypeLeftHandSide
  AllRowRecordPatternBinding
  AllRecordPatternBinding
  AllDeriving
    [ | | idDefOccGam USE {`gamAddGam`} {emptyGam} : IdDefOccGam
    ]

SEM Declaration
    | TypeSignature
        loc             .   idDefOccGam =   mkDefOccGam' @lhs.nmLev @range (\o -> IdAsp_Val_Sig (@mkEHSig (ioccNm o))) @idOccDefs
                        .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @nmLev @range @type.freeTvarS
    | Fixity
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range IdAsp_Val_Fix [ IdOcc n IdOcc_Val | n <- @oprefnames ]
    | PatternBinding
        loc             .   idDefOccGamPat
                                        =   mkDefOccGam @lhs.nmLev @range (IdAsp_Val_Pat @eh) @idOccDefsPat
                        .   idDefOccGam =   @idDefOccGamPat `gamAddGam` @pattern.idDefOccGam
    | Data Newtype
      GADT
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @nmLev @typelefthandside.range @constructors.freeTvarS -- ???? or from constrs itself, so implicit exists is allowed
                        .   idDefOccGamType2
                                        =   tvarL2IdDefOccGam @nmLev @typelefthandside.range @typelefthandside.typevariables -- ???? this should be it, now only used for check on duplicates
                        .   idDefOccGamConstrs
                                        =   mkDefOccGam @lhs.nmLev @typelefthandside.range IdAsp_Val_Con @idOccDefsCon
                                            `gamAddGam`
                                            mkDefOccGam'' @lhs.nmLev @typelefthandside.range (\c _ -> IdAsp_Val_Fld @typerefname c)
                                                          (concat [ [(c,IdOcc n IdOcc_Val), (c,IdOcc n IdOcc_Fld)] | (c,ns) <- @constructors.conAndFldrefnames, n <- ns ]
                                                          )
                                                          -- [ IdOcc n IdOcc_Val | (con,ns) <- @constructors.conAndFldrefnames, n <- ns ]
                        .   idDefOccGamGener
                                        =   mkDefOccGam @lhs.nmLev @typelefthandside.range (IdAsp_Type_Def @ehGener) @idOccDefsGener
                        .   idDefOccGam =   mkDefOccGam @lhs.nmLev @typelefthandside.range (IdAsp_Type_Def @eh) [@idOccDef]
                                            `gamAddGam` @idDefOccGamConstrs
                                            `gamAddGam` @derivings.idDefOccGam
                                            `gamAddGam` @idDefOccGamGener
    | KindSignature
        loc             .   idDefOccGam =   mkDefOccGam' @lhs.nmLev @range (\o -> IdAsp_Type_Sig (@mkEHSig (ioccNm o))) @idOccDefs
                        .   idDefOccGamKind
                                        =   kvarS2IdDefOccGam @nmLev @range @kind.freeTvarS
    | Class
        loc             .   idDefOccGamType
                                        =   tvarL2IdDefOccGam @nmLev @typelefthandside.range @typelefthandside.typevariables
                        .   idDefOccGamSigAsVar
                                        -- =   assocLToGam [ (o,d {doccAsp = IdAsp_Val_Var}) | (o,d) <- gamToAssocL @where.idDefOccGam, iaspIsValSig (doccAsp d) ]
                                        =   @where.idTySigDefOccGam
                        .   idDefOccGam =   mkDefOccGam @lhs.nmLev @typelefthandside.range (IdAsp_Class_Def @eh @ehInst) [@idOccDef]
                                            `gamUnion` @idDefOccGamSigAsVar
    | Instance
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range  @type.freeTvarS -- @types.freeTvarS
                        .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Inst_Def @eh @classrefname) [@idOccDef]
                                            `gamUnion` mkDefOccGam @lhs.nmLev @range IdAsp_Val_Var [@idOccDefVal]
    | InstanceUseImplicitly
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Inst_Def @eh @classrefname) @idOccDefs
    | Default
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Dflt_Def @eh @ignoredecl) @idOccDefs
    | Type
        loc             .   idDefOccGamType
                                        =   tvarL2IdDefOccGam @nmLev @typelefthandside.range @typelefthandside.typevariables
                        .   idDefOccGam =   mkDefOccGam @lhs.nmLev @typelefthandside.range (IdAsp_Type_Def @eh) @idOccDefs
    | Data Newtype
      Class
      Type
      GADT
        loc             .   idDefOccGamInside
                                        =   tvarL2IdDefOccGam @nmLev @typelefthandside.range @typelefthandside.typevariables
    | ForeignImport
      ForeignExport
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS
    | ForeignImport
      ForeignExport
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Val_Foreign @eh) @idOccDefs
    | FusionDeclaration
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Val_Fusion @eh) @idOccDefs
    | FusionConversion
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Fusion_Conv @eh) @idOccDefs

SEM FunctionBinding
    | FunctionBinding
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range
                                              (IdAsp_Val_Fun @lefthandside.eh
                                                             (@lefthandside.ehTyMk @righthandside.eh)
                                                             @lUniq)
                                              @idOccDefs
        loc             .   lUniq       :   UNIQUEREF gUniq

SEM Pattern
    | Variable As
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range IdAsp_Val_Var @idOccDefsNoWildcard
    | As
        lhs             .   idDefOccGam =   @idDefOccGam `gamAddGam` @pattern.idDefOccGam
    | Typed
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS

SEM LeftHandSide
    | Typed
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS

SEM RecordPatternBinding
    | Pun
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range IdAsp_Val_Var [@idOccDef]

SEM Expression
    | Typed
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS
    | ImplicitLambda
        loc             .   idDefOccGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @patterns.freeTvarS

SEM Type
    | Forall Exists
        loc             .   idDefOccGamInside
                                        =   tvarL2IdDefOccGam @lhs.nmLev @range @typevariables

SEM Kind
    | Forall
        loc             .   idDefOccGamInside
                                        =   kvarL2IdDefOccGam @lhs.nmLev @range @kindvariables

SEM Body
    | Body
        loc             .   idDefOccGamMain
                                        =   gamSingleton @idOccDefMain (mkIdDefOcc @idOccDefMain (IdAsp_Val_Pat @ehMainDecl) @lhs.nmLev @range)
                                            `gamUnion` gamSingleton @idOccDefMain (mkIdDefOcc @idOccDefMain IdAsp_Val_Var @lhs.nmLev @range)
                                            `gamUnion` gamSingleton @idOccDefMain (mkIdDefOcc @idOccDefMain (IdAsp_Val_Sig @ehMainSig) @lhs.nmLev @range)

SEM ContextItem
    | Forall
        loc             .   idDefOccGamInside
                                        =   tvarL2IdDefOccGam @lhs.nmLev @range @typevariables

SEM Deriving
    | Deriving
        loc             .   idDefOccGam =   mkDefOccGam @lhs.nmLev @range (IdAsp_Inst_Def @eh @refname) [@idOccDef]
                                            `gamUnion` mkDefOccGam @lhs.nmLev @range IdAsp_Val_Var [@idOccDefVal]

ATTR
  AllDeclaration
    [ | | idTySigDefOccGam USE {`gamAddGam`} {emptyGam} : IdDefOccGam
    ]

SEM Declaration
    | TypeSignature
        loc             .   idTySigDefOccGam
                                        =   mkDefOccGam' @lhs.nmLev @range (\o -> IdAsp_Val_Var) @idOccDefs

ATTR AllNT [ idGam: IdDefOccGam
           | | ]

ATTR
  AllQualifier
  Statement
    [ | | idGam: IdDefOccGam
    ]

ATTR AGItf [ idGam: IdDefOccGam | | ]


ATTR AGItf Module Body [ modInScope: ModEntDomMp | | ]

SEM Body
    | Body
        loc             .   idGam       =   let -- lookup a name whether it is in scope and check for equality of its qualifier
                                                lkn :: (IdOcc -> Bool) -> HsName -> Maybe (HsName,[ModEnt])
                                                lkn isq n = case Map.lookup n @lhs.modInScope of
                                                              Just es | not (null es')
                                                                -> Just (n,es')
                                                                where es' = [ e | e <- es, isq (mentIdOcc e) ]
                                                              _ -> Nothing
                                                -- for an id, get all inscope occurrences, with + without qualifier
                                                lks :: Bool -> IdOcc -> [(HsName,[ModEnt])]
                                                lks allowRename o
                                                          = ns1 ++ catMaybes ns2
                                                          where (mq,n)    = hsnSplitQualify (ioccNm o)
                                                                (ns1,isq) = case mq of
                                                                              Just q  -> ( qres
                                                                                         , (\o' -> maybe False ({- == q -} `elem` qquals {- -}) (hsnQualifier (ioccNm o'))
                                                                                           )
                                                                                         )
                                                                                      where (qres,qquals)
                                                                                               = maybe ([],[q])
                                                                                                       (\x@(_,es) -> ( [x]
                                                                                                                     , q : extra es
                                                                                                       )             )
                                                                                                       (lkn (const True) (hsnPrefixQual (as q) n))
                                                                              Nothing -> ( [], const True )
                                                                ns2       = [lkn isq n]
                                                                extra | allowRename = \es -> catMaybes $ map (hsnQualifier . ioccNm . mentIdOcc) es
                                                                      | otherwise   = const []
                                                -- map qualifier to a possible 'qualified as' alias
                                                as :: HsName -> HsName
                                                as n = Map.findWithDefault n n @importdeclarations.modAsMp
                                                -- compute new gamma holding proper mapping for unqualified & qualified idents
                                                mkg sel g
                                                   = gamFromAssocL
                                                       [ {- tr "NameAnalysis.mkg" (o >#< ns)
                                                         $ -} (o {ioccNm = n},d {doccNmAlts = Just ns})
                                                       | (o,d) <- gamToAssocL g
                                                       , (n,es) <- sel o
                                                       , let ns = [ ioccNm eo | e <- es, let eo = mentIdOcc e, ioccKind eo == ioccKind o ]
                                                       ]
                                                gnew = mkg (lks False) @lhs.idGam
                                            in  mkg (lks False) @declarations.idDefOccGam `gamUnion` gnew

SEM Expression
    | Let
        loc             .   idGam       =   gamAddGam @declarations.idDefOccGam @lhs.idGam
    | Lambda
        expression      .   idGam       =   gamAddGam @patterns.idDefOccGam @lhs.idGam
    | Typed
        type            .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam
    | Comprehension
        expression      .   idGam       =   @qualifiers.idGam
        qualifiers      .   idGam       =   @lhs.idGam
    | ImplicitLambda
        loc             .   idGam       =   gamUnions [@idDefOccGamType, @lhs.idGam]
        expression      .   idGam       =   gamUnions [@patterns.idDefOccGam, @idGam]

SEM Pattern
    | Typed
        type            .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam

SEM LeftHandSide
    | Typed
        type            .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam

SEM Declaration
    | TypeSignature
      ForeignImport
      ForeignExport
        type            .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam
    | Data Newtype
      Type
      GADT
        loc             .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam
    | KindSignature
        kind            .   idGam       =   gamAddGam @idDefOccGamKind @lhs.idGam
    | Class
        -- simpletype       .   idGam       =   @lhs.idGam      -- avoid cycles
        loc             .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam
                        .   idDefOccGamInstForClass
                                        =   fst $ gamPartition (\_ d -> case doccAsp d of {IdAsp_Inst_Def _ n | n == @classrefname -> True ; _ -> False}) $ @lhs.idGam
    | Instance
        loc             .   idGam       =   gamAddGam @idDefOccGamType @lhs.idGam

SEM FunctionBinding
    | FunctionBinding
        righthandside   .   idGam       =   gamAddGam @lefthandside.idDefOccGam @lhs.idGam

SEM RightHandSide
    | Expression
      Guarded
        loc             .   idGam       =   gamAddGam @where.idDefOccGam @lhs.idGam

SEM Alternative
    | Alternative
        righthandside   .   idGam       =   gamAddGam @pattern.idDefOccGam @lhs.idGam

SEM Qualifier
    | Let
        loc             .   idGam       =   gamAddGam @declarations.idDefOccGam @lhs.idGam
    | Generator
        lhs             .   idGam       =   gamAddGam @pattern.idDefOccGam @lhs.idGam

SEM Statement
    | Let
        loc             .   idGam       =   gamAddGam @declarations.idDefOccGam @lhs.idGam
    | Generator
        lhs             .   idGam       =   gamAddGam @pattern.idDefOccGam @lhs.idGam

SEM Type
    | Forall Exists
        loc             .   idGam       =   gamAddGam @idDefOccGamInside @lhs.idGam

SEM Kind
    | Forall
        loc             .   idGam       =   gamAddGam @idDefOccGamInside @lhs.idGam

SEM ContextItem
    | Forall
        loc             .   idGam       =   gamAddGam @idDefOccGamInside @lhs.idGam

{
litNames :: Literal -> Bool -> Int -> ([HsName],IdAspect)
litNames lit isPat sign
  = case lit of
      Literal_String r s   -> ([hsnDataListAltCons,hsnDataListAltNil],if isPat then IdAsp_Val_Con else IdAsp_Val_Var)
      Literal_Int    _ _ _
        | sign < 0         -> ([hsnFromInteger,hsnNegate],IdAsp_Val_Var)
        | otherwise        -> ([hsnFromInteger],IdAsp_Val_Var)
      Literal_Float  _ _
        | sign < 0         -> ([hsnMkRatio,hsnFromRational,hsnNegate],IdAsp_Val_Var)
        | otherwise        -> ([hsnMkRatio,hsnFromRational],IdAsp_Val_Var)
      _                    -> ([],IdAsp_Val_Var)

}
{
mkUseOccGam :: EHCOpts -> IdDefOccGam -> [HsName] -> IdOccKind -> IdAspect -> Range -> (HsName,[HsName],IdUseOccGam,[Err])
mkUseOccGam _ _ [] _ _ _
  = (hsnUnknown,[],emptyGam,[])
mkUseOccGam opts idGam names kind asp rng
  = (n, ns, gamUnions g, concat e)
  where (ns@(n:_),g,e) = unzip3 [ mkUse idGam n kind asp rng | n <- names ]
        mkUse idGam name kind asp rng
          = (nmOfDef,idUseOccGam,errs)
          where idOccUse    = IdOcc name kind
                mbDef       = -- (\v -> tr "XX" (idOccUse >#< ">>>>>" >#< v) v) $
                              case gamLookup idOccUse idGam of
                                Nothing | hsnIsInPrelude name
                                            -> if ehcOptUseAssumePrelude opts
                                               then Just (emptyIdDefOcc {doccOcc = idOccUse})
                                               else gamLookup (idOccUse {ioccNm = hsnQualified $ ioccNm idOccUse}) idGam
                                md          -> md
                nmOfDef     = case mbDef of
                                Just d -> ioccNm $ doccOcc d
                                _      -> name
                occOfDef    = idOccUse {ioccNm = nmOfDef}
                idUseOccGam = gamSingleton occOfDef (IdUseOcc occOfDef asp rng (doccForUse mbDef))
                errs        = case mbDef of
                                Just d | isJust (doccNmAlts d) && length alts > 1
                                  -> [rngLift rng Err_AmbiguousNameRef "name" "name" name alts]
                                  where alts = fromJust (doccNmAlts d)
                                _ -> []

}
ATTR AllNT [ | | idUseOccGam USE {`gamAddGam`} {emptyGam}: IdUseOccGam ]

SEM Expression
    | Literal
        loc             .   (litnames,litAsp)
                                        =   litNames @literal.eh False 1
                        .   (litrefname,litrefnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam @litnames IdOcc_Val @litAsp @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam, @literal.idUseOccGam]
    | Variable
        loc             .   idAsp       =   IdAsp_Val_Var
    | Constructor
      RecordConstruction
        loc             .   idAsp       =   IdAsp_Val_Con
    | Variable Constructor
      RecordConstruction
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   let x@(n,_,_,_) = mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Val @idAsp @range
                                                dbgnm = mkHNm "putStrLn"
                                                dbgoc = IdOcc dbgnm IdOcc_Val
                                            in  {- if @name == dbgnm
                                                then tr "Expr.idGam" (dbgoc >-< n >-< gamLookup dbgoc @lhs.idGam >-< @lhs.idGam) x
                                                else -} x
    | RecordConstruction
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@recordExpressionBindings.idUseOccGam]
    | Negate
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnNegate] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@expression.idUseOccGam]
    | List
        loc             .   (_,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnDataListAltCons,hsnDataListAltNil] IdOcc_Val IdAsp_Val_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@expressions.idUseOccGam]
    | Enum
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@enumNm] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@from.idUseOccGam,@then.idUseOccGam,@to.idUseOccGam]
    | If
        loc             .   (_,valrefnames,idUseOccGamVal,errIdUseVal)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnTrue,hsnFalse] IdOcc_Val IdAsp_Val_Var @range
                        .   (typerefname,_,idUseOccGamType,errIdUseType)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnBool] IdOcc_Type IdAsp_Type_Con @range
                        .   idUseOccGam =   gamUnions [@idUseOccGamVal,@idUseOccGamType]
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@guardExpression.idUseOccGam,@thenExpression.idUseOccGam,@elseExpression.idUseOccGam]

SEM Literal
    | String
        loc             .   (_,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnDataListAltCons,hsnDataListAltNil] IdOcc_Val IdAsp_Val_Var @range
    | Int
        loc             .   (refname,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnFromInteger] IdOcc_Val IdAsp_Val_Var @range
    | Float
        loc             .   (refname,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnMkRatio,hsnFromRational] IdOcc_Val IdAsp_Val_Var @range

SEM Pattern
    | Literal
        loc             .   (eqrefname,_,idUseOccGamEq,errIdUseEq)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnClassEqFldEq] IdOcc_Val IdAsp_Val_Var @range
                        .   (litnames,litAsp)
                                        =   litNames @literal.eh True @sign
                        .   (litrefname,litrefnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam @litnames IdOcc_Val @litAsp @range
                        .   (eqclassrefname,_,idUseOccGamCls,errIdUseCls)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnClassEq] IdOcc_Class IdAsp_Class_Class @range
        lhs             .   idUseOccGam =   gamUnions
                                                [ @idUseOccGam, @idUseOccGamEq
                                                , @idUseOccGamCls
                                                , @literal.idUseOccGam
                                                ]

SEM Qualifier
    | Guard
        loc             .   (_,valrefnames,idUseOccGamVal,errIdUseVal)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnTrue,hsnFalse,hsnDataListAltNil] IdOcc_Val IdAsp_Val_Var @range
                        .   (typerefname,_,idUseOccGamType,errIdUseType)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnBool] IdOcc_Type IdAsp_Type_Con @range
                        .   idUseOccGam =   gamUnions [@idUseOccGamVal,@idUseOccGamType]
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@guard.idUseOccGam]
    | Generator
        loc             .   (_,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnPrelConcatMap,hsnDataListAltNil] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@pattern.idUseOccGam,@expression.idUseOccGam]
    | Empty
        loc             .   (_,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnDataListAltCons,hsnDataListAltNil] IdOcc_Val IdAsp_Val_Var @range

SEM GuardedExpression
    | GuardedExpression
        loc             .   (_,valrefnames,idUseOccGamVal,errIdUseVal)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnTrue,hsnFalse] IdOcc_Val IdAsp_Val_Var @range
                        .   (typerefname,_,idUseOccGamType,errIdUseType)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnBool] IdOcc_Type IdAsp_Type_Con @range
                        .   idUseOccGam =   gamUnions [@idUseOccGamVal,@idUseOccGamType]
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@guard.idUseOccGam,@expression.idUseOccGam]

SEM Pattern
    | Constructor
      InfixConstructor
      Record
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@conNm] IdOcc_Val IdAsp_Val_Con @range
    | Constructor
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@patterns.idUseOccGam]
    | InfixConstructor
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@leftPattern.idUseOccGam,@rightPattern.idUseOccGam]
    | List
        loc             .   (_,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnDataListAltCons,hsnDataListAltNil] IdOcc_Val IdAsp_Val_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@patterns.idUseOccGam]
    | Record
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@recordPatternBindings.idUseOccGam]

SEM Type
    | Constructor
        loc             .   idAsp       =   IdAsp_Type_Con
                        .   idOccKind   =   IdOcc_Type
    | Variable NamedWildcard
        loc             .   idAsp       =   IdAsp_Type_Var
                        .   idOccKind   =   IdOcc_Type
    | Constructor
      Variable NamedWildcard
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] @idOccKind @idAsp @range

SEM Kind
    | Constructor
        loc             .   idAsp       =   IdAsp_Kind_Con
                        .   idOccKind   =   IdOcc_Kind
    | Variable
        loc             .   idAsp       =   IdAsp_Kind_Var
                        .   idOccKind   =   IdOcc_Kind
    | Constructor Variable
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] @idOccKind @idAsp @range

SEM Type
    | Constructor
        loc             .   (idOccKind,idAsp)
                                        :=  if @lhs.isAsPred && @tyConIs == TyConIsOther
                                            then (IdOcc_Class,IdAsp_Class_Class)
                                            else (IdOcc_Type,IdAsp_Type_Con)				-- TBD, now treated as types whereas they are other special constructs actually

SEM RecordExpressionBinding
    | Binding
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Fld (IdAsp_Val_Fld hsnUnknown hsnUnknown) @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@expression.idUseOccGam]

SEM RecordPatternBinding
    | Binding Pun
        loc             .   (fldrefname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Fld (IdAsp_Val_Fld hsnUnknown hsnUnknown) @range
    | Binding
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@pattern.idUseOccGam]

SEM ContextItem
    | Class
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Class IdAsp_Class_Class @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@types.idUseOccGam]

SEM Declaration
    | Instance
        loc             .   (classrefname,_,idUseOccGamInst,errIdUse)
                                        -- =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Class IdAsp_Class_Class @range
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@type.conNm] IdOcc_Class IdAsp_Class_Class @range
    | InstanceUseImplicitly
        loc             .   (classrefname,_,idUseOccGamInst,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Class IdAsp_Class_Class @range
    | Default
        loc             .   (classrefname,classrefnames,idUseOccGamDflt,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam (catMaybes [@name]) IdOcc_Class IdAsp_Class_Class @range

SEM Deriving
    | Deriving
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Class IdAsp_Class_Class @range

SEM Statement
    | Expression
        loc             .   (refname,_,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnMonadSeq] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   @idUseOccGam `gamUnion` @expression.idUseOccGam
    | Generator
        loc             .   (_,refnames,idUseOccGam,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnMonadBind,hsnMonadFail] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@pattern.idUseOccGam,@expression.idUseOccGam]

SEM Body
    | Body
        loc             .   (mainrefname,mainrefnames,idUseOccGamMain,errIdUse)
                                        =   mkUseOccGam @lhs.opts @idGam
                                              (  [hsnMain]
                                              ++ [hsnIO]                    -- this is assumed to be 2nd
                                              ++ [hsnEhcRunMain]
                                              ++ (if @declarations.needsError then [hsnError] else [])
                                              )
                                              IdOcc_Val IdAsp_Val_Var @range

SEM Declaration
    | Data
      GADT
        loc             .   (_,_,idUseOccGamVal,errIdUseVal)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [] IdOcc_Val IdAsp_Val_Var @range
    | Newtype
        loc             .   (_,_,idUseOccGamVal,errIdUseVal)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [hsnPrelId] IdOcc_Val IdAsp_Val_Var @range

SEM Declaration
    | ForeignExport
        loc             .   (refname,_,idUseOccGamExport,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@name] IdOcc_Val IdAsp_Val_Var @range

SEM Declaration
    | Data Newtype GADT
        loc             .   (_,_,idUseOccGamClass,errIdUseClass)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam
                                                        (if ehcOptGenGenerics @lhs.opts then builtinGenerClassNmL else [])
                                                        IdOcc_Class IdAsp_Class_Class @range

SEM Declaration
    | FusionDeclaration
        loc             .   (reffusename,_,idUseOccGamFusion,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@fusename] IdOcc_Val IdAsp_Val_Var @range
    | FusionConversion
        loc             .   (_,refnames,idUseOccGamFusion,errIdUse)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam [@conname,@absname] IdOcc_Val IdAsp_Val_Var @range

SEM Declaration
    | Class
        loc             .   (_,_,idUseOccGamExtra,errIdUseExtra)
                                        =   mkUseOccGam @lhs.opts @lhs.idGam @extranames IdOcc_Val IdAsp_Val_Var @range

ATTR AllDeclaration [ | | needsError USE {||} {False}: Bool ]

SEM Declaration
    | Data
        lhs             .   needsError  =   @constructors.hasFlds

{
type IdDpdMp = Map.Map IdOcc [IdOcc]

idDpdMpSingleton :: IdOcc -> IdOcc -> IdDpdMp
idDpdMpSingleton f t = Map.singleton f [t]

idDpdMpUnions :: [IdDpdMp] -> IdDpdMp
idDpdMpUnions = Map.unionsWith (++)

idDpdMpUnion :: IdDpdMp -> IdDpdMp -> IdDpdMp
idDpdMpUnion = Map.unionWith (++)

idToOccL2DpdMp :: [IdOcc] -> AssocL IdOcc x -> IdDpdMp
idToOccL2DpdMp fs l
  = if null ts then Map.empty else idDpdMpUnions [ Map.singleton f ts | f <- fs ]
  where ts = assocLKeys l

idToOccGam2DpdMp :: [IdOcc] -> Gam IdOcc x -> IdDpdMp
idToOccGam2DpdMp fs l
  = idToOccL2DpdMp fs (gamToAssocL l)

idFrOccGam2DpdMp :: Gam IdOcc x -> [IdOcc] -> IdDpdMp
idFrOccGam2DpdMp g ts
  = if null ts then Map.empty else idDpdMpUnions [ Map.singleton f ts | (f,_) <- gamToAssocL g ]

}
ATTR
  AllDeclaration AllFunctionBinding
  AllDeriving
    [ | | idDpdMp USE {`idDpdMpUnion`} {Map.empty}: IdDpdMp ]
ATTR AllNT [ | | undefOccGam USE {`gamUnion`} {emptyGam}: IdUseOccGam ]

SEM FunctionBinding
    | FunctionBinding
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                 (gamUnions [@lefthandside.idUseOccGam,@righthandside.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@lefthandside.undefOccGam,@righthandside.undefOccGam]

SEM Declaration
    | TypeSignature
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @type.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp (gamKeys @idDefOccGam) @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@type.undefOccGam]
    | PatternBinding
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                 (gamUnions [@pattern.idUseOccGam,@righthandside.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                            `idDpdMpUnion`
                                            idToOccL2DpdMp [@idOccDef] (gamToAssocL @pattern.idDefOccGam)
                                            `idDpdMpUnion`
                                            idFrOccGam2DpdMp @pattern.idDefOccGam [@idOccDef]
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@righthandside.undefOccGam]
    | Data Newtype
      GADT
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions
                                                    [ @constructors.idUseOccGam
                                                    , @idUseOccGamVal
                                                    , @context.idUseOccGam
                                                    -- , @derivings.idUseOccGam
                                                    , @idUseOccGamClass
                                                    ]
                                                )
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                            `idDpdMpUnion`
                                            idFrOccGam2DpdMp @idDefOccGamConstrs [@idOccDef]
                                            `idDpdMpUnion`
                                            @derivings.idDpdMp
                                            `idDpdMpUnion`
                                            idFrOccGam2DpdMp @idDefOccGamGener [@idOccDef]
    | KindSignature
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @kind.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp (gamKeys @idDefOccGam) @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@kind.undefOccGam]
    | ForeignImport
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @type.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@type.undefOccGam]
    | Class
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [ @context.idUseOccGam,@where.idUseOccGam
                                                           , @idUseOccGamExtra
                                                           ])
                        .   idDpdMp     =   idDpdMpUnions
                                                [ idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                                , idToOccGam2DpdMp [@idOccDef] @idDefOccGamSigAsVar
                                                -- , idToOccGam2DpdMp [@idOccDef] @idDefOccGamInstForClass
                                                , idFrOccGam2DpdMp @idDefOccGamSigAsVar [@idOccDef]
                                                , idFrOccGam2DpdMp @idDefOccGamSigAsVar (gamKeys @idDefOccGamInstForClass)
                                                , @where.idDpdMp
                                                ]
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@where.undefOccGam]
    | Instance
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@idUseOccGamInst,@context.idUseOccGam,@type.idUseOccGam {- @types.idUseOccGam -},@where.idUseOccGam])
                        .   idDpdMp     =   idDpdMpUnions
                                                [ idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                                , idDpdMpSingleton @idOccDefVal @idOccDef
                                                , @where.idDpdMp
                                                ]
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@where.undefOccGam]
    | InstanceUseImplicitly
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@idUseOccGamInst,@types.idUseOccGam,@expression.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
    | Default
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@idUseOccGamDflt,@types.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@types.undefOccGam]
    | Type
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @type.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@type.undefOccGam]
    | ForeignExport
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@idUseOccGamExport,@type.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@type.undefOccGam]
    | FusionDeclaration FusionConversion
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @idUseOccGamFusion
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   @undefOccGam

SEM Body
    | Body
        loc             .   (_,idUseHereOccL,_,undefOccGamMain)
                                        =   splitIdUseOccGam @lhs.nmLev @idUseOccGamMain

SEM Body
    | Body
        loc             .   idDpdMp     =   idToOccL2DpdMp [@idOccDefMain] ((IdOcc @mainrefname IdOcc_Val,undefined) : @idUseHereOccL)
                                            `idDpdMpUnion`
                                            idFrOccGam2DpdMp @idDefOccGamMain [@idOccDefMain]
                                            `idDpdMpUnion`
                                            @declarations.idDpdMp
        lhs             .   undefOccGam =   let g = if @lhs.isMainMod then @undefOccGamMain else emptyGam
                                            in  gamUnions [g,@declarations.undefOccGam]

SEM Deriving
    | Deriving
        lhs             .   idDpdMp     =   idDpdMpUnions
                                                [ idDpdMpSingleton @idOccDef @lhs.idOccDefData
                                                , idDpdMpSingleton @idOccDefVal @idOccDef
                                                ]

ATTR AllTopLevel AGItf [ | | mainValExists: Bool ]

SEM Body
    | Body
        loc             .   mainValExists
                                        =   case gamLookupDup (IdOcc @refmainname IdOcc_Val) @declarations.idDefOccGam of
                                              Nothing   -> False
                                              Just occs -> chk iaspIsValVar
                                                            where chk f = not $ null $ filter (f . doccAsp) occs

ATTR AllDeriving [ idOccDefData: IdOcc | | ]

SEM Declaration
    | Data Newtype GADT
        derivings       .   idOccDefData=   @idOccDef


{
idDpdMp2SccOrder :: IdDefOccGam -> IdDpdMp -> [[IdOcc]]
idDpdMp2SccOrder gam mp
  = dgSCCToList gr
  where dflt = idDpdMpUnions [ idDpdMpSingleton o o | o <- gamKeys gam ] `Map.difference` mp
        gr = mkDpdGrFromEdgesMp (idDpdMpUnions [mp,dflt])

}
SEM Body
    | Body
        loc             .   sccOrder    =   idDpdMp2SccOrder (@idDefOccGamMain `gamUnion` @declarations.idDefOccGam) @idDpdMp

SEM Expression
    | Let
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idDefOccGam @declarations.idDpdMp

SEM RightHandSide
    | Expression
      Guarded
        loc             .   sccOrder    =   idDpdMp2SccOrder @where.idDefOccGam @where.idDpdMp

SEM Qualifier
    | Let
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idDefOccGam @declarations.idDpdMp

SEM Statement
    | Let
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idDefOccGam @declarations.idDpdMp

{
mkIdDefEH :: IdDefOcc -> [EH.Decl]
mkIdDefEH def
  = case doccAsp def of
      IdAsp_Val_Pat decl
        -> [decl]
      IdAsp_Val_Sig decl
        -> [decl]
      IdAsp_Val_Fun lhs rhs _
        -> [decl]
        where (h,t) = hdAndTl lhs
              decl  = rngLift (doccRange def) EH.Decl_Val h (foldr (rngLift (doccRange def) EH.Expr_Lam) rhs t)
      IdAsp_Type_Def decl
        -> [decl]
      IdAsp_Type_Sig decl
        -> [decl]
      IdAsp_Val_Foreign decl
        -> [decl]
      IdAsp_Class_Def decl declInst
        -> [decl,declInst]
      IdAsp_Inst_Def decl _
        -> [decl]
      IdAsp_Dflt_Def decl ignore | not ignore
        -> [decl]
      IdAsp_Val_Fusion decl
        -> [decl]
      IdAsp_Fusion_Conv decl
        -> [decl]
      _ -> []

}
{
mergeFunDefL :: Range -> [IdDefOcc] -> ([IdDefOcc],[Err])
mergeFunDefL _ ds
  = case ds of
      [_] -> (ds,[])
      (od : _ : _) | iaspIsFun (doccAsp od)
          -> ([d],e)
          where (IdAsp_Val_Fun (patf:pats1) _ uniq) = doccAsp od
                xSz   = length pats1
                xNmL  = [ mkHNm ("x" ++ show i) | i <- [1..xSz] ]
                xPatL = map (rngLift r EH.PatExpr_Var) xNmL
                b = EH.mkCase'
                      r (mkRngProdOpt r $ map (rngLift r EH.Expr_Var) $ xNmL)
                      (Just $ Set.fromList $ map (iaspUniq . doccAsp) ds)
                      Set.empty
                      (length xNmL > 1)
                    $ zipWith (EH.mkAlt r)
                       [ mkRngProdOpt r $ tail $ iaspPatL $ doccAsp d | d <- ds ]
                       [ iaspBody $ doccAsp $ d | d <- ds ]
                d = mkIdDefOcc (doccOcc od) (IdAsp_Val_Fun (patf:xPatL) b uniq) 0 r
                e | length patLens > 1 = [rngLift r Err_FunPatternLengths (ioccNm $ doccOcc od)]
                  | otherwise          = []
                  where patLens = Set.toList $ Set.fromList [ length $ iaspPatL $ doccAsp d | d <- ds ]
                r = rangeUnions [ doccRange d | d <- ds ]
      _   -> ([],[])

}
{
splitOff :: [IdDefOcc] -> [[IdDefOcc]]
splitOff
  = foldr (\df dfs -> zipWith (++) (s df) dfs) (repeat [])
  where s d = case doccAsp d of
                (IdAsp_Inst_Def  _ _) -> [[],[d]]
                _                     -> [[d],[]]

}
{
idOcc2Defs :: IdDefOccGam -> IdOcc -> [IdDefOcc]
idOcc2Defs idDefOccGam occ = maybe [] id $ gamLookupDup occ idDefOccGam

mkIdOccEH :: Range -> [IdDefOcc] -> ([EH.Decl],[Err])
mkIdOccEH r defs
  = case defs of
      (_:_)
        -> (concatMap mkIdDefEH (otherDefs ++ funDef),errL)
        where (funDefs,otherDefs) = partition (iaspIsFun . doccAsp) defs
              (funDef,errL) = mergeFunDefL r funDefs
      _ -> ([],[])

}
{
idDefOccs2Decls :: Range -> [[IdDefOcc]] -> ([[EH.Decl]],[Err])
idDefOccs2Decls r docss
  = ([concat ds], concat es)
  where (ds,es) = unzip $ map (mkIdOccEH r) $ docss

}
{
mkIdOccSccEH :: Range -> Bool -> IdDefOccGam -> Maybe [[IdOcc]] -> (EH.Expr -> EH.Expr,[[EH.Decl]],[Err])
mkIdOccSccEH r isStrict g moss
  = (m . mkLet (concat sds), d ++ sds, e ++ ses)
  where (m,d,e) = foldr mkl (id,[],[]) doss
        mkl dos (mke,d,e)
          = ((\e -> foldr mkLet e dss) . mke,dss ++ d, es ++ e)
          where (dss,es) = idDefOccs2Decls r dos
        mkLet ds = EH.mkLet' isStrict r (Just ds)
        (sds,ses) = idDefOccs2Decls r $ concat $ spls
        (doss:spls:_)
          = collapse
              [ collapse [ splitOff $ idOcc2Defs g $ l | l <- ll ]
              | ll <- maybe [gamKeys g] id moss
              ]
        collapse :: [[a]] -> [[a]]
        collapse = foldr (zipWith (:)) (repeat [])

}
SEM Body
    | Body
        loc             .   (mkSccLet,_,errReorder)
                                        =   let g = if @lhs.isMainMod then @idDefOccGamMain else emptyGam
                                            in  mkIdOccSccEH @range False (g `gamUnion` @declarations.idDefOccGam) (Just @sccOrder)

SEM Expression
    | Let
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range @isStrict @declarations.idDefOccGam (Just @sccOrder)

SEM RightHandSide
    | Expression
      Guarded
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range False @where.idDefOccGam (Just @sccOrder)

SEM Qualifier
    | Let
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range False @declarations.idDefOccGam (Just @sccOrder)

SEM Declaration
    | Instance Class
        loc             .   (_,ehReorderedDecls,errReorder)
                                        =   mkIdOccSccEH @range False @where.idDefOccGam Nothing

SEM Statement
    | Let
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range False @declarations.idDefOccGam (Just @sccOrder)

ATTR AllImportDeclaration [ | | modAsMp USE {`Map.union`} {Map.empty}: {Map.Map HsName HsName} ]

SEM ImportDeclaration
    | Import
        lhs             .   modAsMp     =   maybe Map.empty (Map.singleton @name) @asname
    | * - Import
        lhs             .   modAsMp     =   Map.empty

{
type PatchEhNmInInstance = HsName -> HsName

}
ATTR AllNT [ patchEhNmInInstance: PatchEhNmInInstance | | ]

SEM AGItf
    | AGItf
        loc             .   patchEhNmInInstance
                                        =   id

SEM Declaration
    | Instance
        where           .   patchEhNmInInstance
                                        =   hsnSetQual (panicJust "Declaration.Instance.patchEhNmInInstance" $ hsnQualifier @classrefname)
    | PatternBinding
        righthandside   .   patchEhNmInInstance
                                        =   id
    | * - Instance FunctionBindings PatternBinding
        loc             .   patchEhNmInInstance
                                        =   id

SEM FunctionBinding
    | FunctionBinding
        righthandside   .   patchEhNmInInstance
                                        =   id

SEM LeftHandSide
    | Function
        patterns        .   patchEhNmInInstance
                                        =   id
    | Infix
        loc             .   patchEhNmInInstance
                                        =   id

