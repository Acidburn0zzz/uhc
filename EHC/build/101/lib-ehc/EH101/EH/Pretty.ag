{
infixr 2 >###<      -- same as >-<

(>###<) :: PP_Doc -> PP_Doc -> PP_Doc
l >###< r = l >-< indent 2 r

}
ATTR AllNT AllAnn AGItf [ | | pp USE {>-<} {empty} : PP_Doc ]

SEM Expr
  | IConst      loc     .   pp      =   pp (show @int)
  | CConst      loc     .   pp      =   pp (show @char)
  | Var         loc     .   pp      =   pp @nm
  | Con         loc     .   pp      =   ppCon @nm
  | Let         loc     .   pp      =   if ehcOptShowEH @lhs.opts || ehcOptEmitEH @lhs.opts
                                        then
                                             "let"
                                             >|< (if @isStrict then pp "!" else empty)
                                             >#< (@decls.pp >-< @extraPP)
                                             >-< @errLetPP
                                             >#< "in" >-< @body.pp
                                        else empty
  | App         loc     .   pp      =   @func.pp >#< @arg.pp
  | Parens      loc     .   pp      =   ppParens @expr.pp
  | TypeAs      loc     .   pp      =   ppParens @expr.pp >#< "::" >#< @tyExpr.pp
  | Ann         loc     .   pp      =   {- @ann.pp >#< -} @expr.pp

  | AppTop      loc     .   pp      =   ppAppTop  (@expr.appFunNm,@expr.appFunPP)
                                                  @expr.appArgPPL @expr.pp
  | Lam         loc     .   argPP   =   @arg.pp
  | Lam
    LamImpl
                loc     .   pp      =   if @lhs.isTopLam
                                        then let sep = case @lamArgPPL of
                                                         [_] -> (>#<)
                                                         _   -> (>###<)
                                             in  ("\\" >|< ppSpaces @lamArgPPL) `sep` ("->" >#< @body.lamBodyPP)
                                        else "\\" >|< @argPP >#< "->" >#< @body.pp

SEM Decl
  | Val         loc     .   pp      =   @patExpr.pp >###< "=" >#< @expr.pp
  | TySig       loc     .   tyPP    =   @tyExpr.pp
                        .   pp      =   @nm >#< "::" >#< @tyPP

SEM PatExpr
  | IConst      loc     .   pp      =   pp (show @int)
  | CConst      loc     .   pp      =   pp (show @char)
  | Var         loc     .   pp      =   pp @nm
  | VarAs       loc     .   pp      =   pp @nm >|< "@" >|< @patExpr.pp
  | Con         loc     .   pp      =   ppCon @nm
  | App         loc     .   pp      =   @func.pp >#< @arg.pp
  | AppTop      loc     .   pp      =   ppAppTop  (@patExpr.appFunNm,@patExpr.appFunPP)
                                                  @patExpr.appArgPPL @patExpr.pp
  | Parens      loc     .   pp      =   ppParens @patExpr.pp
  | Ann         loc     .   pp      =   {- @ann.pp >#< -} @patExpr.pp

SEM TyExpr
  | Con         loc     .   pp      =   ppCon @nm
  | App         loc     .   pp      =   @func.pp >#< @arg.pp
  | AppTop      loc     .   pp      =   ppAppTop  (@tyExpr.appFunNm,@tyExpr.appFunPP)
                                                  @tyExpr.appArgPPL @tyExpr.pp
  | Parens      loc     .   pp      =   ppParens @tyExpr.pp
  | Ann         loc     .   pp      =   @ann.pp >#< @tyExpr.pp

SEM Decls
  | Cons        lhs     .   pp      =   @hd.pp
                                        >-< @errPP
                                        >-< @tl.pp

SEM AGItf
  | AGItf       lhs     .   pp      =   @extraPP >-< @expr.pp
                                        >-< @errTopPP
                loc     .   extraPP =   empty

ATTR Expr [ | | lamArgPPL: {[PP_Doc]}  lamBodyPP: PP_Doc ]

SEM Expr
  | Lam
    LamImpl
                loc     .   lamArgPPL   =   @argPP : @body.lamArgPPL
  | * - Lam
    LamImpl
                loc     .   lamBodyPP   =   @pp
                        .   lamArgPPL   =   []

SEM TyExpr
  | Wild        loc     .   pp      =   pp "..."
  | Mono        loc     .   pp      =   pp "%..."

SEM TyExpr
  | Var         loc     .   pp      =   pp @nm
  | VarWild     loc     .   pp      =   "%" >|< pp @nm

SEM Decl
  | TySig       loc     .   tyPP    :=  if null @tyExpr.tyWildL
                                        then  @tyExpr.pp
                                        else  ppTy @finalTy

SEM Decl
  | TySig       loc     .   tyPP    :=  if Map.null @tyExpr.tyVarWildMp
                                        then  @tyExpr.pp
                                        else  ppTy @finalTy

SEM Decl
  | TySig       loc     .   tyPP    :=  @tyExpr.pp

SEM Expr
  | AppImpred   loc     .   argPP   =   "~" >|< @arg.pp
                        .   pp      =   @func.pp >#< @argPP

SEM PatExpr
  | TypeAs      loc     .   pp      =   @patExpr.pp >#< "::" >#< @tyExpr.pp

SEM TyExpr
  | Quant       loc     .   pp      =   showTyQu @qu >#< @tyVar >#< "." >#< @tyExpr.pp

SEM Expr
  | SConst      loc     .   pp      =   pp (show @str)
  | Case        loc     .   pp      =   "case"  >#< @expr.pp >#< "of"
                                                >-< indent 2 (vlist @alts.ppL)
                                                >-< @extraPP
                        .   extraPP =   maybe empty (ppCmt . ppCommas' . Set.toList) @mbCaseIds

SEM PatExpr
  | SConst      loc     .   pp      =   pp (show @str)

SEM CaseAlt
  | Pat         loc     .   pp      =   @patExpr.pp >|< @extraPP >###< "->" >#< @expr.pp
                        .   extraPP =   empty

SEM TyVar
  | Var         lhs     .   pp      =   pp @nm

SEM KiExpr
  | Con Var     loc     .   pp      =   pp @nm
  | App         loc     .   pp      =   @func.pp >#< @arg.pp
  | AppTop      loc     .   pp      =   ppAppTop  (@kiExpr.appFunNm,@kiExpr.appFunPP)
                                                  @kiExpr.appArgPPL @kiExpr.pp
  | Parens      loc     .   pp      =   ppParens @kiExpr.pp
  | Ann         loc     .   pp      =   {- @ann.pp >#< -} @kiExpr.pp

SEM Decl
  | KiSig       loc     .   pp      =   @nm >#< "::" >#< @kiExpr.pp

SEM Expr
  | DataFields  loc     .   pp      =   @dataFieldExpr.pp >#< ppCurlysCommas' (reverse @dataFieldExpr.ppL)
  | Rec         loc     .   pp      =   ppAppTop  (hsnRec,mkPPAppFun @appFunNm @recExpr.pp)
                                                  (reverse @recExpr.ppL) @recExpr.pp
  | Sel         loc     .   pp      =   @expr.pp >|< "." >|< @lbl

SEM RecExpr
  | Empty       loc     .   pp      =   hsnORec >|< hsnCRec
  | Ext         loc     .   pp      =   ppFld "=" (Just @positionalNm) @nm (pp @nm) @expr.pp
  | Upd         loc     .   pp      =   ppFld ":=" Nothing @nm (pp @nm) @expr.pp
  | Ext Upd     lhs     .   pp      =   @recExpr.pp
  | Expr        loc     .   pp      =   @expr.pp

SEM PatExpr
  | DataFields  loc     .   pp      =   @dataFieldPatExpr.pp >#< ppCurlysCommas' (reverse @dataFieldPatExpr.ppL)
  | Rec         loc     .   pp      =   ppAppTop  (hsnRec,mkPPAppFun @appFunNm @recPatExpr.pp)
                                                  (reverse @recPatExpr.ppL) @recPatExpr.pp

SEM RecPatExpr
  | Empty       loc     .   pp      =   hsnORec >|< hsnCRec
  | Ext         loc     .   pp      =   @recPatExpr.pp
  | Expr        loc     .   pp      =   @patExpr.pp

SEM TyExpr
  | Row         loc     .   pp      =   ppAppTop  (hsnRow,mkPPAppFun hsnRow @rowTyExpr.pp)
                                                  (reverse @rowTyExpr.ppL) @rowTyExpr.pp

SEM RowTyExpr
  | Ext         lhs     .   pp      =   @rowTyExpr.pp

SEM DataFieldExpr
  | Upd         loc     .   pp      =   ppFld "=" Nothing @nm (pp @nm) @expr.pp
                lhs     .   pp      =   @dataFieldExpr.pp
  | Con         loc     .   pp      =   pp @nm
  | Expr        loc     .   pp      =   @expr.pp

SEM DataFieldPatExpr
  | Ext         loc     .   pp      =   ppFld "=" Nothing @nm (pp @nm) @patExpr.pp
                lhs     .   pp      =   @dataFieldPatExpr.pp
  | Con         loc     .   pp      =   pp @nm

SEM Expr
  | Undefined   loc     .   pp      =   pp "..."
  | CaseAltFail loc     .   pp      =   pp "FAIL" >#< @caseId

SEM Decl
  | FFI         loc     .   pp      =   "foreign import" >#< @callconv >#< @safety >#< pp (show @impEnt) >#< @nm >#< "::" >#< @tyExpr.pp
  | FFE         loc     .   pp      =   "foreign export" >#< @nm >#< @callconv >#< ppForeignEnt @expEnt >#< @expr.pp >#< "::" >#< @tyExpr.pp

SEM PatExpr
  | Irrefutable loc     .   pp      =   "~" >|< @patExpr.pp
  | Bang 		loc     .   pp      =   "!" >|< @patExpr.pp

SEM RowTyExpr
  | Var         loc     .   pp      =   pp @nm

SEM TyExpr
  | Pred        loc     .   pp      =   hsnOImpl >#< @prExpr.pp >#< hsnCImpl
  | Impls       loc     .   pp      =   hsnOImpl >#< "..." >#< hsnCImpl
  | NoImpls     loc     .   pp      =   hsnOImpl >#< "_" >#< hsnCImpl

SEM PrExpr
  | Class       loc     .   pp      =   ppSpaced (pp @nm : @tyExprs.ppL)
  | Arrow       loc     .   pp      =   @arg.pp >#< hsnPrArrow >#< @res.pp
  | Forall      loc     .   pp      =   "forall" >#< @tyVar >#< "." >#< @prExpr.pp

SEM Decl
  | Class       loc     .   pp      =   "class"     >#< @tyPrExpr.pp
                                                    >#< "|" >#< ppListSep "" "" ", " @funcDeps.ppL
                                                    >#< "where"
                                                    >-< indent 2 (@decls.pp
                                                                  >-< ppCmt (ppAssocL @generDerivs)
                                                                 )
  | Instance    loc     .   pp      =   "instance"  >|< maybe empty (\(n,e) -> " " >|< n >#< (if e then "<:" else "::")) @mbNmElim
                                                    >#< @tyPrExpr.pp
                                                    >#< "where"
                                                    >#< ppCmt (pp $ show @instVariant)
                                                    >-< indent 2 @decls.pp
                                                    >-< @errInstPP
                                                    >-< @errDeclsPP
  | InstanceIntro
                loc     .   pp      =   "instance"  >#< @expr.pp >#< "<:" >#< @prExpr.pp
                                                    >-< @errInstPP
  | Default     loc     .   pp      =   "default"  >#< @nm >#< ppParensCommas' @tyExprs.ppL

SEM PrExpr
  | Lacks       loc     .   pp      =   @rowTyExpr.pp >|< "\\" >|< pp @nm
  | DynVar      loc     .   pp      =   hsnDynVar >|< @nm >#< "::" >#< @tyExpr.pp

SEM Expr
  | DynVar      loc     .   pp      =   hsnDynVar >|< pp @nm

SEM PrExpr
  | Eq          loc     .   pp      =   @tyExpr1.pp >#< hsnEqTilde >#< @tyExpr2.pp

SEM Decl
  | Type        loc     .   pp      =   "type" >#< @tyNm >#< "=" >#< @tyExpr.pp

SEM TyExpr
  | Lam         loc     .   pp      =   "\\" >|< @tyVar >#< "->" >#< @tyExpr.pp

SEM Expr
  | AppImpl     loc     .   argPP   =   @arg.pp >#< "<:" >#< @argPr.pp
                        .   pp      =   @func.pp >#< hsnOImpl >#< @argPP >#< hsnCImpl
  | LamImpl     loc     .   argPP   =   hsnOImpl >#< @arg.pp >#< "<:" >#< @argPr.pp >#< hsnCImpl

SEM FuncDep
  | Dep         lhs     .   pp      =   @fromTvs.pp >#< "->" >#< @toTvs.pp


SEM Expr
  | IIConst     loc     .   pp      =   pp (show @integer)

SEM PatExpr
  | Expr        loc     .   pp      =   "`" >|< @expr.pp >|< "`"

SEM ExprAnn
  | Empty		loc		.	pp		=	empty

SEM PatExprAnn
  | Empty		loc		.	pp		=	empty

SEM TyExprAnn
  | Empty		loc		.	pp		=	empty
  | Strictness  loc     .   pp      =   "@" >|< show @strictness

SEM KiExprAnn
  | Empty		loc		.	pp		=	empty

SEM Decl
  | Data        loc     .   pp      =   (if @isNewtype then "newtype" else "data")
                                        >#< @tyNm >#< ppSpaced @tyVars.ppL
                                        >#< "=" >#< ppListSepFill "" "" " | " @constrs.ppL

SEM DataConstr
  | Constr      loc     .   pp      =   pp @conNm
                                        >#<  (if null $ catMaybes $ assocLKeys $ @dataConGadtFldTyL
                                              then ppSpaced @fields.ppL
                                              else ppCurlysCommas' @fields.ppL
                                             )
              							>|< maybe empty (\t -> " ->" >#< t) @mbGadtTyExpr.ppMb
                        .   extraPP =   empty

SEM DataField
  | Field       lhs     .   pp      =   case @mbLabels of
                                          Just l  -> ppCommas' l >#< "::" >#< @tyExpr.pp
                                          Nothing -> @tyExpr.pp


SEM Decl
  | GenerRep    loc     .   pp      =   "generic" >#< (@maxArity >#< @tyNm >-< (vlist @conNmL) >-< (ppAssocLV $ assocLMapElt ppCurlysCommas @recFldNmL))

SEM Decl
  | FusionDecl  loc     .   pp      =   "fuse" >#< @fuseNm
  | FusionConv  loc     .   pp      =   "convert" >#< ppCommas [@absNm, @conNm]

ATTR TyExpr [ | | appFunPP: PP_Doc  appArgPPL: {[PP_Doc]} ]

SEM TyExpr
  | App         lhs     .   appArgPPL   =   @func.appArgPPL ++ [@arg.pp]
                        .   appFunPP    =   @func.appFunPP
  | * - App
                lhs     .   appArgPPL   =   []
                lhs     .   appFunPP    =   @pp

SEM TyExpr
  | App         lhs     .   (appFunPP,appArgPPL)
                                        :=  mkExtAppPP  (@func.appFunNm,@func.appFunPP,@func.appArgPPL)
                                                        (@arg.appFunNm,@arg.appFunPP,@arg.appArgPPL,@arg.pp)
  | Row         lhs     .   appArgPPL   :=  reverse @rowTyExpr.ppL
                        .   appFunPP    :=  @rowTyExpr.pp

ATTR KiExpr [ | | appFunPP: PP_Doc  appArgPPL: {[PP_Doc]} ]

SEM KiExpr
  | App         lhs     .   appArgPPL   =   @func.appArgPPL ++ [@arg.pp]
                        .   appFunPP    =   @func.appFunPP
  | * - App     lhs     .   appArgPPL   =   []
                lhs     .   appFunPP    =   @pp

SEM Expr
  | Let         loc     .   extraPP     =   empty

SEM Expr
  | Let         loc     .   extraPP     :=  ppCmt (ppGam (gamTop @decls.patValGam))

SEM Expr
  | Let         loc     .   extraPP     :=  ppCmt (ppGam (@lhs.finTyVarMp `varUpd` (gamTop @decls.patValGam)))

SEM Expr
  | Let         loc     .   extraPP     :=  ppCmt (ppGam $ @lhs.finTyVarMp `varUpd` @finValGamDecls)

SEM Expr
  | Let         loc     .   extraPP     :=  ppCmt (ppGam $ fst $ gamPartition (\k _ -> tyKiKeyIsName k) @lQuTyKiGam_ex_subst) >-< ppCmt (ppGam $ @lhs.finTyVarMp `varUpd` @finValGamDecls)

SEM Expr
  | Let         loc     .   extraPP     :=  if ehcOptVerbosity @lhs.opts > VerboseNormal
                                            then ppCmt (    ppGam (fst $ gamPartition (\k _ -> tyKiKeyIsName k) @lQuTyKiGam_ex_subst)
                                                       >-<  ppGam @lQuTyGam
                                                       >-<  ppGam (@lhs.finTyVarMp `varUpd` @finValGamDecls)
                                                       >-<  ppGam @lClGamNoDups
                                                       >-<  ppGam @loc.finGathPolGam_extra
                                                       )
                                            else empty


SEM AGItf
  | AGItf       loc     .   extraPP     :=  if ehcOptVerbosity @lhs.opts > VerboseNormal
                                            then ppCmt (ppGam @lhs.valGam)
                                            else empty

SEM AGItf
  | AGItf       loc     .   extraPP     :=  empty

ATTR
  MbTyExpr
    [ | | ppMb: {Maybe PP_Doc} ]

SEM MbTyExpr
  | Just		lhs		.	ppMb	=	Just @just.pp
  | Nothing		lhs		.	ppMb	=	Nothing

ATTR
  TyVars TyExprs DataConstrs
  DataFields
    [ | | ppL: {[PP_Doc]} ]

SEM
  TyExprs TyVars DataConstrs
  DataFields
  | Nil         lhs     .   ppL     =   []
  | Cons        lhs     .   ppL     =   @hd.pp : @tl.ppL


ATTR CaseAlts [ | | ppL: {[PP_Doc]} ]

SEM CaseAlts
  | Nil         lhs     .   ppL     =   []
  | Cons        lhs     .   ppL     =   (@hd.pp >|< @extraPP) : @tl.ppL
                loc     .   extraPP =   empty


ATTR RecExpr RowTyExpr RecPatExpr DataFieldExpr DataFieldPatExpr [ | | ppL: {[PP_Doc]} ]

SEM RecExpr
  | Empty       lhs     .   ppL     =   []
  | Ext Upd     lhs     .   ppL     =   @pp : @recExpr.ppL
  | Expr        lhs     .   ppL     =   []

SEM RecPatExpr
  | Empty       lhs     .   ppL     =   []
  | Ext         lhs     .   ppL     =   ppFld "=" (Just @positionalNm) @nm (pp @nm) @patExpr.pp : @recPatExpr.ppL
  | Expr        lhs     .   ppL     =   []

SEM RowTyExpr
  | Empty       lhs     .   ppL     =   []
  | Ext         lhs     .   ppL     =   ppFld "::" (Just @positionalNm) @nm (pp @nm) @tyExpr.pp : @rowTyExpr.ppL
  | Var         lhs     .   ppL     =   []

SEM DataFieldExpr
  | Upd         lhs     .   ppL     =   @pp : @dataFieldExpr.ppL
  | Con Expr    lhs     .   ppL     =   []

SEM DataFieldPatExpr
  | Ext         lhs     .   ppL     =   @pp : @dataFieldPatExpr.ppL
  | Con         lhs     .   ppL     =   []

ATTR PrExprs [ | | ppL: {[PP_Doc]} ]

SEM PrExprs
  | Nil         lhs     .   ppL     =   []
  | Cons        lhs     .   ppL     =   @hd.pp : @tl.ppL


ATTR FuncDeps [ | | ppL: {[PP_Doc]} ]

SEM FuncDeps
  | Nil         lhs     .   ppL     =   []
  | Cons        lhs     .   ppL     =   @hd.pp : @tl.ppL

ATTR Expr [ | | appFunPP: PP_Doc  appArgPPL: {[PP_Doc]} ]

SEM Expr
  | App         lhs     .   appArgPPL   =   @func.appArgPPL ++ [@arg.pp]
                        .   appFunPP    =   @func.appFunPP
  | * - App     lhs     .   appArgPPL   =   []
                        .   appFunPP    =   @pp

SEM Expr
  | AppImpred   lhs     .   appArgPPL   :=  @func.appArgPPL ++ [@argPP]
                        .   appFunPP    :=  @func.appFunPP

SEM Expr
  | App         lhs     .   (appFunPP,appArgPPL)
                                        :=  mkExtAppPP  (@func.appFunNm,@func.appFunPP,@func.appArgPPL)
                                                        (@arg.appFunNm,@arg.appFunPP,@arg.appArgPPL,@arg.pp)
  | Rec         lhs     .   appArgPPL   :=  reverse @recExpr.ppL
                        .   appFunPP    :=  @recExpr.pp

SEM Expr
  | AppImpl     lhs     .   appArgPPL   :=  @func.appArgPPL ++ [@argPP]
                        .   appFunPP    :=  @func.appFunPP

ATTR PatExpr [ | | appFunPP: PP_Doc  appArgPPL: {[PP_Doc]} ]

SEM PatExpr
  | App         lhs     .   appArgPPL   =   @func.appArgPPL ++ [@arg.pp]
                        .   appFunPP    =   @func.appFunPP
  | * - App     lhs     .   appArgPPL   =   []
                        .   appFunPP    =   @pp

SEM PatExpr
  | App         lhs     .   (appFunPP,appArgPPL)
                                        :=  mkExtAppPP  (@func.appFunNm,@func.appFunPP,@func.appArgPPL)
                                                        (@arg.appFunNm,@arg.appFunPP,@arg.appArgPPL,@arg.pp)
  | Rec         lhs     .   appArgPPL   :=  reverse @recPatExpr.ppL
                        .   appFunPP    :=  @recPatExpr.pp

ATTR AGItf [ | | topTyPP: PP_Doc ]

SEM AGItf
  | AGItf       lhs     .   topTyPP     =   ppTy @expr.ty

SEM AGItf
  | AGItf       lhs     .   topTyPP     :=  ppTy (tyQuantifyClosed @expr.ty)

