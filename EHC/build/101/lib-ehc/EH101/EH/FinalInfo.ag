ATTR
  AllDecl
  AllExpr AllPatExpr AllCase
    [ finValGam: ValGam | | ]

SEM Expr
  | Let         loc         .   finValGamDecls      :=  @quValGam_ex_subst

SEM Expr
  | Let
                loc         .   finValGam           =   (if @lhs.isFirstLet then gamUnion @gathValGam else id) @lhs.finValGam

SEM AGItf
  | AGItf       loc
                            .   finValGam           =   @expr.gathValGam `gamUnion` @lhs.valGam

ATTR AllNT [ finTyVarMp: VarMp | | ]

SEM AGItf
  | AGItf       loc         .   finTyVarMp          =
                                                        @chrSolveSimpTyVarMp `varUpd`
                                                        @expr.tyVarMp

SEM Expr
  | Let         loc         .   finTyVarMp          =   varUpd @tmpoTyVarMp $
                                                        @lhs.finTyVarMp

SEM Decl
  | TySig       loc         .   finalTy             =   maybe (acoreTyErr "EH.FinalInfo.Decl.TySig.finalTy")    vgiTy $ valGamLookup @nm            @lhs.finValGam
  | Val         loc         .   finalTy             =   maybe (acoreTyErr "EH.FinalInfo.Decl.Val.finalTy")      vgiTy $ valGamLookup @patExpr.topNm @lhs.finValGam
  | Instance    loc         .   finalTy             =   maybe (acoreTyErr "EH.FinalInfo.Decl.Instance.finalTy") vgiTy $ valGamLookup @dictNm        @lhs.finValGam

SEM Decl
  | FusionConv  loc         .   finConTy            =   maybe (acoreTyErr $ "EH.FinalInfo.Decl.FusionConv.finConTy: " ++ show @conNm) vgiTy $ valGamLookup @conNm @lhs.finValGam
                            .   finAbsTy            =   maybe (acoreTyErr $ "EH.FinalInfo.Decl.FusionConv.finAbsTy: " ++ show @absNm) vgiTy $ valGamLookup @absNm @lhs.finValGam

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable Bang
    -- Expr
                loc         .   finalTy             =   @lhs.finTyVarMp `varUpd` @ty

SEM DataConstr
  | Constr      loc         .   finDataConTy        =   @lhs.finTyVarMp `varUpd` @dataConTyAsVar

SEM PatExpr
  | AppTop Con
    Rec
                loc         .   finKnPatTy          =   @lhs.finTyVarMp `varUpd` @knPatTy

SEM Expr
  | AppTop      loc         .   finalTy             =   @lhs.finTyVarMp `varUpd` @ty
  | Case        loc         .   finalTyExpr         =   @lhs.finTyVarMp `varUpd` @expr.ty
  | Lam
    LamImpl
                loc         .   finalTyArg          =   @lhs.finTyVarMp `varUpd` @arg.ty

SEM DataFieldExpr
  | Upd         loc         .   finalTyExpr         =   @lhs.finTyVarMp `varUpd` @expr.ty

SEM Expr
  | AppTop      loc         .   finalTyExpanded     =   tyCanonicFFI (emptyTyBetaRedEnv' @fe) @finalTy
  | Case        loc         .   finalTyExprExpanded =   tyCanonicFFI (emptyTyBetaRedEnv' @fe) @finalTyExpr
  | Lam
    LamImpl
                loc         .   finalTyArgExpanded  =   tyCanonicFFI (emptyTyBetaRedEnv' @fe) @finalTyArg

SEM DataFieldExpr
  | Upd         loc         .   finalTyExprExpanded =   tyCanonicFFI (emptyTyBetaRedEnv' @fe) @finalTyExpr

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable Bang
    -- Expr
                loc         .   finalTyExpanded     =   tyCanonicFFI (emptyTyBetaRedEnv' @fe) @finalTy

SEM Decl
  | Val         loc         .   finalTyExpanded     =   tyCanonicFFI (emptyTyBetaRedEnv' @fe) @finalTy
  | FFI
    FFE
                loc         .   finalTyExpanded     =   tyCanonicFFI' True (emptyTyBetaRedEnv' @fe) @ty_sig_

SEM Decl
  | Instance    loc         .   finalHdInstArgLExpanded
                                                    =   map (tyCanonic (emptyTyBetaRedEnv' @fe)) @instArgTyL

ATTR AllNT [ finKiVarMp: VarMp | | ]

SEM AGItf
  | AGItf       expr        .   finKiVarMp          =   @expr.kiVarMp

ATTR AllNT [ finTyKiGam: TyKiGam |  | ]

SEM AGItf
  | AGItf       expr        .   finTyKiGam          =   emptyGam

SEM Expr
  | Let         loc         .   finTyKiGam          =   @lhs.finKiVarMp `varUpd` @tyKiGam_l_ `gamUnion` @lhs.finTyKiGam


