{
gamErrToL :: Range -> Gam HsName ErrL -> ErrL
gamErrToL r = concat . map (\(n,e) -> mkNestErr r (pp n) e) . gamToAssocL

}
{
ppErrsSq :: ErrSq -> PP_Doc
ppErrsSq = ppErrs . Seq.toList

}
ATTR AllNT [ | | errSq USE {`Seq.union`} {Seq.empty} : ErrSq ]

SEM AGItf
  | AGItf       loc         .   lErrSq      =   Seq.empty

SEM Expr
  | Let         loc         .   letErrL     =   Seq.empty

SEM Expr
  | Let         loc         .   letErrL     :=  Seq.fromList @dupErrs
  | App         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [@func.errSq, @arg.errSq]
  | Lam         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_fitF_, @arg.errSq, @body.errSq]
  | TypeAs      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [@expr.errSq, @tyExpr.errSq, foErrSq @fo_]
  | Var         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs, foErrSq @fo_]
  | IConst CConst
                lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]
  | AppTop      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [@expr.errSq]

SEM TyExpr
  | Con         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs]

SEM PatExpr
  | IConst CConst
                lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]

SEM PatExpr
  | AppTop      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @patExpr.errSq
                                                                              , Seq.fromList @arityErrs
                                                                              ]

SEM Decl
  | Val         lhs         .   errSq       =   Seq.unions [ @patExpr.errSq, @expr.errSq
                                                           , Seq.fromList @sigMissErrs
                                                           ]

SEM Expr
  | Con         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]

SEM PatExpr
  | AppTop      lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [ @patExpr.errSq
                                                                              , Seq.fromList @arityErrs, foErrSq @fo_fitR_
                                                                              ]

SEM Decl
  | Val         lhs         .   errSq       :=  Seq.unions [@patExpr.errSq, @expr.errSq]

SEM Expr
  | Con         lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs, foErrSq @fo_]
  | Let         loc         .   letErrL     :=  Seq.unions [ Seq.fromList @dupErrs, Seq.fromList @occCycTyErrs ]

SEM PatExpr
  | TypeAs      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @patExpr.errSq, @tyExpr.errSq
                                                                              , foErrSq @fo_
                                                                              ]
  | Con         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs, foErrSq @fo_fitR_]
  | AppTop      lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [@patExpr.errSq, Seq.fromList @arityErrs, foErrSq @fo_fitR_]

SEM PatExpr
  | IConst CConst
                lhs         .   errSq       :=  Seq.empty

SEM Expr
  | SConst      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]
  | TypeAs      lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [ @expr.errSq, @tyExpr.errSq, foErrSq @fo_, foErrSq @fo_fitDown
                                                                              ]

SEM Expr
  | Let         loc         .   letErrL     :=  Seq.unions [ Seq.fromList @dupErrs, Seq.fromList @occCycTyErrs, Seq.fromList @occCycTyKiErrs ]

SEM TyExpr
  | Con         lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [Seq.fromList $ firstNotEmpty [@nmErrs,@nmErrs2]]

SEM KiExpr
  | Con         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs]

SEM TyExpr
  | App         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @func.errSq, @arg.errSq
                                                                              , foErrSq @fo_
                                                                              ]
  | AppTop      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [@tyExpr.errSq]

SEM Decl
  | TySig       lhs         .   errSq       =   rngLift @range mkNestErr' @tyExpr.pp [ @tyExpr.errSq
                                                                                     , foErrSq @fo_
                                                                                     ]
  | Data        lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @tyVars.errSq, @constrs.errSq
                                                                              , foErrSq @fo_
                                                                              , Seq.fromList @inconsistFldErrs
                                                                              ]

SEM DataConstr
  | Constr      lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @fields.errSq
                                                                              , @mbGadtTyExpr.errSq
                                                                              , Seq.fromList @dupErrs
                                                                              , foErrSq @fo_
                                                                              , maybe Seq.empty foErrSq @mbGadtFO
                                                                              ]

SEM RecExpr
  | Empty       lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]

SEM RecPatExpr
  | Empty       lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]

SEM DataFieldPatExpr
  | Con         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs, foErrSq @fo_]

SEM DataFieldExpr
  | Con         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [Seq.fromList @nmErrs, foErrSq @fo_]

SEM PatExpr
  | Rec         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [@recPatExpr.errSq]

SEM RecPatExpr
  | Ext         lhs         .   errSq       =   Seq.unions [ @recPatExpr.errSq
                                                           , rngLift @range mkNestErr' @pp [@patExpr.errSq, foErrSq @fo_]
                                                           ]

SEM DataFieldPatExpr
  | Ext         lhs         .   errSq       =   Seq.unions [ @dataFieldPatExpr.errSq
                                                           , rngLift @range mkNestErr' @pp [@patExpr.errSq, Seq.fromList @nmErrs, foErrSq @fo_]
                                                           ]

SEM Expr
  | Rec         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @recExpr.errSq
                                                                              , foErrSq @fo_
                                                                              ]
  | DataFields  lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @dataFieldExpr.errSq
                                                                              , Seq.fromList @fldMissErrs, Seq.fromList @fldDupErrs, Seq.fromList @dfErrs
                                                                              ]

SEM RecExpr
  | Ext Upd     lhs         .   errSq       =   Seq.unions [ @recExpr.errSq
                                                           , rngLift @range mkNestErr' @pp [@expr.errSq, foErrSq @foKnRec]
                                                           ]

SEM DataFieldExpr
  | Upd         lhs         .   errSq       =   Seq.unions [ @dataFieldExpr.errSq
                                                           , rngLift @range mkNestErr' @pp [@expr.errSq, Seq.fromList @nmErrs, foErrSq @fo_]
                                                           ]


SEM AGItf
  | AGItf       loc         .   lErrSq      :=  Seq.unions [ Seq.fromList @predNotPrfErrs
                                                           , Seq.fromList @chrSolveMainErrs
                                                           , Seq.fromList @nmErrs
                                                           , foErrSq @foMain
                                                           ]

SEM Expr
  | Let         loc         .   letErrL     :=  Seq.unions [ Seq.fromList @dupErrs, Seq.fromList @occCycTyErrs, Seq.fromList @occCycTyKiErrs
                                                           , Seq.unions $ map Seq.fromList [@predNotPrfErrs, @predAmbigErrs, firstNotEmpty [@chrSolve1Errs, @chrSolve2Errs]]
                                                           , @loc.cycErrSq
                                                           , Seq.fromList @errsDataGenerBind
                                                           ]
  | Lam         lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [foErrSq @fo_fitF_, @arg.errSq, @body.errSq]
  | AppTop      lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [@expr.errSq]

SEM RowTyExpr
  | Var         lhs         .   errSq       =   rngLift @range mkNestErr' @pp [foErrSq @fo_]

SEM Decl
  | Instance    loc         .   lErrSq      =   Seq.firstNotEmpty
                                                  [ Seq.unions [
                                                                 case @instVariant of
                                                                   InstDeriving InstDerivingFrom_Datatype
                                                                     -> Seq.empty           -- ignore kind errors when deriving
                                                                   _ -> @tyPrExpr.errSq
                                                               , Seq.fromList @valNoSigErrs
                                                               ]
                                                  , Seq.unions $ map Seq.fromList [@cxSplitErrs, @derivErrs]
                                                  , foErrSq @foGenerDeriv
                                                  , Seq.unions $ map Seq.fromList [@predNotPrfErrs, @chrSolveSuperErrs, @chrSolveDeclsErrs]
                                                  ]
  | InstanceIntro
                loc         .   lErrSq      =   Seq.unions [ @expr.errSq, @prExpr.errSq
                                                           , foErrSq @foPr, Seq.fromList @predErrs
                                                           ]

SEM PrExpr
  | Class       lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @tyExprs.errSq
                                                                              , Seq.fromList $ firstNotEmpty [@nmErrs,@clKiNmErrs], foErrSq @fo_
                                                                              ]

SEM Decl
  | Type        lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @tyExpr.errSq
                                                                              , foErrSq @foTy_, foErrSq @foKi_
                                                                              ]

SEM Expr
  | AppImpl     lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @func.errSq, @arg.errSq, @argPr.errSq
                                                                              , Seq.fromList @nmErrs, foErrSq @foPr
                                                                              ]
  | LamImpl     lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @arg.errSq, @argPr.errSq, @body.errSq
                                                                              , Seq.fromList @nmErrs, foErrSq @fo_fitF_, foErrSq @foPr
                                                                              ]

SEM PatExpr
  | Expr        lhs         .   errSq       =   rngLift @range mkNestErr' @pp [ @expr.errSq
                                                                              , Seq.fromList @nmErrs, foErrSq @fo_
                                                                              ]

SEM Decl
  | Type        lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [ @tyExpr.errSq, foErrSq @foKi_, foErrSq @foPol]

SEM TyExpr
  | Con         lhs         .   errSq       :=  rngLift @range mkNestErr' @pp [Seq.fromList $ firstNotEmpty [@nmErrs,@nmErrs2,@nmPolErrs], foErrSq @loc.foPol]

SEM TyExpr
  | Var         lhs         .   errSq        =  rngLift @range mkNestErr' @pp [foErrSq @loc.foPol]

SEM Decl
  | FFI         lhs         .   errSq        =  rngLift @range mkNestErr' @pp [foErrSq @foFFI]

SEM Decl
  | FusionConv  lhs         .   errSq        =  rngLift @range mkNestErr' @pp [foErrSq @foBuildInverse]

SEM Decls
  | Cons        loc         .   errPP       =   ppErrsSq @hd.errSq
                lhs         .   errSq       =   Seq.empty

SEM Expr
  | Let         loc         .   errLetPP    =   ppErrsSq @letErrL
                            .   errBodyPP   =   ppErrsSq @body.errSq
                lhs         .   errSq       =   Seq.empty

SEM AGItf
  | AGItf       loc         .   errTopPP    =   ppErrsSq @lErrSq

SEM Decl
  | Instance    loc         .   errInstPP   =   ppErrsSq @lErrSq
                            .   errDeclsPP  =   ppErrsSq @decls.errSq
                lhs         .   errSq       =   Seq.empty
  | InstanceIntro
                loc         .   errInstPP   =   ppErrsSq @lErrSq
                lhs         .   errSq       =   Seq.empty

ATTR AllNT AGItf [ | | allErrSq USE {`Seq.union`} {Seq.empty} : ErrSq ]

SEM Decls
  | Cons        lhs         .   allErrSq    =   Seq.unions [@hd.errSq, @hd.allErrSq, @tl.allErrSq]

SEM Expr
  | Let         lhs         .   allErrSq    =   ehcOptTrace @lhs.opts "Expr.Let.lhs.allErrSq" $
                                                Seq.unions [@letErrL, @body.errSq, @decls.allErrSq, @body.allErrSq]

SEM Decl
  | Instance    lhs         .   allErrSq    =   Seq.unions [@lErrSq, @decls.allErrSq]
  | InstanceIntro
                lhs         .   allErrSq    =   @lErrSq

SEM AGItf
  | AGItf       lhs         .   allErrSq    =   Seq.unions [@lErrSq, @expr.allErrSq]

