ATTR NTPrf [ chrStore: ScopedPredStore | | ]

ATTR AGItf [ chrStore: ScopedPredStore | | gathChrStore: ScopedPredStore ]

SEM AGItf
  | AGItf       loc         .   initChrStore        =   @lhs.chrStore

SEM AGItf
  | AGItf       loc         .   (instsOuter,instsInner)
                                                    =   partition (\(_,_,_,sc) -> sc == initPredScope) $ Seq.toList @expr.chrInstDeclSq
                            .   (chrStoreOuterScope,gathChrStore)
                                                    =   mkScopedCHR2 @chrFIIn (Seq.toList @expr.chrClassDeclSq) @instsOuter @initChrStore
                            .   (chrStore,_)        =   mkScopedCHR2 @chrFIIn [] @instsInner @chrStoreOuterScope

ATTR NTPrf [ predScope: PredScope | | ]

SEM AGItf
  | AGItf       loc         .   predScope           =   initPredScope

SEM Expr
  | AppTop      loc         .   predScope           =   pscpMk' @mustEnterNewPredScope @lhs.predSameScopeCounter @lhs.predScope
                (loc.predSameScopeCounterTop,expr.predSameScopeCounter)
                                                    =   pscpEnter' @mustEnterNewPredScope @lhs.predSameScopeCounter
                lhs         .   predSameScopeCounter
                                                    =   pscpLeave' @mustEnterNewPredScope @predSameScopeCounterTop @expr.predSameScopeCounter
  | Rec         loc         .   predScope           =   pscpMk' @mustEnterNewPredScope @lhs.predSameScopeCounter @lhs.predScope
                (loc.predSameScopeCounterTop,recExpr.predSameScopeCounter)
                                                    =   pscpEnter' @mustEnterNewPredScope @lhs.predSameScopeCounter
                lhs         .   predSameScopeCounter
                                                    =   pscpLeave' @mustEnterNewPredScope @predSameScopeCounterTop @recExpr.predSameScopeCounter
  | Lam
    LamImpl
                loc         .   predScope           =   pscpMk' @mustEnterNewPredScope @lhs.predSameScopeCounter @lhs.predScope
                (loc.predSameScopeCounterLam,body.predSameScopeCounter)
                                                    =   pscpEnter' @mustEnterNewPredScope @lhs.predSameScopeCounter
                lhs         .   predSameScopeCounter
                                                    =   pscpLeave' @mustEnterNewPredScope @predSameScopeCounterLam @body.predSameScopeCounter
  | Lam
  | * - Lam AppTop Rec Let {- -}
    LamImpl
                loc         .   predScope           =   @lhs.predScope

SEM Expr
  | AppTop Rec
                loc         .   mustEnterNewPredScope
                                                    =   False -- not @implsIsEmpty -- True -- False -- not @implsIsEmpty -- not (null @knPrL) -- otherwise AG depends on @lhs.knTy, creating a cycle
  | Lam         loc         .   mustEnterNewPredScope
                                                    =   True -- otherwise AG depends on @lhs.knTy, creating a cycle
  | LamImpl     loc         .   mustEnterNewPredScope
                                                    =   True

ATTR
  AllCase AllExpr AllDecl
  AllPatExpr
    [ | predSameScopeCounter: Int | ]

SEM AGItf
  | AGItf       loc         .   predSameScopeCounter
                                                    =   0

SEM Expr
  | Let         loc         .   mustEnterNewPredScope
                                                    =   not @lexLevIsGlobal && @lhs.isFirstLet && @hasInstDecl
                loc         .   predScope           =   pscpMk' @mustEnterNewPredScope @lhs.predSameScopeCounter @lhs.predScope
                (loc.predSameScopeCounterLet,decls.predSameScopeCounter)
                                                    =   pscpEnter' @mustEnterNewPredScope @lhs.predSameScopeCounter
                lhs         .   predSameScopeCounter
                                                    =   pscpLeave' @mustEnterNewPredScope @predSameScopeCounterLet @body.predSameScopeCounter

SEM Decl
  | Val         expr        .   predSameScopeCounter
                                                    =   0
  | Class Instance
                decls       .   predSameScopeCounter
                                                    =   0

SEM Decl
  | Val Class Instance
                lhs         .   predSameScopeCounter
                                                    =   @lhs.predSameScopeCounter+1
                loc         .   predScope           :=  snd $ pscpEnter @lhs.predSameScopeCounter @lhs.predScope


{
type ScopeGam = Gam HsName PredScope

}
ATTR AllDecl AllPatExpr [ | | scopeGam USE {`gamUnion`} {emptyGam}: ScopeGam ]

SEM PatExpr
  | Var         lhs         .   scopeGam            =   gamSingleton @nm @lhs.predScope

SEM AGItf
  | AGItf       loc         .   chrFIIn             =   @expr.chrFIIn {fiUniq = @lUniq}
                loc         .   lUniq               :   UNIQUEREF gUniq

SEM Decl
  | Instance    loc         .   chrFIIn             =   emptyFI {fiEnv = @fe} :: FIIn

ATTR Expr [ | | chrFIIn: FIIn ]

SEM Expr
  | Let         loc         .   chrFIIn             =   @body.chrFIIn
  | * - Let     loc         .   chrFIIn             =   emptyFI {fiEnv = @fe} :: FIIn

ATTR AllDecl Expr [ | | chrClassDeclSq USE {`Seq.union`} {Seq.empty}: {Seq.FastSeq (CHRClassDecl Pred RedHowAnnotation)} ]

SEM Decl
  | Class       loc         .   chrClassDecl        =   let off n = tyRecOffset n @clsTyRec
                                                            {-
                                                            (cxt,hdt) = tyArrowArgsRes $ tyMetaTyVars @lUniq_9_prTyMeta @tyPrExpr.ty
                                                            cx = map tyPred cxt
                                                            hd = tyPred hdt
                                                            -}
                                                        in  ( {- cx -- -} map tyPred @ctxtPrTyL
                                                            , {- hd -- -} tyPred     @hdPrTy
                                                            , zipWith (\p n -> RedHow_BySuperClass n (off n) @dictTag) {- cx -} @ctxtPrTyL @supClsFldNmL
                                                            )
                loc         .   lUniq_9_prTyMeta    :   UNIQUEREF gUniq
                lhs         .   chrClassDeclSq      =   Seq.singleton @chrClassDecl

SEM Expr
  | Let         loc         .   chrClassDeclSq      =   ehcOptTrace @lhs.opts "Expr.Let.loc.chrClassDeclSq" $
                                                        @decls.chrClassDeclSq `Seq.union` @body.chrClassDeclSq
  | * - Let     lhs         .   chrClassDeclSq      =   Seq.empty

ATTR NTCode [ | | chrInstDeclSq USE {`Seq.union`} {Seq.empty}: {Seq.FastSeq (CHRScopedInstanceDecl Pred RedHowAnnotation PredScope)} ]

SEM Decl
  | Instance    loc         .   chrInstDecl         =   let cx = @unfixPrTyVarMp `varUpd` @ctxtPrTyFixL
                                                            hd = @unfixPrTyVarMp `varUpd` @hdPrTyFix
                                                            hdPr = tyPred hd
                                                        in  ( map tyPred cx
                                                            , hdPr
                                                            , RedHow_ByInstance @dictNm hdPr @lhs.predScope
                                                            , @lhs.predScope
                                                            )
                lhs         .   chrInstDeclSq       =   if @inclForElim then Seq.singleton @chrInstDecl else Seq.empty
  | InstanceIntro
                loc         .   chrInstDecl         =   let pr = tyPred $ tyMetaTyVars @lUniq_9_prTyMeta @prExpr.ty
                                                        in  ( []
                                                            , pr
                                                            , RedHow_ByInstance @dictNm pr @lhs.predScope
                                                            , @lhs.predScope
                                                            )
                loc         .   lUniq_9_prTyMeta    :   UNIQUEREF gUniq
                lhs         .   chrInstDeclSq       =   Seq.singleton @chrInstDecl

SEM Expr
  | Let         lhs         .   chrInstDeclSq       =   ehcOptTrace @lhs.opts "Expr.Let.lhs.chrInstDeclSq" $
                                                        Seq.unions [Seq.fromList @generInstDeclL, @decls.chrInstDeclSq, @body.chrInstDeclSq]
