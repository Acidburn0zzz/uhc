SEM AGItf
  | AGItf       loc         .   mainUseExists
                                            =   case acoreExprMbVar @expr.letCBody of
                                                  Just n | n == hsnMain -> True
                                                  _                     -> False
                            .   insertMainUse
                                            =   not @mainUseExists

SEM AGItf
  | AGItf       loc         .   insertMainUse
                                            :=  not @mainUseExists && @lhs.isMainMod

SEM AGItf
  | AGItf       loc         .   mainDefExists
                                            =   let ds = [ b | (_,g) <- @expr.letCBindL, b <- g, cbindNm b == hsnMain ]
                                                in  not (null ds)
                            .   insertMainDef
                                            =   not @mainDefExists

SEM AGItf
  | AGItf       loc         .   insertMainDef
                                            :=  not @mainDefExists && @lhs.isMainMod

ATTR AGItf [ | | cmodule: CModule ]

SEM AGItf
  | AGItf       lhs         .   cmodule     =   let b = if @insertMainUse then acoreVar hsnMain else @expr.letCBody
                                                    d = if @insertMainDef then acoreLet CBindCateg_Plain [acoreBind1Ty hsnMain (acoreTyErr $ "EH.ToCore.AGItf.main") @expr.letCBody] else id
                                                in  CModule_Mod @lhs.moduleNm
                                                        (
                                                           cSubstAppExpr True @expr.cSubst
                                                           (foldr (\(c,b) e -> acoreLet c b e)
                                                             (d b)
                                                             (@extraCBindL ++ @expr.frontCBindL ++ @expr.letCBindL
                                                             ++ @expr.backCBindL
                                                             )
                                                           )
                                                           Nothing
                                                        )
                                                        [ (tn,Map.toList m) | (tn,dgi) <- gamToAssocL @expr.gathDataGam, not (dgiIsNewtype dgi), let m = Map.map dtiCTag $ dgiConstrTagMp dgi ]
                loc         .   extraCBindL =   []

SEM AGItf
  | AGItf       loc         .   extraCBindL :=  [(CBindCateg_Rec,@chrScopeMainBindL)]

SEM Expr
  | IConst CConst SConst Var Con
    App AppImpred AppTop Rec TypeAs
    Lam Let
    AppImpl
    LamImpl
    IIConst
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq

SEM PatExpr
  | Expr        loc         .   lUniq_cexpr :   UNIQUEREF gUniq

ATTR Expr [ | | cexpr: CExpr ]

SEM Expr
  | Ann         loc         .   cexpr       =   @expr.cexpr
  | Let         loc         .   frontCBindL =   [(if True {- ehcOptPriv @lhs.opts -} then CBindCateg_Plain else CBindCateg_FFI,@decls.ffiCBindL)]
                            .   backCBindL  =   [(CBindCateg_FFE,@decls.ffeCBindL)]
                            .   howToBind   =   if @isStrict then CBindCateg_Strict else CBindCateg_Rec
                            .   letCBindL   =   [( @howToBind
                                                 , @cDataBindL
                                                   ++ @cDataGenerBindL
                                                   ++ @decls.cbindL
                                                 )]
                            .   letCBindOtherL
                                            =   []
                            .	mkBangEval	=	\e -> foldr ($) e @decls.bangEvalL
                            .   cexprtop    =   ehcOptTrace @lhs.opts "Expr.Let.lhs.cexprtop" $
                                                foldr (\(c,b) e -> acoreLet c b e)
                                                      (@mkBangEval @letCBody)
                                                      @letCBindRemL
  | App AppImpred
    AppImpl
                loc         .   cexprapp    =   acoreApp1 @func.cexpr @arg.cexpr
                            .   cexpr       =   if @func.isNewtype then @arg.cexpr else @cexprapp
  | Lam         loc         .   cexpr       =   acoreLam1 @arg.topNm
                                                    (rceMatchTy @rceEnv [(@arg.topNm,@finalTyArgExpanded)] [RAlt_Alt [@arg.rpat] @body.cexpr @body.caseFailS])
  | Case        loc         .   cexpr       =   let (ns,bs,as)
                                                      = if @isTupOfArg
                                                        then let ns = [ acbrefNm ref | (CExpr_Var ref) <- fuL2ExprL (reverse @expr.fuCExprL) ]
                                                             in  (zip ns (tyProdArgs @finalTyExprExpanded),[],@alts.raltL')
                                                        else let n = uidHNm @lUniq2
                                                             in  ([(n,@finalTyExprExpanded)],[acoreBind1Ty n @finalTyExprExpanded @expr.cexpr],@alts.raltL)
                                                in  acoreLet CBindCateg_Plain bs (rceMatchTy @rceEnv ns as)
  | AppTop      loc         .   cexprtop    =   @expr.cexpr
  | Rec         loc         .   cexprtop    =   @rcexpr
  | Parens TypeAs
                loc         .   cexpr       =   @expr.cexpr
  | AppTop Rec Let
                loc         .   cexpr       =   @cexprtop
  | Undefined   loc         .   cexpr       =   acoreBuiltinUndefined @lhs.opts
  | CaseAltFail loc         .   cexpr       =   CExpr_CaseAltFail (CaseAltFailReason_Continue @caseId) (acoreBuiltinError @lhs.opts ("FAIL " ++ show @caseId))

SEM Expr
  | IConst      loc         .   cexprBase   =   acoreInt @int
  | CConst      loc         .   cexprBase   =   CExpr_Char @char
  | SConst      loc         .   cexprBase   =   acoreBuiltinString @lhs.opts @str
  | IIConst     loc         .   cexprBase   =   acoreBuiltinInteger @lhs.opts @integer
  | Var Con     loc         .   cexprBase   =   acoreVar @nm

SEM Expr
  | IConst CConst SConst Var Con
    IIConst
                loc         .   (cexpr,cexprCSubst)
                                            =   foAppLRCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @lhs.cSubst @cexprBase
                lhs         .   cSubst      =   cSubstApp @lhs.cSubst @cexprCSubst

{
mkWeaveExpr :: EHCOpts -> UID -> VarMp -> CSubst -> (CExpr->CExpr) -> CExpr -> [Coe] -> [Coe] -> (CExpr,CSubst)
mkWeaveExpr opts uniq finTyVarMp csubst postmk expr lCoeL rCoeL
  = (postmk e, s1 `cSubstApp` s2)
  where (_,u1,u2) = mkNewLevUID2 uniq
        (ww,s1)   = coeWipeWeaveAsSubst2 opts u1 finTyVarMp csubst lCoeL rCoeL
        (e ,s2)   = coeEvalOnAsSubst u2 ww expr

}
SEM Expr
  | Let         loc         .   letCBindOtherL
                                            :=  [ (CBindCateg_Rec,@chrScopeBindL) ]
  | App AppImpred
    AppImpl
                loc         .   (cexprapp,cexprappCSubst)
                                            :=  mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @arg.cSubst (flip acoreApp1 @arg.cexpr) @func.cexpr @appImplsCoeL []
                lhs         .   cSubst      =   cSubstApp @arg.cSubst @cexprappCSubst
  | Lam
    LamImpl
                loc         .   (cexpr,cexprlamCSubst)
                                            :=  mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @body.cSubst id @body.appFunCExpr @lamBodyCoeL @lamArgCoeL
                lhs         .   cSubst      =   cSubstApp @body.cSubst @cexprlamCSubst
  | AppTop      loc         .   cSubstTop   =   @expr.cSubst
  | Rec         loc         .   cSubstTop   =   @recExpr.cSubst
  | Let         loc         .   cSubstTop   =   @body.cSubst
  | AppTop Rec Let
                loc         .   (cexpr,cexprapptopCSubst)
                                            :=  mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @cSubstTop @cann @cexprtop [] @lamArgCoeL
  | AppTop      lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprapptopCSubst
  | Rec         lhs         .   cSubst      =   cSubstApp @recExpr.cSubst @cexprapptopCSubst
  | Let         lhs         .   cSubst      =   cSubstApp @body.cSubst @cexprapptopCSubst
  | TypeAs      loc         .   (cexpr,cexprtypeasCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (e1,s1)   = foAppLRCoeAsSubst @lhs.opts u1 @fo_fitDown @lhs.finTyVarMp @expr.cSubst @expr.cexpr
                                                    (e2,s2)   = foAppLRCoeAsSubst @lhs.opts u2 @fo_        @lhs.finTyVarMp @expr.cSubst e1
                                                in  (e2, s1 `cSubstApp` s2)
                lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprtypeasCSubst

SEM Expr
  | DynVar      loc         .   cexpr       =   acoreBuiltinUndefined @lhs.opts

SEM PatExpr
  | Expr        loc         .   cexprBaseEq =   acoreVar @eqFldNm
                            .   (cexpr,cexprpatCSubst)
                                            =   let (e,s) = foAppLRCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @expr.cSubst @cexprBaseEq
                                                in  (acoreApp e [@expr.cexpr], s)
                lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprpatCSubst

SEM Expr
  | AppTop      loc         .   cann        =   CExpr_Ann (CExprAnn_Ty @finalTyExpanded)
  | * - AppTop  loc         .   cann        =   id

SEM Expr
  | Rec         loc         .   rcexpr          =
                                                    if  not (@recExpr.isExtFromEmpty)
                                                    then  fuMkCExpr @lhs.opts @lUniq3 (reverse @recExpr.fuCExprL) @recExpr.recCExpr
                                                    else
                                                          foldl acoreApp1 (CExpr_Tup CTagRec)
                                                            $ fuL2ExprL $ tyRowCanonOrder $ @recExpr.fuCExprL
                loc         .   lUniq3          :   UNIQUEREF gUniq

ATTR RecExpr [ | | recCExpr: CExpr ]
ATTR RecExpr Expr [ | | fuCExprL: {FieldUpdateL CExpr} ]

SEM RecExpr
  | Empty       loc         .   recCExpr        =   CExpr_Tup CTagRec
                lhs         .   fuCExprL        =   []
  | Expr        loc         .   recCExpr        =   @expr.cexpr
                lhs         .   fuCExprL        =   []
  | Ext         loc         .   rcexpr          =   CExpr_TupIns @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Upd         loc         .   rcexpr          =   CExpr_TupUpd @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Ext Upd     lhs         .   fuCExprL        =   if @knRecHasLab
                                                    then (@nm,(@rcexpr,Nothing)) : @recExpr.fuCExprL
                                                    else @recExpr.fuCExprL

SEM Expr
  | * - Rec     lhs         .   fuCExprL        =   []

ATTR RecExpr [ | | isExtFromEmpty: Bool ]

SEM RecExpr
  | Empty       lhs         .   isExtFromEmpty  =   True
  | Expr        lhs         .   isExtFromEmpty  =   False
  | Upd         lhs         .   isExtFromEmpty  =   not @knRecHasLab && @recExpr.isExtFromEmpty
  | Ext         lhs         .   isExtFromEmpty  =   @recExpr.isExtFromEmpty

SEM RecExpr
  | Ext Upd     loc         .   offset          =   acoreInt (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recExpr.ty)

SEM RecExpr
  | Ext Upd     loc         .   offset          :=  cSubstApp @expr.cSubst $ acoreNmHolePred @prUid

SEM Expr
  | DataFields  loc         .   dfexpr      =   let mkTup dti mkDflt con
                                                      = foldl acoreApp1 con
                                                        . fuL2ExprL
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr" ("arity" >#< length dflt) v)
                                                        . listSaturateWith 0 (ctagArity (dtiCTag dti) - 1) (\(_,(_,Just o)) -> o) dflt
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr2" ("arity" >#< length dflt) v)
                                                        . fuMap (\l mke -> let o = dtiOffsetOfFld l dti in (mke dti o,o))
                                                      where dflt = [ (o,(f,(CExpr_TupIns (acoreBuiltinUndefined @lhs.opts) (dtiCTag dti) f (acoreInt o) (mkDflt f),Just o)))
                                                                   | (f,i) <- Map.toList $ dtiFldMp dti, let o = dfiOffset i
                                                                   ]
                                                in  if dgiIsNewtype @dgi
                                                    then acoreLet CBindCateg_Plain @dataFieldExpr.dfeCBindL
                                                         $ head $ fuL2ExprL $ fuMap (\_ f -> (f emptyDataTagInfo 0,0)) $ @dataFieldExpr.fuCExprL
                                                    else case @dataFieldExpr.mbConNm of
                                                           Just conNm
                                                             -> acoreLet CBindCateg_Plain @dataFieldExpr.dfeCBindL
                                                                  (mkTup (dgiDtiOfCon conNm @dgi) (const $ acoreBuiltinUndefined @lhs.opts) @dataFieldExpr.dfeCExpr @dataFieldExpr.fuCExprL)
                                                           _ -> acoreLet CBindCateg_Plain (err ++  @dataFieldExpr.dfeCBindL)
                                                                  (acoreSatSelsCasesTy (rceUpdEnv (acoreVar en) @rceEnv) (Just (mkHNm @lUniq,(acoreTyErr $ "EH.ToCore.Expr.DataFields: " ++ show (mkHNm @lUniq)))) @dataFieldExpr.dfeCExpr alts)
                                                             where alts = [ ( dtiCTag dti
                                                                            , [ (f,{-f,-}dfiOffset i) | (f,i) <- Map.toList $ dtiFldMp dti ]
                                                                            , Nothing
                                                                            , mkTup dti acoreVar (CExpr_Tup $ dtiCTag dti) @dataFieldExpr.fuCExprL
                                                                            )
                                                                          | dti <- @dtiInFldL
                                                                          ]
                                                                   err = [acoreBind1Ty en (acoreTyErr $ "EH.ToCore.Expr.DataFields.en: " ++ show en) (acoreBuiltinError @lhs.opts ("has no field update '" ++ show @fldL ++ "'"))]
                                                                   en = mkHNm "_upd_error"
                            .   cexpr       =   @dfexpr

ATTR
  DataFieldExpr
    [ | | dfeCExpr: CExpr
          dfeCBindL: CBindL
          fuCExprL: {FieldUpdateL (DataTagInfo -> Int -> CExpr)}
    ]

SEM DataFieldExpr
  | Upd         loc         .   fldExprNm   =   mkHNm @lUniq
                lhs         .   fuCExprL    =   let mke dti o = CExpr_TupIns @dataFieldExpr.dfeCExpr (dtiCTag dti) @nm (acoreInt o) (acoreVar @fldExprNm)
                                                in  (@nm,(mke,Nothing)) : @dataFieldExpr.fuCExprL
                            .   dfeCBindL   =   acoreBind1Ty @fldExprNm @finalTyExprExpanded @expr.cexpr : @dataFieldExpr.dfeCBindL
  | Con         lhs         .   dfeCExpr    =   CExpr_Tup (dtiCTag @dti)
                            .   fuCExprL    =   []
                            .   dfeCBindL   =   []
  | Expr        loc         .   dfeCExpr    =   @expr.cexpr
                            .   fuCExprL    =   []
                            .   dfeCBindL   =   []


SEM Expr
  | Sel         loc         .   offset          =   acoreInt (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @lbl @expr.ty)
                            .   cexpr           =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq_freshKnTy
                                                    -- in   mkCExprSelCase @rceEnv (Just n1) @expr.cexpr CTagRec n2 @lbl @offset Nothing
                                                    in   acoreSelCaseTy @rceEnv (Just (n1,(acoreTyErr $ "EH.ToCore.Expr.Sel.n1: " ++ show n1))) @expr.cexpr CTagRec n2 {- @lbl -} @offset Nothing

SEM Expr
  | Sel         loc         .   offset          :=  cSubstApp @expr.cSubst $ acoreNmHolePred @prUid

SEM DataConstr
  | Constr      lhs         .   cbindL      =   [] -- mkDataCBindL @lhs.opts @ctag @conNm @lhs.isNewtype

SEM Decl
  | Data        loc         .   fldSelCBindL=   let (xn1:xn2:_) = hsnLclSupply
                                                    tgSels f i = [ (t,[(f,{-f,-}o)],Nothing,acoreVar f) | (t,o) <- Map.toList $ dficInTagMp i ]
                                                    ty f = valGamLookupTyDefault f @lhs.finValGam
                                                in  if @isNewtype
                                                    then [ [ acoreBind1Ty f (ty f) (acoreVar $ ehcOptBuiltin @lhs.opts ehbnId)
                                                           | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         ] ]
                                                    else [ [ acoreBind1Ty f t
                                                               (acoreLam [xn1]
                                                                 (acoreSatSelsCasesTy (rceUpdEnv (acoreVar en) @rceEnv) (Just (xn2,fst $ tyArrowArgRes t)) (acoreVar xn1) tg))
                                                           ]
                                                           ++ (if isSaturated then [] else [ acoreBind1Ty en (acoreTyErr $ "EH.ToCore.Decl.Data.en: " ++ show en) (acoreBuiltinError @lhs.opts ("has no field selection '" ++ show f ++ "'")) ])
                                                         | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         , let en = hsnUniqifyStr HsNameUniqifier_New "datafield_sel_error" f -- hsnSuffix f "_datafield_sel_error"
                                                               tg = tgSels f i
                                                               isSaturated = length tg == Map.size (dgiConstrTagMp @dgi)
                                                               t = ty f
                                                         ]

SEM Decl
  | Data        lhs         .   cbindL      =   concat @fldSelCBindL ++ @constrs.cbindL

{
-- | Make bindings for constructors, given various bits of info
mkDataCBindL :: EHCOpts -> CTag -> Ty -> [DataConFldAnnInfo] -> HsName -> Bool -> [CBind]
mkDataCBindL opts ctag ty annL conNm isNewtype
  | isNewtype = [ acoreBind1Ty conNm ty (acoreVar $ ehcOptBuiltin opts ehbnId) ]
  | otherwise = [ acoreBind1Ty conNm ty
                    (acoreLam nms
                      (foldr (.) id mkStrict
                        (acoreApp (CExpr_Tup ctag)
                          (map acoreVar nms'
                    ) ) ) )
                ]
  where nms = (map (\i -> hsnFromString ("x" ++ show i)) [1 .. ctagArity ctag])
        (nms',mkStrict)
          = (nms, replicate (ctagArity ctag) id)
          where len = ctagArity ctag
{-
          = unzip [ if s then (n',\e -> acoreLet1StrictIn n' (acoreVar n) (const e)) else (n,id)
                  | (n,s) <- zip nms $ map ((==Strictness_Strict) . dcfaiStrictness) annL
                  , let n' = hsnUniqifyEval n
                  ]
-}

}
{
-- | Generate all bindings given functions to generate individual bindings.
mkDataBinds
  :: (Bool -> DataTagInfo -> [bind])
     -> DataGam
     -> [bind]
mkDataBinds mkCon dataGam
  = concat
      [ concat
          [ mkCon isNewtype dti
          | dti <- Map.elems constrMp
          ]
      | dgi@(DataGamInfo
              { dgiConstrTagMp  = constrMp
              }) <- gamElts dataGam
      , let isNewtype = isJust (dgiMbNewtype dgi)
      ]

}
SEM Expr
  | Let         loc         .   cDataBindL  =   mkDataBinds
                                                    (\isNewtype
                                                      (DataTagInfo
                                                        { dtiConNm      = conNm
                                                        , dtiConFldAnnL = annL
                                                        , dtiCTag       = ctag
                                                        }) -> mkDataCBindL @lhs.opts ctag (valGamLookupTyDefault conNm @finValGamDecls) annL conNm isNewtype
                                                    )
                                                    @decls.gathDeclDataGam

ATTR PatExpr [ | | isBang: Bool ]

SEM PatExpr
  | Bang		lhs			.	isBang		=	True
  | * - Bang 	lhs			.	isBang		=	False

ATTR PatExpr [ | | cpNm: RPatNm ]

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable Bang
    Expr
                loc         .   cpNm        =   maybe (RPatNmUniq @topNm) RPatNmOrig @mbTopNm
  | App         loc         .   cpNm        =   @arg.cpNm

SEM PatExpr
  | AppTop Con  loc         .   tyConNm     =   tyConNm $ fst $ tyAppFunArgs @finKnPatTy -- $ tyAppFunArgsWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @knPatTy
                            .   dgi         =   panicJust ("PatExpr.{AppTop,Con}.dgi: " ++ show @tyConNm)
                                                    $ dataGamLookup @tyConNm $ @lhs.dataGam
                            .   dti         =   panicJust ("PatExpr.{AppTop,Con}.dti: " ++ show @tyConNm ++ "." ++ show @appFunNm)
                                                    $ Map.lookup @appFunNm $ dgiConstrTagMp @dgi

SEM PatExpr
  | AppTop Con  loc         .   tag         =   dtiCTag @dti
                            .   rest        =   CPatRest_Empty
  | Rec         loc         .   tag         =   CTagRec
                            .   rest        =   @recPatExpr.patCRest
  | DataFields  loc         .   tag         =   dtiCTag @dataFieldPatExpr.dti
                            .   rest        =   @dataFieldPatExpr.patCRest

{
fsL2PatOffsetL :: FieldSplitL -> AssocL RPatFld (Maybe Int)
fsL2PatOffsetL l = [ (RPatFld_Fld n oe n p,Just oi) | (o,(foff,p)) <- zip [0..] l, let (oi,oe) = foffMkOff foff o, let n = foffLabel foff ]

}
SEM PatExpr
  | AppTop      loc         .   rpatBinds   =   fsL2PatOffsetL $ reverse                   $ @fsRPatL
  | Rec         loc         .   rpatBinds   =   fsL2PatOffsetL $ tyRowCanonOrderBy compare $ @fsRPatL
  | DataFields  loc         .   (rpatBindss,rpatBindsNonSat,rpatBind0)
                                            =   let fsL = reverse @fsRPatL
                                                    grp = groupByOn (\o1 o2 -> (foffOffset o1 `compare` foffOffset o2) /= GT) fst
                                                    max = ctagArity @tag - 1
                                                    sat = -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                          listSaturateWith 0 max (foffOffset . fst) $
                                                          -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss2" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                            (zipWith (\o n -> (o,(FldKnownOffset n o,RPat_Var (RPatNmOrig n) (acoreTyErr $ "EH.ToCore.PatExpr.DataFields: " ++ show n) False))) [0..max] hsnLclSupply)
                                                in  ( map (fsL2PatOffsetL . sat) $ grp fsL      -- groups of bindings which can be dealt with simultaneously
                                                    , fsL2PatOffsetL fsL                        -- bindings
                                                    , fsL2PatOffsetL $ sat []                   -- 0 binding
                                                    )

ATTR PatExpr [ | | rpat: RPat ]

SEM PatExpr
  | IConst      loc         .   rpat        =   RPat_Int @cpNm @finalTyExpanded (toInteger @int)
  | CConst      loc         .   rpat        =   RPat_Char @cpNm @finalTyExpanded @char
  | SConst      loc         .   rpat        =   RPat_Int @cpNm @finalTyExpanded (-1) -- for now
  | Var         loc         .   rpat        =   RPat_Var @cpNm @finalTyExpanded False
  | VarAs       loc         .   rpat        =   @patExpr.rpat {rcpPNm = @cpNm}
  | Con         loc         .   rpat        =   RPat_Con @cpNm @finalTyExpanded @tag (RPatConBind_One CPatRest_Empty [])
  | AppTop      loc         .   rpat        =   RPat_Con @cpNm @finalTyExpanded @tag (RPatConBind_One @rest (map fst @rpatBinds))
  | Rec         loc         .   rpat        =   case @rest of
                                                    CPatRest_Empty
                                                      ->  RPat_Con @cpNm @finalTyExpanded @tag (RPatConBind_One @rest (map fst @rpatBinds))
                                                    CPatRest_Var r
                                                      ->  RPat_Con @cpNm @finalTyExpanded @tag (RPatConBind_One @rest pbL)
                                                          where  pbL = map fst $ fsL2PatOffsetL $ fsLReorder @lhs.opts $ reverse $ @fsRPatL
  | DataFields  loc         .   rpat        =   RPat_Con @cpNm @finalTyExpanded @tag
                                                    (rpatConBindUnFlatten (RPatConBind_One @rest $ map fst @rpatBind0)
                                                     $ map (RPatConBind_One @rest . map fst)
                                                           @rpatBindss
                                                    )
  | Irrefutable loc         .   rpat        =   RPat_Irrefutable @cpNm @finalTyExpanded @patExpr.cbindL -- $ cbindInPatFlatten @patExpr.cbindInPatL
  | Bang        loc         .   rpat        =   case @patExpr.rpat of
                                                  r@(RPat_Var _ _ _) -> r {rcpMustEval = True}
                                                  r                  -> r

SEM PatExpr
  | Expr        loc         .   rpat        =   RPat_BoolExpr @cpNm (acoreTyErr "EH.ToCore.PatExpr.Expr") @cexpr @mbConst

ATTR AllPatExpr [ | | patCRest: CPatRest ]

SEM RecPatExpr
  | Empty       lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @recPatExpr.patCRest

SEM DataFieldPatExpr
  | Con         lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @dataFieldPatExpr.patCRest

SEM PatExpr
  | Var         lhs         .   patCRest    =   CPatRest_Var @nm
  | * - Var     lhs         .   patCRest    =   CPatRest_Empty

ATTR AllPatExpr [ | | fsRPatL: FieldSplitL ]

SEM DataFieldPatExpr
  | Con         lhs         .   fsRPatL     =   []
  | Ext         lhs         .   fsRPatL     =   (FldKnownOffset @nm @ioffset,@patExpr.rpat) : @dataFieldPatExpr.fsRPatL

SEM RecPatExpr
  | Empty       lhs         .   fsRPatL     =   []
  | Ext         lhs         .   fsRPatL     =   (FldComputeOffset @nm @offset,@patExpr.rpat) : @recPatExpr.fsRPatL

SEM PatExpr
  | App         lhs         .   fsRPatL     =   (FldImplicitOffset,@arg.rpat) : @func.fsRPatL
  | AppTop      loc         .   fsRPatL     =   @patExpr.fsRPatL
  | Rec         loc         .   fsRPatL     =   @recPatExpr.fsRPatL
  | DataFields  loc         .   fsRPatL     =   @dataFieldPatExpr.fsRPatL
  | Con         loc         .   fsRPatL     =   []
  | * - App Con Rec
                lhs         .   fsRPatL     =   []

SEM DataFieldPatExpr
  | Ext         loc         .   ioffset     =   dfiOffset $ panicJust "DataFieldPatExpr.Ext.ioffset" $ Map.lookup @nm $ dtiFldMp @dataFieldPatExpr.dti
                            .   offset      =   acoreInt @ioffset :: CExpr

SEM RecPatExpr
  | Ext         loc         .   ioffset     =   tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recPatExpr.ty
                            .   offset      =   acoreInt @ioffset :: CExpr

SEM RecPatExpr
  | Ext         loc         .   offset      :=  cSubstApp @patExpr.cSubst $ acoreNmHolePred @prUid

SEM Expr
  | App AppImpred
                loc         .   appImplsCoeL        =   (acoreCoePoiLApp $ map poPoi @prOccL) ++ [Coe_ImplApp $ ipoId @imPrvOcc]
                            .   appImplsLRCoe       =   lrcoeLFromList @appImplsCoeL

SEM Expr
  | AppImpl     loc         .   appImplsCoeL        =   []
                            .   appImplsLRCoe       =   lrcoeLFromList @appImplsCoeL

SEM Expr
  | Lam
    LamImpl
                loc         .   lamBodyCoeL         =   mkLamBodyCoe
                                                            (acoreCoeMap (\e -> rceMatchTy @rceEnv [(@arg.topNm,@finalTyArgExpanded)] [RAlt_Alt [@arg.rpat] e Set.empty]))
                                                            @body.appArgCoeL

SEM Expr
  | Lam         loc         .   lamArgCoeL          =   acoreCoePoiLLam (acoreCoeLetRec @poiBindL) @poiL ++ [acoreCoeLam1 @arg.topNm]
  | AppTop Rec Let
                loc         .   lamArgCoeL          =   acoreCoePoiLLam (acoreCoeLetRec @poiBindL) @poiL

SEM Expr
  | *           loc         .   lamArgCoeL          :   {[Coe]}

SEM Expr
  | LamImpl     loc         .   lamArgCoeL          =   [acoreCoeLam1 @arg.topNm `acoreCoeCompose` acoreCoeLetRec @poiBindL]

ATTR Expr [ | | appArgCoeL: {[Coe]}  appFunCExpr: CExpr ]

SEM Expr
  | App AppImpred
    AppImpl
                lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if @func.isNewtype
                                                    then ([],@arg.cexpr)
                                                    else (@func.appArgCoeL ++ @appImplsCoeL ++ [acoreCoeApp1 @arg.cexpr],@func.appFunCExpr)
  | AppTop      lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if null @lamArgCoeL
                                                    then (@expr.appArgCoeL,@expr.appFunCExpr)
                                                    else ([],@cexpr)
  | * - App AppImpred AppTop
    AppImpl
                lhs         .   appArgCoeL      =   []
                            .   appFunCExpr     =   @cexpr

ATTR AllDecl [ | | bangEvalL USE {++} {[]} : {[CExpr -> CExpr]} ]

SEM Decl
  | Val			lhs			.	bangEvalL		=	if @patExpr.isBang then [acoreLet1StrictTy (hsnUniqify HsNameUniqifier_Strict @patExpr.topNm) @finalTy (acoreVar @patExpr.topNm)] else []

ATTR
  AllDecl AllDataConstr
    [ | | cbindL
        , ffiCBindL
        , ffeCBindL
          USE {++} {[]}: CBindL
    ]

SEM Decl
  | TySig       lhs         .   cbindL          =   []
  | FFI         lhs         .   ffiCBindL       =   let ffi = ffiCoreMk @lhs.opts (\ty -> CExpr_FFI @callconv @safety @impEnt ty) @lUniqFFI @rceEnv @foreignEntInfo @finalTyExpanded
                                                    in  [acoreBind1CatTy CBindCateg_Plain @nm @finalTyExpanded ffi]
                loc         .   lUniqFFI        :   UNIQUEREF gUniq
  | Val         lhs         .   cbindL          :=  [ acoreBind1CatTy CBindCateg_Plain @patExpr.topNm @finalTyExpanded $
                                                      acoreLetMerge True CBindCateg_Rec @chrScopeValBindL $
                                                      @expr.cexpr
                                                    ]
                                                    ++ @patExpr.cbindL -- cbindInPatFlatten @patExpr.cbindInPatL

SEM Decl
  | FFE         loc         .   nmCoerced       =   hsnUniqify HsNameUniqifier_FFECoerced @nm
                            .   (ffeMkCExpr,ffeTy)
                                                =   ffeCoreMk @lhs.opts @lUniqFFE @rceEnv @finalTyExpanded
                            .   ffeCExpr        =   @ffeMkCExpr @expr.cexpr
                loc         .   lUniqFFE        :   UNIQUEREF gUniq
                lhs         .   ffeCBindL       =   [acoreBind1Asp1 @nm (CBound_FFE @callconv @expEnt @ffeCExpr @ffeTy)]

SEM Decl
  | FusionDecl  lhs         .  cbindL           =   []
  | FusionConv  lhs         .  cbindL           =   []

{
mkLetCBodyBindL :: Bool -> CBindCateg -> [(CBindCateg,CBindL)] -> [(CBindCateg,CBindL)] -> [(CBindCateg,CBindL)] -> CExpr -> ([(CBindCateg,CBindL)],CExpr)
mkLetCBodyBindL isStrict howToBind locBindL locOthBindL bodyBindL body
  = if isStrict
    then (locOthBindL,foldr (\(c,b) e -> acoreLet c b e) body (merge $ locBindL ++ bodyBindL))
    else (merge $ locOthBindL ++ locBindL ++ bodyBindL, body)
  where merge (cb1@(c1,b1) : tl)
          = case merge tl of
              (c2,b2) : tl' | c1 == c2 && c1 == CBindCateg_Rec
                  -> (c1,b1++b2) : tl'
              tl' -> cb1 : tl'
        merge [] = []

}
ATTR
  Expr
    [ | | letCBindL
        , frontCBindL
        , backCBindL
            : {[(CBindCateg,CBindL)]}
          letCBody: CExpr
    ]

SEM Expr
  | Let         (loc.letCBindRemL,loc.letCBody) =   mkLetCBodyBindL @isStrict @howToBind @letCBindL @letCBindOtherL @body.letCBindL @body.letCBody
                lhs         .   letCBindL       =   @letCBindRemL
                            .   frontCBindL     =   @frontCBindL ++ @body.frontCBindL
                            .   backCBindL      =   @backCBindL ++ @body.backCBindL
  | * - Let     lhs         .   letCBody        =   @cexpr
                            .   letCBindL       =   []
                            .   frontCBindL     =   []
                            .   backCBindL      =   []

{
cdictOffset :: HsName -> Ty -> Int
cdictOffset n r = tyRecOffset n $ r

}
SEM Decl
  | Class       lhs         .   cbindL      =   let  x = mkHNm "x"
                                                     vx = acoreVar x
                                                     xStrict = hsnUniqifyEval x
                                                     -- vxStrict = acoreVar xStrict :: CExpr
                                                     mkSel n = acoreSatSelsCaseMetaTy
                                                                 ((emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}) (Just (xStrict,(acoreTyErr $ "EH.ToCore.Decl.Class.mkSel: " ++ show n))) CMetaVal_Dict vx @dictTag
                                                                 [(n,{-n,-}cdictOffset n @clsTyRec)] Nothing (acoreVar n)
                                                     mkApp = if ehcCfgInstFldHaveSelf @lhs.opts
                                                             then (\f -> acoreApp1 f vx)
                                                             else id
                                                     dDflt
                                                       = [acoreBind1Ty nDflt (acoreTyErr $ "EH.ToCore.Decl.Class.dDflt: " ++ show nDflt) (acoreLam1 nD d)]
                                                       where nDflt = clgiDfltDictNm @clgi2
                                                             d = acoreApp (CExpr_Tup @dictTag) (replicate (length $ snd $ tyRecExts $ @clsTyRec) (acoreBuiltinUndefined @lhs.opts))
                                                             nD = hsnUniqify HsNameUniqifier_SelfDict nDflt
                                                in   (maybe dDflt (const []) @mbDefaultInstNm)
                                                     ++ [ acoreBind1CatTy CBindCateg_Plain n (tyQuantifyClosed $ [@dataDictTy] `mkArrow` t) $ acoreLam1 x $ mkApp $ mkSel n
                                                        | (n,t) <- @clsFldL
                                                        ]

{
-- | Make the various names required for instance building
mkInstanceNames
  :: HsName
     -> Ty
     -> ( AssocL HsName Ty
        , [HsName]
        , [HsName]
        , [CExpr]
        )
mkInstanceNames
     dictNm instanceRecTy
  = (instanceFieldL,memberNames,memberNewNames,memberNewVars)
  where instanceFieldL  = snd $ tyRecExts instanceRecTy
        memberNames     = assocLKeys $ tyRowCanonOrder instanceFieldL
        memberNewNames  = [ hsnUniqifyStr HsNameUniqifier_DictField (show n) dictNm | n <- memberNames ]
        memberNewVars   = map acoreVar memberNewNames

}
{
-- | Make a dictionary corresponding to an instance declaration
mkNormalInstance
  :: EHCOpts
     -> ClGamInfo                           -- info about the class
     -> DataGam                             -- env/gamma for datas
     -> CTag                                -- tag of the dictionary (as data type)
     -> (HsName,HsName,HsName)              -- various names for the dictionary under construction at various stages of construction, also used externally
     -> Ty                                  -- instance dict as record
     -> ( [HsName]                          -- names of super class fields
        , [HsName]                          -- names of super class dicts, given as arg
        , [HsName]                          -- names of context class dicts, given as arg
        )
     -> [CBind]                             -- bindings for decls of the instance
     -> ([CBind]                            -- bindings for decls related context reduction, both Assume & Prove
        ,[CBind]                            -- bindings for super class related context reduction, only Prove
        ,[CBind]                            -- bindings for super + ctxt class related context reduction, only Assume
        )
     -> ( CExpr                             -- the instance
        , CMetaVal                          -- the meta info about the instance
        )
mkNormalInstance
      opts clgi dataGam dictTag
      (dictNm,_,dictBuildNm)
      instanceRecTy
      (superFldNmL,superNmL,contextNmL)
      declsCBindL
      (chrDeclsCBindL,chrSuperProveCBindL,chrSuperCtxtAssumeCBindL)
  = ( bind4
    , CMetaVal_DictInstance (TrackVarApply (ctagTyNm dictTag) [] : TrackVarApply dfltNm [] : instanceAndSuperTracks )
    )
  where dfltNm       = clgiDfltDictNm clgi
        rsltNm       = dictBuildNm
        rsltNmStrict = hsnUniqifyEval rsltNm
        dfltNmStrict = hsnUniqifyEval dfltNm

        dfltVar      = acoreVar dfltNm
        rsltVar      = acoreVar rsltNm
        rsltVarStrict= acoreVar rsltNmStrict
        dfltVarStrict= acoreVar dfltNmStrict

        (instanceFieldL,memberNames,memberNewNames,memberNewVars)
                            = mkInstanceNames dictNm instanceRecTy
        mkSetFlds           = mkInstanceSetFlds opts dataGam dictTag instanceRecTy

        instanceBindingPairs= [ (nm,v)
                              | CBind_Bind nm asps <- declsCBindL, CBound_Bind _ v <- asps
                              ]
        instanceMbBodies    = map (flip lookup instanceBindingPairs) memberNames
        instanceMbNewNames  = let f _ Nothing  = Nothing
                                  f n (Just e) = Just n
                              in zipWith f memberNewNames instanceMbBodies
        instanceMbNames     = let f _ Nothing  = Nothing
                                  f n (Just _) = Just n
                              in zipWith f memberNames instanceMbNewNames
        instanceNameMapping = [ (nm, CMetaVal_Val, v)
                              | (Just nm,v) <- zip instanceMbNames memberNewVars
                              ]
        instanceNewBindings = [ acoreBind1MetaTy nm CMetaVal_Val (acoreTyErr $ "EH.ToCore.mkNormalInstance.instanceNewBindings: " ++ show nm) v
                              | (nm,Just v) <- zip memberNewNames instanceMbBodies
                              ]

        superNewVars        = map acoreVar superNmL
        superNameMapping    = zip3 superFldNmL
                                   (repeat CMetaVal_Dict)
                                   superNewVars

        superNameMapping2   = zip superFldNmL
                                  superNmL
        superPairs          = map getBindLeftAndRightVar chrSuperProveCBindL

        doubleLookup :: HsName -> Maybe HsName
        doubleLookup nm   =  do { nm2 <- lookup nm superNameMapping2
                                -- ; nm3 <- lookup nm2 superPairs
                                ; return nm2 -- nm3
                                }

        superMbNewNames   =  map doubleLookup memberNames

        instanceAndSuperMbNewNames = let f (Just x) _ = Just x
                                         f _ (Just y) = Just y
                                         f _ _        = Nothing
                                     in zipWith f instanceMbNewNames superMbNewNames

        instanceAndSuperTracks = map mbNameToTrack instanceAndSuperMbNewNames

        instanceCHRBindings = chrSuperCtxtAssumeCBindL ++ chrSuperProveCBindL ++ chrDeclsCBindL

        dict1     = acoreApp1 dfltVar rsltVar
        bind1     = acoreBind1MetaTy dfltNmStrict CMetaVal_Dict (acoreTyErr $ "EH.ToCore.mkNormalInstance.bind1: " ++ show dfltNmStrict) dict1

        dict2     = acoreLetBase (acoreBindcategStrict) [bind1] (mkSetFlds (superNameMapping ++ instanceNameMapping) dfltVarStrict)
        bind2     = acoreBind1MetaTy rsltNmStrict (CMetaVal_Track TrackSelf) (acoreTyErr $ "EH.ToCore.mkNormalInstance.bind2: " ++ show rsltNmStrict) dict2

        dict3     = acoreLetBase (acoreBindcategPlain) [bind2] rsltVarStrict
        bind3     = acoreBind1MetaTy rsltNm       (CMetaVal_Track TrackSelf) (acoreTyErr $ "EH.ToCore.mkNormalInstance.bind3: " ++ show rsltNm) dict3

        dict4     = acoreLetRec ([bind3] ++ instanceNewBindings ++ instanceCHRBindings) rsltVar
        bind4     = acoreLam contextArguments dict4

        -- The above generates the following Core code as dict4:
        --
        -- letrec reslt = let rsltStrict = let! dfltStrict = dflt rslt
        --                                 in   case defltStrict of
        --                                        (Dict-C _1 _2 _3 _4) -> (Dict-C _1 inst2 _3 inst4)     -- in this example, field 2 and 4 are defined in the isntance, 1 and 3 are taken from the defaultdefinitions
        --                in  rsltStrict
        --        inst2 = ...
        --        inst4 = ...
        -- in reslt

        contextArguments = contextNmL

}
{
--  Make a dictionary for a normal instance, the default-definitions of a class, or for a derived instance
mkInstanceCBindL
  :: EHCOpts
     -> ClGamInfo                           -- info about the class
     -> DataGam                             -- env/gamma for datas
     -> InstVariant                         -- what kind of instance
     -> CTag                                -- tag of the dictionary (as data type)
     -> (HsName,HsName,HsName)              -- various names for the dictionary under construction at various stages of construction, also used externally
     -> Ty                                  -- instance dict as data type
     -> Ty                                  -- instance dict as record
     -> ( [HsName]                          -- names of super class fields
        , [HsName]                          -- names of super class dicts, given as arg
        , [HsName]                          -- names of context class dicts, given as arg
        )
     -> [CBind]                             -- bindings for decls of the instance
     -> ([CBind]                            -- bindings for decls related context reduction, both Assume & Prove
        ,[CBind]                            -- bindings for super class related context reduction, only Prove
        ,[CBind]                            -- bindings for super + ctxt class related context reduction, only Assume
        )
     -> [CBind]
mkInstanceCBindL
      opts clgi dataGam instVariant dictTag
      nms@(dictNm,dictSelfNm,dictBuildNm)
      instanceTy
      instanceRecTy
      nmLs@(superFldNmL,superNmL,contextNmL)
      declsCBindL
      chrBindLs@(chrDeclsCBindL,chrSuperProveCBindL,chrSuperCtxtAssumeCBindL)
  = [acoreBind1MetaTy dictNm generatedMeta instanceTy generatedDictionary]
  where (generatedDictionary, generatedMeta)
          = case instVariant of
               InstNormal     -> mkNormalD  declsCBindL
               InstDefault    -> mkDefaultD declsCBindL
               InstDeriving _ -> mkNormalD  declsCBindL
        rsltNm   = dictBuildNm
        rsltVar  = acoreVar rsltNm

        mkNormalD instanceBindings
          = mkNormalInstance
              opts clgi dataGam dictTag nms instanceRecTy nmLs
              instanceBindings chrBindLs

        -- Make a dictionary corresponding to (the default definitions in a) class definition
        mkDefaultD defaultBindings
          = let selfNm    = dictSelfNm

                (instanceFieldL,memberNames,memberNewNames,memberNewVars)
                                    = mkInstanceNames dictNm instanceRecTy

                lookupMeta n = if n `elem` superFldNmL then CMetaVal_Dict else CMetaVal_Val

                defaultBindingPairs = [ (nm,v)
                                      | CBind_Bind nm asps <- defaultBindings, CBound_Bind _ v <- asps
                                      ]
                defaultMbBodies     = map (flip lookup defaultBindingPairs) memberNames
                defaultMetas        = map lookupMeta                        memberNames
                defaultBodies       = map (maybe (acoreBuiltinUndefined opts) id) defaultMbBodies
                defaultMbNewNames   = let f _ Nothing  = Nothing
                                          f n (Just _) = Just n
                                      in zipWith f memberNewNames defaultMbBodies
                defaultTracks       = map mbNameToTrack defaultMbNewNames

                defaultNewBindings  = zipWith3 (\n m b -> acoreBind1MetaTy n m (acoreTyErr $ "EH.ToCore.mkInstanceCBindL.defaultNewBindings: " ++ show n) b)
                                                                memberNewNames
                                                                defaultMetas
                                                                defaultBodies
                defaultCHRBindings  = chrDeclsCBindL

                dict5     = acoreApp (CExpr_Tup dictTag) memberNewVars
                bind5     = acoreBind1MetaTy rsltNm CMetaVal_Dict (acoreTyErr $ "EH.ToCore.mkInstanceCBindL.bind5: " ++ show rsltNm) dict5

                dict6     = acoreLetRec ([bind5] ++ defaultNewBindings ++ defaultCHRBindings) rsltVar
                bind6     = acoreLam1 selfNm dict6

            in  ( bind6
                , CMetaVal_DictClass defaultTracks
                )

}
{
mkInstanceSetFlds :: EHCOpts -> DataGam -> CTag -> Ty -> [(HsName,CMetaVal,CExpr)] -> CExpr -> CExpr
mkInstanceSetFlds opts dataGam dictTag instanceRecTy
  = if   ehcCfgClassViaRec opts
    then mkSetFldsRec
    else mkSetFldsData
  where off n = cdictOffset n instanceRecTy
        mkSetFldsRec ts d0
          = foldl (\d (n,_,v) -> mkSet d n v) d0 ts
          where mkSet d n v = CExpr_TupUpd d dictTag n (acoreInt $ off n) v

        mkSetFldsData ts d0
          = acoreSatSelsCaseMetaTy env Nothing CMetaVal_Dict d0 dictTag nmLblOffL Nothing sel
          where env = (emptyRCEEnv opts) {rceDataGam = dataGam}
                fullListWithTrivialValues = [ (o, (o, (acoreVar n) ) )
                                            | (n,o) <- nmLblOffL
                                            ]
                sparseListWithInterestingValues = [ (off n, (v) )
                                                  | (n,m,v) <- ts
                                                  ]
                arity = ctagArity dictTag
                ns = take arity hsnLclSupply
                nmLblOffL = zip ns [0..]
                sel = acoreApp       (CExpr_Tup dictTag)
                                     (map snd
                                      $ listSaturateWith 0
                                                         (arity-1)
                                                         fst
                                                         fullListWithTrivialValues
                                                         sparseListWithInterestingValues
                                     )

}
SEM Decl
  | Instance    (lhs.cbindL,loc.cSubstInst)   =   let (bindL,cSubstInstL) =
                                                           case @instVariant of
                                                             InstNormal   -> (@decls.cbindL,[])
                                                             InstDefault  -> (@decls.cbindL,[])
                                                             InstDeriving _
                                                               | not $ null @generForFitsInL
                                                                          -> unzip
                                                                               [ (acoreBind1 fld $ acoreApp1 f $ acoreBuiltinUndefined @lhs.opts,s)
                                                                               | ((fld,dflt,_,_),fo,u) <- zip3 @generForFitsInL @foGenerDerivL (mkNewLevUIDL (length @generForFitsInL) @lUniq_bind)
                                                                               , let (f,s) = foAppLRCoeAsSubst @lhs.opts u fo @lhs.finTyVarMp @cSubstDecls (acoreVar dflt)
                                                                               ]
                                                               | otherwise
                                                                          -> ([ @mkf dcf | dcf <- dclFldL @derivDCL ],[])
                                                  in  ( mkInstanceCBindL
                                                        @lhs.opts @clgi @lhs.dataGam @instVariant @dictTag
                                                        (@dictNm,@dictSelfNm,@dictBuildNm)
                                                        @finalTy @recTy
                                                        (@supClsFldNmL,@chrSuperProveNmL,@chrCtxtArgNmL)
                                                        bindL
                                                        ( @chrAssumeDeclsInstBindL ++ @chrScopeDeclsBindL
                                                        , @chrScopeSuperBindL
                                                        , @chrAssumeSuperBindL ++ @chrAssumeDeclsCtxtBindL
                                                        )
                                                      , foldr cSubstApp emptyCSubst cSubstInstL
                                                      )
                loc         .   lUniq_bind  :   UNIQUEREF gUniq
  | InstanceIntro
                lhs         .   cbindL      =   [acoreBind1MetaTy @dictNm CMetaVal_Dict (acoreTyErr $ "EH.ToCore.Decl.InstanceIntro.cbindL: " ++ show @dictNm) @expr.cexpr]

{
getBindRightVar :: CBind -> Maybe HsName

getBindRightVar (CBind_Bind _ [CBound_Bind _ v]) = acoreExprMbVar v
getBindRightVar _ = Nothing


getBindLeftAndRightVar :: CBind -> (HsName,HsName)

getBindLeftAndRightVar (CBind_Bind nm1 [CBound_Bind _ (CExpr_Var ref2)]) = (nm1, acbrefNm ref2)
getBindLeftAndRightVar _ = error "getBindLeftAndRightVar: not a bind"

mbNameToTrack Nothing   = TrackNone
mbNameToTrack (Just nm) = TrackVarApply nm []


}
{
mkInstanceDerivingFldBind :: EHCOpts -> RCEEnv -> DataGam -> UID -> DataGamInfo -> Ty -> HsName -> CTag -> [[PredOcc]] -> [PredOcc] -> DerivClsFld -> CBind
mkInstanceDerivingFldBind opts rceEnv dataGam uniq derivDataDGI derivHdDataTy dictBuildNm ctag derivAltsPrOcc derivExtraPrOcc
  = mkf
  where rsltNm   = dictBuildNm
        rsltVar  = acoreVar rsltNm

        mkf :: DerivClsFld -> CBind
        mkf dcf
         = acoreBind1Ty (dcfNm dcf) (acoreTyErr $ "EH.ToCore.mkInstanceDerivingFldBind.mkf.dcfNm: " ++ show (dcfNm dcf))
             (if fArity == 0
              then acoreLam (dcfInitialArgL dcf)
                   $ dcfNoArgSubsCExpr dcf rceEnv
                       [ (dti,mkcSubs dti (repeat []) altPrOccL) | (dti,altPrOccL) <- zip dtis derivAltsPrOcc ]
                       nrOfAlts rsltVar extraCxL (dcfInitialArgL dcf)
              else acoreLam (dcfInitialArgL dcf ++ take fArity nsA)
                     (dcfWrapCase dcf opts derivDataDGI nrOfAlts n1 (dcfInitialArgL dcf)
                      $ acoreStrictSatCaseTy rceEnv (Just (hsnUniqifyEval n1,(acoreTyErr $ "EH.ToCore.mkInstanceDerivingFldBind.mkf.n1: " ++ show n1))) n1v
                        [ CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just $ n1subs ctag))
                                   (mkc splDTI altInx (fArity - 1) n1s [n1subs ctag] altPrOccL)
                        | (ctag,altPrOccL) <- zip (map dtiCTag dtis) derivAltsPrOcc
                        , let splDTI@(dtisLT,_,_) = splitDTIs ctag dtis
                              altInx = length dtisLT
                        ]
             )       )
         where n1v = acoreVar n1
               nsA@(n1:n1s) = hsnLclSupplyWith (mkHNm "x")
               dtis  = panicJust "Decl.Instance.Deriving.dataGamDTIsOfTy" $ dataGamDTIsOfTy derivHdDataTy dataGam
               nrOfAlts = length dtis
               splitDTIs t ts -- in (lt,eq,gt), according to list ordering
                 = (l,e,g)
                 where (l,(e:g)) = span ((/= t) . dtiCTag) ts
               fArity = (length $ tyArrowArgs $ dcfTy dcf) - dcfNrOmitTailArg dcf - length (dcfInitialArgL dcf) - 1 {- dictionary -}
               n1subs t = nsubs t n1
               nsubs t n = take (ctagArity t) $ hsnLclSupplyWith n
               extraCxL = [ acoreNmHolePred (poPoi prOcc) | prOcc <- derivExtraPrOcc ]
               mkcSubs dti nmFldLL altPrOccL
                 = [ acoreApp
                       (acoreVar (dcfNm dcf))
                       ([acoreNmHolePred (poPoi prOcc)]
                         ++ (dcfInitialSubArgL dcf dti ++ map acoreVar nmFldL))
                   | (nmFldL,prOcc) <- zip nmFldLL altPrOccL
                   ]
               mkc tg@(dtisLT,dti,dtisGT) altInx arity nms nmFldLL altPrOccL
                 = case nms of
                     (n:ns) | arity > 0
                       -> acoreStrictSatCaseTy rceEnv (Just (hsnUniqifyEval n,(acoreTyErr $ "EH.ToCore.mkInstanceDerivingFldBind.mkf.mkc.n: " ++ show n))) (acoreVar n)
                            (   [ mka (dtiCTag dti) tsubs (mkc tg altInx (arity - 1) ns (nmFldLL ++ [tsubs]) altPrOccL) ]
                             ++ [ mka t (nsubs t n) (dcfAllTagLtCExpr dcf) | t <- map dtiCTag dtisLT ]
                             ++ [ mka t (nsubs t n) (dcfAllTagGtCExpr dcf) | t <- map dtiCTag dtisGT ]
                            )
                       where tsubs = nsubs (dtiCTag dti) n
                             mka ctag nsubs e = CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just nsubs)) e
                     _ -> dcfFoldSubsCExpr dcf uniq rceEnv dti (altInx, nrOfAlts) (dcfInitialArgL dcf)
                          $ mkcSubs dti (transpose nmFldLL) altPrOccL

}
SEM Decl
  | Instance    loc         .   mkf         =   mkInstanceDerivingFldBind @lhs.opts @rceEnv @lhs.dataGam @lUniq @derivDataDGI @derivHdDataTy @dictBuildNm @dictTag @derivAltsPrOcc @derivExtraPrOcc

{
mkDataGenerBinds
  :: -- (AbstractCore e m b bcat mbind t) =>
        EHCOpts
     -> RCEEnv
     -> ClGam                               -- env/gamma for class
     -> DataGam                             -- env/gamma for datas
     -> UID                                 -- uniq
     -> [GenerDataInstInfo]                 -- inst infos
     -> ([CBind],[Err])
mkDataGenerBinds
     opts rceEnv clGam dataGam
     uniq instInfoL
  = (concat instBinds, concat errs)
  where (instBinds,errs) = unzip $ map mk instInfoL
        mk (orignm,dictNm,clNm,instKind,pr)
          = ( mkInstanceCBindL opts clgi dataGam InstNormal (clgiDictTag clgi) (dictNm,dictSelfNm,dictBuildNm) (pred2DataTy pr) recTy ([],[],[])
                               binds ([],[],[])
            , foErrL evFO
            )
          where (_,u1,u2) = mkNewLevUID2 uniq
                clgi  = panicJust ("mkDataGenerBinds.clGam: " ++ show dictNm ++ ": " ++ show clNm) $ gamLookup clNm clGam

                -- derived names required for building
                (dictSelfNm,dictBuildNm) = mkInstanceBuildNms dictNm

                -- match predicate to get the record type describing fields of dictionary
                evFO  = fitPredToEvid' u1 emptyVarMp (mkTyPr pr) (Left clgi)
                recTy = foVarMp evFO `varUpd` foTy evFO

                -- the bindings for datatypes acting as labels
                binds = case instKind of
                          GenerInstKind_Representable remArity proj
                            -> [ acoreBind1 (ehcOptBuiltin2 opts ehbnGenerClassRepresentableNFldFrom remArity) (projFrom opts rceEnv proj)
                               , acoreBind1 (ehcOptBuiltin2 opts ehbnGenerClassRepresentableNFldTo   remArity) (projTo   opts rceEnv proj)
                               ]

                          GenerInstKind_Datatype
                            -> [ mkBindStr ehbnGenerClassDatatypeFldName                         $ hsnQualified orignm
                               , mkBindStr ehbnGenerClassDatatypeFldModule $ maybe hsnUnknown id $ hsnQualifier orignm
                               ]

                          GenerInstKind_Selector
                            -> [ mkBindStr ehbnGenerClassSelectorFldName                         $ hsnQualified orignm
                               ]

                          GenerInstKind_Constructor tyNm
                            -> [ mkBindStr ehbnGenerClassConstructorFldName $ hsnQualified orignm ]
                               ++ (if Map.null (dtiFldMp dti) then [] else [mkBind ehbnGenerClassConstructorFldIsRec $ acoreVar $ biNm ehbnBoolTrue])
                               ++ (if isNothing mbInfix
                                   then []
                                   else [mkBind ehbnGenerClassConstructorFldFixity
                                         $ acoreApp (acoreVar $ biNm ehbnGenerDataFixityAltInfix)
                                         $ [ acoreVar (biNm (case fixity of
                                                               Fixity_Infix  -> ehbnGenerDataAssociativityAltNot
                                                               Fixity_Infixr -> ehbnGenerDataAssociativityAltRight
                                                               Fixity_Infixl -> ehbnGenerDataAssociativityAltLeft
                                                      )     )
                                           , acoreInt prio
                                           ]
                                        ]
                                  )
                            where dgi = panicJust ("mkDataGenerBinds.dataGam: " ++ show tyNm) $ dataGamLookup tyNm dataGam
                                  dti = panicJust ("mkDataGenerBinds.dgiConstrTagMp: " ++ show orignm) $ Map.lookup orignm $ dgiConstrTagMp dgi
                                  mbInfix@(~(Just (prio,fixity))) = dtiMbFixityPrio dti

                          -- _ -> []

        -- get a builtin name
        biNm          = ehcOptBuiltin opts

        -- utils for bindings
        argNm         = mkHNm "x"
        mkBindx a f x = acoreBind1 (biNm f) (acoreLam [a] x)
        mkBind        = mkBindx argNm
        mkBindStr f n = mkBind f $ acoreBuiltinString opts $ show n

}
SEM Expr
  | Let         loc         .   (cDataGenerBindL,errsDataGenerBind)
                                            =   mkDataGenerBinds
                                                    @lhs.opts
                                                    (@rceEnv {rceValGam = @finValGam `gamUnion` rceValGam @rceEnv})
                                                    @forDeclsClGam @lhs.dataGam
                                                    @lUniq_gener @generInstInfoL
                loc         .   lUniq_gener :   UNIQUEREF gUniq


ATTR CaseAlt [ | | ralt: RAlt  ralt': RAlt ]
ATTR CaseAlts [ | | raltL: {[RAlt]}  raltL': {[RAlt]} ]

SEM CaseAlt
  | Pat         lhs         .   ralt        =   RAlt_Alt [@patExpr.rpat] @expr.cexpr @expr.caseFailS
                            .   ralt'       =   RAlt_Alt (fsL2PatL $ reverse @patExpr.fsRPatL) @expr.cexpr @expr.caseFailS

SEM CaseAlts
  | Nil         lhs         .   raltL       =   []
                            .   raltL'      =   []
  | Cons        lhs         .   raltL       =   @hd.ralt  : @tl.raltL
                            .   raltL'      =   @hd.ralt' : @tl.raltL'

ATTR AllPatExpr [ | | cbindL USE {++} {[]}: CBindL ]

SEM PatExpr
  | AppTop Rec  loc         .   cbindL      =   acoreRPatBindL2BindL @rceEnv (not $ null @cbindLSub) @lhs.ceParentNm @tag (Just (@rest,length @fsRPatL)) @rpatBinds
  | DataFields  loc         .   cbindL      =   acoreRPatBindL2BindL @rceEnv (not $ null @cbindLSub) @lhs.ceParentNm @tag (Just (@rest,ctagArity @tag)) @rpatBindsNonSat
  | AppTop Rec DataFields
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub

SEM PatExpr
  | AppTop      loc         .   cbindLSub   =   @patExpr.cbindL
  | Rec         loc         .   cbindLSub   =   @recPatExpr.cbindL
  | DataFields  loc         .   cbindLSub   =   @dataFieldPatExpr.cbindL

ATTR AllPatExpr [ ceParentNm: HsName | | ]

SEM PatExpr
  | App         arg         .   ceParentNm  =   rpatNmNm @arg.cpNm
--  | Irrefutable patExpr       .   ceParentNm  =   tr "PatExpr.Irrefutable" (@cpNm >#< @lhs.ceParentNm >#< @patExpr.topNm) @lhs.ceParentNm

SEM RecPatExpr
  | Ext         patExpr     .   ceParentNm  =   rpatNmNm @patExpr.cpNm

SEM Decl
  | Val         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM CaseAlt
  | Pat         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM Expr
  | Lam         arg         .   ceParentNm  =   @arg.topNm

SEM Expr
  | LamImpl     arg         .   ceParentNm  =   @arg.topNm

ATTR Expr [ | | caseFailS USE {`Set.union`} {Set.empty}: UIDS ]

SEM Expr
  | Case        lhs         .   caseFailS   =   @caseFailS

