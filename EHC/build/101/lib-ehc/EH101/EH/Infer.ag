SEM Expr
  | Let         loc         .   gathTySigGam_l_     =   @decls.gathTySigGam
                decls       .   patValGam           =   gamPushGam @gathTySigGam_l_ @lhs.valGam
                loc         .   (valGam_l_,valGam_g_)
                                                    =   gamPop @decls.patValGam
                decls       .   valGam              =   @decls.patValGam
                loc         .   bodyValGam          =   @decls.patValGam
                body        .   valGam              =   @bodyValGam

SEM Expr
  | Let         decls       .   patTyVarMp          =   @lhs.tyVarMp
                            .   tyVarMp             =   @decls.patTyVarMp

SEM Expr
  | Let         -- (loc.lSubsValGam_,loc.cycTyVarMp_l) =   @decls.tyVarMp `varUpdCyc` @valGam_l_
                loc         .   gTyTvS              =   @valTyUpdFreeTvarS `Set.union` @tyTyUpdFreeTvarS
                            .   gSubsValGam_        =   @valGam_g_
                            .   noLetQuantTyVarIdS  =   setSubst @tyVarMpDeclsL0 @decls.noLetQuantTyVarIdS `Set.union` @gTyTvS
                            .   (quValGam_qu_,cycTyVarMp_l)
                                                    =   let (g,cycMp) = @tyVarMpDeclsQuant `varUpdCyc` @valGam_l_
                                                        in  (valGamQuantify @valQuTyKiGam @quTvKiVarMp @tyVarMpDeclsQuant @noLetQuantTyVarIdS g,cycMp)
                            .   quValGam_           =   @quValGam_qu_
                loc         .   bodyValGam          :=  ehcOptTrace @lhs.opts "Expr.Let.loc.bodyValGam" $
                                                        gamAddGam @quValGam_ @gSubsValGam_

SEM Expr
  | Let         loc         .   gathTySigGam_l_     :=  valGamInst1Exists @lUniq @decls.gathTySigGam
                loc         .   quValGam_ex_        =   valGamInst1Exists @lUniq2 @quValGam_qu_
                            .   quValGam_ex_subst   =   @quValGam_ex_
                            .   quValGam_           :=  @quValGam_ex_
                loc         .   lUniq               :   UNIQUEREF gUniq
                loc         .   lUniq2              :   UNIQUEREF gUniq

SEM Expr
  | Let         loc         .   valQuTyKiGam        =   gamUnions [@finTyKiGam,@decls.intlTyKiGam]

SEM Expr
  | Let         loc         .   (gathTySigGam_l_,exTyVarMp1)
                                                    :=  (valGamInst1Exists {- WithVarMp @lhs.tyVarMp -} @lUniq @decls.gathTySigGam,emptyVarMp)
                            .   exTyVarMp1b         =   (@exTyVarMp1 :: VarMp) `varUpd` @lhs.tyVarMp
                decls       .   patTyVarMp          :=  @exTyVarMp1b
                loc         .   (quValGam_qu_,quTyVarMp, cycTyVarMp_l)
                                                    :=  valGamQuantifyWithVarMp @valQuTyKiGam @quTvKiVarMp @tyVarMpDeclsQuant @noLetQuantTyVarIdS @valGam_l_
                            .   bodyVarMp1          =   @quTyVarMp `varUpd` @tyVarMpDeclsL0 		-- TBD: Use of @tyVarMpDeclsQuant increases compile time. Why???? Should be ok...
                            .   (quValGam_ex_,exTyVarMp2)
                                                    :=  (valGamInst1Exists {- WithVarMp @bodyVarMp1 -} @lUniq2 (@quTyVarMp `varUpd` @quValGam_qu_), emptyVarMp)
                            .   bodyVarMp2          =   (@exTyVarMp2 :: VarMp) `varUpd` @bodyVarMp1
                            .   quValGam_ex_subst   :=  @bodyVarMp2 `varUpd` @quValGam_ex_
                body        .   tyVarMp             =   @bodyVarMp2

                loc         .   exTyVarMp1          :   VarMp
                loc         .   exTyVarMp1b         :   VarMp

{
-- | split a list of predicates into non-ambiguous & ambiguous, using quantifications results tqoGam,
--   which (a.o.) administers which predicates could be merged for quantification, those not are then ambiguous
doPredAmbigSplit :: (x -> PredOcc) -> TQOGam -> [x] -> ([x],[x])
doPredAmbigSplit get tqoGam prOccL
  = partition (\o -> poPoi (get o) `Set.member` assumedByQuant) prOccL
  where assumedByQuant = Set.unions $ map tmpoInsPrIdSet $ gamElts tqoGam

}
SEM Expr
  | Let         decls       .   patTyVarMp          :=  @forExprTyVarMp `varUpd` @exTyVarMp1b
                loc         .   doValGamQuantify    =   \doQuant tyVarMp prOccL -> valGamQuantifyWithVarMp doQuant @valQuTyKiGam @quTvKiVarMp tyVarMp @noLetQuantTyVarIdS prOccL @valGam_l_
                            .   doPredAmbigSplitForSimplify
                                                    =   \chrPrOccL
                                                           -> let us                = mkNewLevUIDL (length chrPrOccL) uidStart
                                                                  -- couple with arbitrary id's to make quantify & split work
                                                                  prOccL            = zipWith (\u (o,_) -> cpo2PredOcc (mkPrId u) o) us chrPrOccL
                                                                  (_,_, (_,tqoGam)) = @doValGamQuantify False @tyVarMpDeclsL01 prOccL
                                                                  (namb,amb)        = doPredAmbigSplit fst tqoGam $ zip prOccL chrPrOccL
                                                              in  (map snd amb, map snd namb)
                            .   (quValGam_qu_,quTyVarMp, (cycTyVarMp_l,tqoGam))
                                                    :=  @doValGamQuantify True @tyVarMpDeclsQuant @toQuantOverPrOccL
                            .   tmpoTyVarMp         =   foldr (\tmpo c -> tmpoImplsVarMp tmpo `varUpd` c) emptyVarMp (gamElts @tqoGam)


SEM Expr
  | Let         loc         .   tyVarMpDeclsL0      =   @decls.tyVarMp

SEM Expr
  | Let         loc         .   tyVarMpDeclsL0      :=  {- varmpIncMetaLev @quTvKiVarMp `varUpd` -} varmpSelectMetaLev [0] @decls.tyVarMp

SEM Decl
  | Instance    loc         .   tyVarMpDeclsL0      =   varmpSelectMetaLev [0] $
                                                        foVarMp @foGenerDeriv `varUpd`
                                                        @decls.tyVarMp

SEM Expr
  | Let         loc         .   tyVarMpDeclsL01     =   @tyVarMpDeclsL0
                            .   tyVarMpDeclsQuant   =   @tyVarMpDeclsL01

SEM Expr
  | Let         loc         .   tyVarMpDeclsL01     :=  varmpIncMetaLev @quTvKiVarMp `varUpd` @tyVarMpDeclsL0

SEM Expr
  | Let         loc         .   tyVarMpDeclsQuant   :=  @chrSolve1SimpTyVarMp `varUpd` @tyVarMpDeclsL01

SEM Decl
  | Instance    loc         .   tyVarMpDeclsL01     =   @tyVarMpDeclsL0

SEM Decl
  | Val         loc         .   knTy                =   @ty_sig_
                            .   exprKnTy            =   @knTy
                expr        .   knTy                =   @exprKnTy

SEM Decl
  | Val         loc         .   exprKnTy            :=  if @hasTySig then @knTy else @patExpr.ty

SEM Decl
  | Val         loc         .   knTy                :=  tyInstKnown @lUniq @ty_sig_
                loc         .   lUniq               :   UNIQUEREF gUniq

SEM Decl
  | Val         loc         .   knTy                :=  @ty_sig_


SEM Decl
  | FFE         loc         .   knTy                =   @ty_sig_

SEM Decl
  | Data
    Type
                loc         .   knKi                =   @sigKi

ATTR
  AllDecl AllExpr
  AllDataConstr AllCase
    [ valGam: ValGam | | ]

ATTR AllPatExpr [ | valGam: ValGam | ]

ATTR AllDecl [ | patValGam: ValGam | ]

SEM Decl
  | Val         patExpr     .   valGam              =   @lhs.patValGam
                lhs         .   patValGam           =   @patExpr.valGam
                expr        .   valGam              =   @lhs.valGam

ATTR AllDecl [ | tyVarMp: VarMp  patTyVarMp: VarMp | ]

SEM AGItf
  | AGItf       expr        .   tyVarMp             =   emptyVarMp

ATTR AllExpr [ | tyVarMp: VarMp | ]

ATTR AllPatExpr [ | patTyVarMp: VarMp | ]

ATTR AllCase [ | tyVarMp: VarMp   patTyVarMp: VarMp | ]
ATTR AllDataConstr AllData [ | patTyVarMp: VarMp | ]

ATTR AllPatExpr [ | tyVarMp: VarMp | ]


ATTR AllDecl AllExpr [ tyGam: TyGam | | ]

ATTR AllPatExpr [ | tyGam: TyGam | ]

ATTR AllDataConstr AllCase [ tyGam: TyGam | | ]
ATTR AllDecl [ | patTyGam: TyGam | ]

SEM Expr
  | Let         decls       .   patTyGam            =   gamPushNew @lhs.tyGam
                            .   tyGam               =   @decls.patTyGam

ATTR AllDataField [ | tyGam: TyGam | ]

ATTR AllDecl AllExpr AllDataConstr AllCase [ tyKiGam: TyKiGam | | ]
ATTR
  AllPatExpr
  AllDataField
    [ | tyKiGam: TyKiGam | ]

ATTR AllDecl [ | patTyKiGam: TyKiGam | ]

ATTR AllExpr AllPatExpr AllData AllCase AllDecl [ | kiVarMp: VarMp | ]
ATTR AllDecl [ | patKiVarMp: VarMp | ]

SEM Expr
  | Let         decls       .   patTyGam            :=  gamPushGam @decls.gathKiSigGam @lhs.tyGam
                            .   patTyKiGam          =   gamPushGam @decls.gathTyKiSigGam @lhs.tyKiGam
                            .   patKiVarMp          =   @lhs.kiVarMp
                loc         .   (tyGam_l_,tyGam_g_) =   gamPop @decls.patTyGam
                            .   tyGam_l_extra       =   gamUnion @extraTyGam @tyGam_l_
                            .   (tyKiGam_l_,tyKiGam_g_)
                                                    =   gamPop @decls.patTyKiGam
                decls       .   tyGam               :=  gamPushGam @tyGam_l_ @lhs.tyGam
                            .   tyKiGam             =   gamPushGam @tyKiGam_l_ @lhs.tyKiGam
                            .   kiVarMp             =   @decls.patKiVarMp
                loc         .   (lSubsTyKiGam,cycTyKiVarMp_l)
                                                    =   @decls.kiVarMp `varUpdCyc` @tyKiGam_l_
                            .   gSubsTyKiGam        =   @tyKiGam_g_
                            .   gKiTvS              =   @tyKiUpdFreeTvarS
                            .   lQuTyGam            =   @tyGam_l_extra
                            .   lQuTyKiGam_qu       =   tyKiGamQuantify @gKiTvS @lSubsTyKiGam
                            .   lQuTyKiGam_ex       =   tyKiGamInst1Exists @lUniq3 @lQuTyKiGam_qu
                            .   lQuTyKiGam          =   @lQuTyKiGam_ex_extra
                            .   lQuTyKiGam_ex_extra =   gamUnion @extraTyKiGam @lQuTyKiGam_ex
                            .   lQuTyKiGam_ex_subst =   @lQuTyKiGam_ex_extra
                body        .   tyGam               =   gamAddGam @lQuTyGam @tyGam_g_
                            .   tyKiGam             =   gamAddGam @lQuTyKiGam @gSubsTyKiGam
                loc         .   lUniq3              :   UNIQUEREF gUniq

SEM Decl
  | TySig       tyExpr      .   tyGam               =   gamPushNew @lhs.tyGam
                            .   tyKiGam             =   gamPushNew @lhs.tyKiGam
                loc         .   fo_                 =   fitsIn weakFIOpts defaultFIEnv @lUniq2 @tyExpr.kiVarMp @tyExpr.ki kiStar
                lhs         .   kiVarMp             =   foVarMp @fo_ `varUpd` @tyExpr.kiVarMp
                loc         .   lUniq2              :   UNIQUEREF gUniq

SEM Expr
  | TypeAs      tyExpr      .   tyGam               =   gamPushNew @lhs.tyGam
                            .   tyKiGam             =   gamPushNew @lhs.tyKiGam

SEM Expr
  | Let         loc         .   (lQuTyKiGam_qu,quTyKiVarMp, cycTyKiVarMp_l)
                                                    :=  tyKiGamQuantifyWithVarMp @decls.kiVarMp @gKiTvS @tyKiGam_l_
                            .   bodyTyKiVarMp1      =   @quTyKiVarMp `varUpd` @decls.kiVarMp
                            .   (lQuTyKiGam_ex,exTyKiVarMp2)
                                                    :=  tyKiGamInst1ExistsWithVarMp @bodyTyKiVarMp1 @lUniq3 @lQuTyKiGam_qu
                            .   bodyTyKiVarMp2      =   @exTyKiVarMp2 `varUpd` @bodyTyKiVarMp1
                            .   lQuTyKiGam_ex_subst :=  @bodyTyKiVarMp2 `varUpd` @lQuTyKiGam_ex_extra
                body        .   kiVarMp             =   @bodyTyKiVarMp2

ATTR AllDecl [ | tyTyVarMp: VarMp | ]

SEM Expr
  | Let         decls       .   tyTyVarMp           =   emptyVarMp
                loc         .   lQuTyGam            :=  @decls.tyTyVarMp `varUpd` @tyGam_l_extra

SEM Expr
  | Case        loc         .   caseIds     =   maybe (Set.singleton uidStart) id @mbCaseIds

ATTR AllExpr AllTyExpr AllPatExpr AllData AllCase AllDecl [ kiGam: KiGam | | ]

SEM AGItf
  | AGItf       loc         .   kiVarMp             =   emptyVarMp

ATTR AllDecl [ | | gathTySigGam USE {`gamAddGam`} {emptyGam}: ValGam ]


SEM Decl
  | TySig       loc         .   gamSigTy            =   @tyExpr.ty
                            .   gathTySigGam        =   @nm `gamSingleton` ValGamInfo @gamSigTy

ATTR AllDecl AllPatExpr [ tySigGam: ValGam | | ]

SEM Expr
  | Lam
    LamImpl
                loc         .   tySigGam            =   emptyGam

SEM CaseAlt
  | Pat         loc         .   tySigGam            =   emptyGam

SEM Expr
  | Let         decls       .   tySigGam            =   @decls.gathTySigGam

SEM Decl
  | Val         loc         .   (ty_sig_,hasTySig)  =   case @patExpr.mbTopNm of
                                                          Nothing
                                                            ->  (Ty_Any,False)
                                                          Just nm
                                                            ->  case gamLookup nm @lhs.tySigGam of
                                                                  Nothing   -> (Ty_Any,False)
                                                                  Just vgi  -> (vgiTy vgi,True)

SEM Decl
  | TySig       loc         .   ty_sig_             =   tyQuantifyOuter (`Map.member` @tyExpr.tyVarWildMp) @tyExpr.ty
                            .   gamSigTy            :=  @ty_sig_

SEM Decl
  | TySig       loc         .   gTyTvS              =   varFreeSet . map (tgiTy.snd) . gamToAssocL $ @lhs.tyGam
                            .   ty_sig_             :=  let fv  = Map.keysSet @tyExpr.tyVarWildMp `Set.union` @gTyTvS
                                                            t   = varmpIncMetaLev @lhs.finKiVarMp `varUpd` @tyExpr.ty
                                                            tkg = gamUnion @lhs.finTyKiGam @tyExpr.intlTyKiGam
                                                            t2k = tvarKi tkg @lhs.finKiVarMp emptyVarMp
                                                        in  tyQuantifyOuter t2k (`Set.member` fv) t

SEM Decl
  | TySig       loc         .   gTyTvS              :=  @tyTyUpdFreeTvarS

SEM Decl
  | FFI
    FFE
                loc         .   ty_sig_             =   let t   = varmpIncMetaLev @lhs.finKiVarMp `varUpd` @tyExpr.ty
                                                            tkg = gamUnion @lhs.finTyKiGam @tyExpr.intlTyKiGam
                                                            t2k = tvarKi tkg @lhs.finKiVarMp emptyVarMp
                                                        in  tyQuantifyOuter t2k (const False) t
                lhs         .   gathTySigGam        =   @nm `gamSingleton` ValGamInfo @ty_sig_

SEM Decl
  | FFI
                loc         .   foreignEntInfo      =   foreignEntExtract @impEnt
                            .   knTy                =   let v      = mkTyVar @lUniq
                                                            funptr = mk1ConApp (ehcOptBuiltin @lhs.opts ehbnFunPtr)
                                                            io     = mk1ConApp (ehcOptBuiltin @lhs.opts ehbnIO)
                                                        in  case targetIsJavaScript (ehcOptTarget @lhs.opts) of
                                                              True  -> let v1            = mkTyVar @lUniq2
                                                                           wrappedFunptr = mkApp [v1, funptr v]
                                                                       in case @foreignEntInfo of
                                                                            ForeignExtraction_Wrapper -> Ty_Any -- v `mk1Arrow` io wrappedFunptr
                                                                            ForeignExtraction_Dynamic -> Ty_Any -- wrappedFunptr `mk1Arrow` v
                                                                            _                         -> Ty_Any
                                                              False -> case @foreignEntInfo of
                                                                        ForeignExtraction_Wrapper -> v `mk1Arrow` io (funptr v)
                                                                        ForeignExtraction_Dynamic -> funptr v `mk1Arrow` v
                                                                        _                         -> Ty_Any
                            .   foFFI               =   fitsIn strongFIOpts @fe @lUniq3 (emptyVarMp :: VarMp) @ty_sig_ @knTy
                loc         .   lUniq               :   UNIQUEREF gUniq
                loc         .   lUniq2              :   UNIQUEREF gUniq
                loc         .   lUniq3              :   UNIQUEREF gUniq
                loc         .   foreignEntInfo      :   ForeignExtraction

ATTR AllDecl [ kiSigGam: TyGam | gathKiSigGam: TyGam | ]

SEM Expr
  | Let         decls       .   gathKiSigGam        =   emptyGam
                            .   kiSigGam            =   @decls.gathKiSigGam

SEM Decl
  | KiSig       lhs         .   gathKiSigGam        =   gamAdd @nm (mkTGI (Ty_Con @nm)) @lhs.gathKiSigGam

ATTR AllDecl [ tyKiSigGam: TyKiGam | | gathTyKiSigGam USE {`gamUnion`} {emptyGam}: TyKiGam ]

SEM Decl
  | KiSig       lhs         .   gathTyKiSigGam      =   tyKiGamNameSingleton @nm (TyKiGamInfo @sigKi)

SEM Expr
  | Let         decls       .   tyKiSigGam          =   @decls.gathTyKiSigGam

SEM Decl
  | Data
    Type
                loc         .   (sigKi,hasKiSig)    =   case tyKiGamLookupByName @tyNm @lhs.tyKiSigGam of
                                                          Nothing -> (Ty_Any,False)
                                                          Just i  -> (tkgiKi i,True)

SEM Decl
  | KiSig       loc         .   sigKi               =   tyKiQuantify (const False) @kiExpr.ki

ATTR AllDecl [ | patClGam1: ClGam  patClGam2: ClGam | ]
ATTR NTPrf AllPrExpr AllTyExpr AllData AllPatExpr [ clGam: ClGam | | ]

SEM Expr
  | Let         decls       .   patClGam1           =   gamPushNew @lhs.clGam
                            .   patClGam2           =   @decls.patClGam1
                loc         .   (lClGam,_)          =   gamPop @decls.patClGam2
                            .   lClGamNoDups        =   gamNoDups @lClGam
                            .   forDeclsClGam       =   gamPushGam @lClGamNoDups @lhs.clGam
                decls       .   clGam               =   @forDeclsClGam
                body        .   clGam               =   gamAddGam @lClGamNoDups @lhs.clGam

SEM Expr
  | Let         loc         .   extraTyGam          =   @generTyGam
                            .   extraTyKiGam        =   @generTyKiGam
                            .   extraDataGam        =   @generDataGam
                            .   extraPolGam         =   @generPolGam

