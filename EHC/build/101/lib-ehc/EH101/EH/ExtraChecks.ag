SEM Expr
  | Let         loc         .   dupErrs             =   if ehcOptHsChecksInEH @lhs.opts
                                                        then let nms = assocLKeys $ gamToOnlyDups $ gamTop @decls.patValGam
                                                             in  if null nms
                                                                 then []
                                                                 else [rngLift @range Err_NamesDupIntrod "value" (zip nms (repeat Nothing))]
                                                        else []


SEM Decl
  | Data        loc         .   inconsistFldErrs    =   let  ft = gamToOnlyDups @constrs.fldSelGam
                                                             wrong tl = foHasErrs fo
                                                                      where fo = fitsInFold opts @fe uidStart @lhs.finTyVarMp $ map (tyArrowRes . vgiTy) $ tl
                                                                            (tlvars,tl') = unzip [ (varFreeSet t', t') | t <- tl, let t' = tyArrowRes (vgiTy t) ]
                                                                            opts = unifyFIOpts { fioDontBind = Set.unions tlvars }
                                                             nms = [ f | (f,tl) <- ft, wrong tl ]
                                                        in   if null nms then [] else [rngLift @range Err_InconsistentIntros "data field" nms]

SEM DataConstr
  | Constr      loc         .   dupErrs             =   let  nms = assocLKeys $ gamToOnlyDups @fields.fldSelGam
                                                        in   if null nms then [] else [rngLift @range Err_NamesDupIntrod "data field" (zip nms (repeat Nothing))]

SEM Expr
  | DataFields  loc         .   fldMissErrs         =   case @dataFieldExpr.mbDti of
                                                          Just dti | not (Set.null m)
                                                            -> [rngLift @range Err_MissingDataFields (Set.toList m) (dtiConNm dti)]
                                                            where m = Map.keysSet (dtiFldMp dti) `Set.difference` Set.fromList @fldL
                                                          _ | null @dtiInFldL -> [rngLift @range Err_MissingAnyDataField @fldL (dgiTyNm @dgi)]
                                                            | otherwise       -> []
                            .   fldDupErrs          =   let fs = [ f | (f:_:_) <- group @fldL ]
                                                        in  if null fs then [] else [rngLift @range Err_DuplicateDataFields fs]

SEM Expr
  | Let         loc         .   occCycTyErrs        =   rngLift @range varmpOccurErr @tyVarMpDeclsL0 $ @cycTyVarMp_l {- `varmpUnion` @cycTyVarMp_g -}


SEM Expr
  | Let         loc         .   occCycTyKiErrs      =   rngLift @range varmpOccurErr @decls.kiVarMp $ @cycTyKiVarMp_l {- `varmpUnion` @cycTyKiVarMp_g -}

{
checkClNms :: Range -> HsNameS -> [Err]
checkClNms r s = if Set.null s then [] else [mkErr_NamesNotIntrod r "class" (Set.toList s)]

}
{
mkRangedPred :: RangeMp -> Pred -> (Pred,[Range])
mkRangedPred rm pr = (pr,Map.findWithDefault [] pr rm)

}
{
mkPrvErr :: RangeMp -> Range -> CHRPredOccCnstrTraceMp -> [Err]
mkPrvErr rm r m
  = if Map.null m
    then []
    else [Err_NotProvenPreds r [ (mkRangedPred rm pr, vlist $ map pp t) | (c,((_,t):_)) <- Map.toList m, let pr = cpoPr (cnstrPred c) ]]

}
SEM AGItf
  | AGItf       loc         .   predNotPrfErrs      =   mkPrvErr @rangeMp emptyRange @cannotProveCnstrMp

SEM Decl
  | Instance    loc         .   valNoSigErrs        =   let ns = gamKeys (gamTop @decls.patValGam) \\ gamKeys @tySigGam
                                                        in  if null ns
                                                            then []
                                                            else [rngLift @range Err_ValWithoutSig ns]
                loc         .   predNotPrfErrs      =   mkPrvErr @lhs.rangeMp @range @cannotProveCnstrMp
  | InstanceIntro
                loc         .   predErrs            =   if Set.null (varFreeSet @prExpr.ty) then [] else [rngLift @range Err_TyHasFreeTVars @prExpr.ty]

SEM PrExpr
  | Class       loc         .   nmErrs              =   if ehcOptHsChecksInEH @lhs.opts
                                                        then rngLift @range checkClNms @clMissNmS
                                                        else []

SEM Expr
  | Let         loc         .   predNotPrfErrs      =   mkPrvErr @lhs.rangeMp @range @cannotProveCnstrMp
                            .   predAmbigErrs       =   let (_,amb) = doPredAmbigSplit id @tqoGam @toQuantOverPrOccL
                                                            mkg = assocLMapElt (ppTy . vgiTy) . gamToAssocL
                                                        in  if null amb
                                                            then []
                                                            else [rngLift @range Err_AmbigPreds
                                                                    (map (mkRangedPred @lhs.rangeMp . poPr) amb)
                                                                    (mkg @quValGam_ex_subst) (mkg $ @tyVarMpDeclsL0 `varUpd` @valGam_l_)
                                                                 ]

SEM Expr
  | AppImpl LamImpl
                loc         .   nmErrs              =   []

SEM Decl
  | Instance    loc         .   derivErrs           =   let mke m = [rngLift @range Err_NoDerivForData @derivHdDataTy @instClsNm m]
                                                            hasFlds = any (\t -> ctagArity t > 0)
                                                            builtinNms = ehcOptBuiltinNames @lhs.opts
                                                        in  case ( Map.lookup @instClsNm @derivMp
                                                                 , @instVariant
                                                                 , panicJust "Decl.Instance.dataGamTagsOfTy" $ dataGamTagsOfTy (tgiTy @derivDataTGI) @lhs.dataGam
                                                                 )
                                                            of
                                                              (Nothing,InstDeriving _,_)
                                                                | null @generForFitsInL
                                                                -> [rngLift @range Err_NoDerivFor @tyPrExpr.pp]
                                                              (Just _,InstDeriving _,[])
                                                                -> mke "has no constructors"
                                                              (Just _,InstDeriving _,ctags)
                                                                | @instClsNm `elem`
                                                                     [ ehbnClassEnum builtinNms
                                                                     , ehbnClassIx   builtinNms
                                                                     ]
                                                                  && hasFlds ctags
                                                                  -> mke "has a constructor with >0 fields"
                                                              (Just _,InstDeriving _,ctags@(_:_:_))
                                                                | @instClsNm == ehbnClassBounded builtinNms
                                                                  && hasFlds ctags
                                                                  -> mke "has >1 constructors, of which >0 with fields"
                                                              _ -> []

SEM Decl
  | FusionConv          loc .   foBuildInverse      =   let opts = unifyFIOpts { fiMbMkErrClash = Just $ rngLift @range Err_FusionBuildInverse }
                                                        in  fitsIn opts @fe @lUniq_buildInverse @lhs.finTyVarMp @finConTy (tyArrowInverse @finAbsTy)
                        loc .   lUniq_buildInverse  :   UNIQUEREF gUniq

