INCLUDE "Core/CommonLevLet.ag"
ATTR AllNT [ topClassNm: HsName  pkgNm: HsName | | ]
ATTR AllNT - CodeAGItf CModule [ moduleClassNm: HsName | | ]
ATTR CodeAGItf CModule [ | | moduleClassNm: HsName ]

SEM CModule
  | Mod         loc         .   topClassNm      =   @moduleNm
                            .   pkgNm           =   @moduleNm
                            .   moduleClassNm   =   hsnSetQual @moduleNm $ hsnQualified @moduleNm

SEM CodeAGItf
  | AGItf       loc         .   topClassNm      =   hsnUnknown
                            .   pkgNm           =   hsnUnknown

ATTR AllExprOnly CBound [ mbLamNm: {Maybe (HsName,HsName)} | | ]

SEM CExpr
  | App Lam     loc         .   mbLamNm         =   Nothing

SEM CAlt
  | Alt         loc         .   mbLamNm         =   Nothing

SEM CBound
  | Bind Val
    FFE
                expr        .   mbLamNm         =   Just (@varnm,@lhs.nm)

SEM CPatFld
  | Fld         offset      .   mbLamNm         =   Nothing

SEM CModule
  | Mod         expr        .   mbLamNm         =   Nothing

SEM CBoundL
  | Cons        hd          .   mbLamNm         =   Nothing

SEM CExpr
  | Lam         loc         .   (hasFunHere,(lamNm,origLamNm))
                                                =   if @lhs.whatAbove /= ExprIsLam
                                                    then (True,fromJust @lhs.mbLamNm)
                                                    else (False,(hsnUnknown,hsnUnknown))

SEM CBound
  | Bind Val    loc         .   isCAF           =   @expr.whatBelow /= ExprIsLam

ATTR AllBind [ | | bindNmL USE {++} {[]} : {[HsName]} ]

SEM CBind
  | Bind        loc         .   bindNmL         =   [@nm]

ATTR AllNT [ cvarMp: CVarMp | | ]

SEM CodeAGItf
  | AGItf       loc         .   cvarMp          =   Map.empty


ATTR AllPat [ | | patCVarMp USE {`Map.union`} {Map.empty} : CVarMp ]

SEM CPatFld
  | Fld         loc         .   patCVarMp       =   Map.singleton @fldNm @cviField

SEM CExpr
  | Lam         loc         .   cvarMp          =   Map.fromList @lamBindings `Map.union` @lhs.cvarMp
  | Let         loc         .   (nLocals,cvarMpNew)
                                                =   if @isGlobal
                                                    then (0,Map.empty)
                                                    else let nLocals = length @binds.bindNmL
                                                         in  ( nLocals
                                                             , Map.fromList
                                                                 [ (n,CVarInfo_Local tyDefault o)
                                                                 | (n,o) <- @nmToRefAssocL
                                                                 ]
                                                             )
                            .   cvarMp          =   @cvarMpNew `Map.union` @lhs.cvarMp

SEM CAlt
  | Alt         loc         .   cvarMpOffsets   =   Map.fromList [ (n,cvi) | (n,cvi,_) <- @pat.offsetBinds ]
                expr        .   cvarMp          =   Map.unions [@cvarMpOffsets, @pat.patCVarMp, @lhs.cvarMp]

SEM CExpr
  | Var         loc         .   cvi             =   Map.findWithDefault (cvarGlob tyDefault @lhs.moduleClassNm @nm @varnm) @nm @lhs.cvarMp

ATTR CExpr [ | | nmArgL: {[HsName]} ]

SEM CExpr
  | Lam         loc         .   nmArgL      =   @argNm : @body.nmArgL
                loc         .   nmArgL      :   {[HsName]}
  | * - Lam Ann lhs         .   nmArgL      =   []

ATTR AllAlt AllPat [ scrutineeCVarInfo: CVarInfo | | ]

ATTR AllPatFld [ ctag: CTag | | ]

SEM CPat
  | Con         binds       .   ctag            =   @tag

ATTR AllAlt CPat [ | | scrutinees USE {++} {[]} : {[Scrutinee]} ]

SEM CPat
  | Con         lhs         .   scrutinees      =   [Scrutinee_Tag @tag]
  | Var         lhs         .   scrutinees      =   [Scrutinee_Var @pnm]
  | Int         lhs         .   scrutinees      =   [Scrutinee_Int @int]
  | Char        lhs         .   scrutinees      =   [Scrutinee_Other "char"]
  | * - Con Var Int Char Ann
                lhs         .   scrutinees      =   [Scrutinee_Other "other"]

ATTR AllBind CExpr [ | | jbinds USE {`Seq.union`} {Seq.empty}: JBinds]

SEM CExpr
  | Let         lhs         .   jbinds          =   @jbindsLet `Seq.union` @body.jbinds

