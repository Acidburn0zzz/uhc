MODULE {EH101.Core.Trf.EtaRed} {cmodTrfEtaRed}
{
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Core
import EH101.Ty
import EH101.AbstractCore

}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonPred.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/Trf/CommonFv.ag"
INCLUDE "Core/CommonBindNm.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
cmodTrfEtaRed :: CModule -> CModule
cmodTrfEtaRed cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t

}
{
type MbApp = Maybe ((CExpr,FvS),CBound)

}
ATTR CExpr [ | | mbApp: MbApp  mbFunAppL: {[MbApp]} ]

SEM CExpr
  | App         lhs         .   mbApp       =   case @func.appFunKind of
                                                  AppFunKind_Tag _  -> Nothing
                                                  AppFunKind_FFI    -> Nothing
                                                  _                 -> Just ((@func.cTrf,@func.fvS),@arg.cTrf)
                            .   mbFunAppL   =   @func.mbApp : @func.mbFunAppL
  | Lam         lhs         .   (mbApp,mbFunAppL)
                                            =   case @body.mbFunAppL of
                                                  (f:fs) | @isMatch
                                                    -> (f,fs)
                                                  _ -> (Nothing,@body.mbFunAppL)
  | * - App Lam Ann
                lhs         .   mbApp       =   Nothing
                            .   mbFunAppL   =   []

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | Lam         (loc.cNew,loc.isMatch)      =   case @body.mbApp of
                                                  Just ((f,fFvS),v) | isJust mbV && a == @argNm && not (a `Set.member` fFvS)
                                                    -> (f,True)
                                                    where mbV@(~(Just a)) = acoreExprMbVar $ acoreUnBoundVal v
                                                  _ -> (@cTrf,False)
                lhs         .   cTrf        =   @cNew

