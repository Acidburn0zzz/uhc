MODULE {EH101.Core.Trf.InlineLetAlias} {cmodTrfInlineLetAlias}
{
import Data.Maybe
import qualified Data.Map as Map
import qualified Data.Set as Set
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Core
import EH101.Ty
import EH101.AbstractCore
import EH.Util.Utils
import qualified Data.Set as Set

}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/Trf/CommonFv.ag"
INCLUDE "Core/Trf/CommonLev.ag"
WRAPPER CodeAGItf

{
}
{
}
PRAGMA nocycle

{
cmodTrfInlineLetAlias :: HsNameS -> CModule -> CModule
cmodTrfInlineLetAlias globNmS cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf {noTrfNmS_Inh_CodeAGItf = globNmS})
     in   cTrf_Syn_CodeAGItf t

}
ATTR CodeAGItf AllExprOnly CModule AllBind [ noTrfNmS: HsNameS | | ]

SEM CAlt
  | Alt         loc         .   noTrfNmS    =   Set.empty

SEM CPatFld
  | Fld         loc         .   noTrfNmS    =   Set.empty

{
type NmMp = Map.Map HsName CExpr

}
ATTR AllCodeNT [ nmMp: NmMp | | ]

SEM CodeAGItf
  | AGItf       module      .   nmMp        =   Map.empty

SEM CExpr
  | Let         loc         .   allowTrf    =   @categ /= CBindCateg_Strict
                                                && @categ /= CBindCateg_FFI
                                                && @categ /= CBindCateg_FFE
                            .   allowStrTrf =   @categ /= CBindCateg_FFI
                                                && @categ /= CBindCateg_FFE
                            .   nmMpNew     =   Map.foldrWithKey
                                                  (\n r m
                                                    -> case r of
                                                         CExpr_Var ref
                                                           | nm `Map.member` @binds.bindNmMp
                                                             -> m
                                                           | @allowTrf || (@allowStrTrf && cexprIsEvaluated r')
                                                             -> Map.insert n r' m
                                                           where nm = acbrefNm ref
                                                                 r' = maybe r id . Map.lookup nm $ @lhs.nmMp
                                                         _ | @allowTrf
                                                             -> Map.insert n r m
                                                         CExpr_Int i
                                                           | @allowStrTrf
                                                             -> Map.insert n r m
                                                         _   -> m
                                                  )
                                                  Map.empty
                                                  @binds.bindNmMp
                            .   nmMp        =   Map.union @nmMpNew $ Map.difference @lhs.nmMp @binds.cvarIntroExprMp
  | Lam			body		.	nmMp		=	Map.delete @argNm @lhs.nmMp

SEM CAlt
  | Alt         expr        .   nmMp		=	foldr Map.delete @lhs.nmMp @pat.nmL


ATTR CExpr [ | | mbRepl: {Maybe CExpr} ]

SEM CExpr
  | Var         lhs         .   mbRepl      =   Just @cTrf
  | Int
    Char        lhs         .   mbRepl      =   if @lhs.allowTrfToCon
                                                then Just @cTrf
                                                else Nothing
  | * - Ann
        Var
        Int
        Char    lhs         .   mbRepl      =   Nothing

ATTR AllBind [ | | bindsNoTrfNmS USE {`Set.union`} {Set.empty}: HsNameS ]

ATTR AllBind [ | | bindNmMp USE {`Map.union`} {Map.empty}: NmMp ]
ATTR AllBind [ | | bindL USE {++} {[]}: {[(HsName,CBind)]} ]


SEM CBound
  | Bind        lhs         .   (bindNmMp,bindL)
                                            =   case @expr.mbRepl of
                                                  Just r | @lhs.nm /= hsnMain
                                                           && not (@lhs.nm `Set.member` @lhs.noTrfNmS)
                                                    -> (@lhs.nm `Map.singleton` r,[(@lhs.nm,acoreBind1Asp1 @lhs.nm @cTrf)])
                                                  _ -> (Map.empty,[(@lhs.nm,acoreBind1Asp1 @lhs.nm @cTrf)])


ATTR AllExprOnly AllAlt AllBind [ allowTrfToCon: {Bool} | | ]

SEM CModule
  | Mod   expr.allowTrfToCon  =  True

SEM CPatFld
  | Fld   offset.allowTrfToCon  =  True
  		  bind  .allowTrfToCon  =  False



ATTR AllExprOnly AllBind AllAlt [ noTrfToConNmS : HsNameS | | ]

SEM CModule
  | Mod   expr.noTrfToConNmS  =  Set.empty

SEM CPatFld
  | Fld   offset.noTrfToConNmS  =  Set.empty
  		  bind  .noTrfToConNmS  =  Set.empty


SEM CBound
  | Bind  expr.allowTrfToCon  =  not (@lhs.nm `Set.member` @lhs.noTrfToConNmS)
          expr.noTrfToConNmS  =  @lhs.noTrfToConNmS `Set.union` @bindMeta.nameS


ATTR AllBound   [ aspBindNmMp: {ACoreBindAspMp NmMp} | | gathAspBindNmMp USE {`Map.union`} {Map.empty}: {ACoreBindAspMp NmMp} ]

SEM CBind
  | Bind		loc			.	aspBindNmMp =	@bindAspects.gathAspBindNmMp

SEM CBound
  | Bind  		lhs			.	gathAspBindNmMp
  											=	Map.singleton acbaspkeyDefault @expr.bindNmMp

SEM CExpr
  | App			arg			.	aspBindNmMp	=	Map.empty

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | Let         lhs         .   cTrf        =   if Map.null @nmMpNew
                                                then @cTrf
                                                else acoreLet @categ
                                                       [ b | (n,b) <- @binds.bindL
                                                           , not (n `Map.member` @nmMpNew)
                                                             || n `Set.member` @binds.bindsNoTrfNmS
                                                       ] @body.cTrf
  | Var         lhs         .   cTrf        =   maybe @cTrf id $ Map.lookup @nm $ @lhs.nmMp

SEM CBound
  | FFE         loc         .   bindsNoTrfNmS
                                            =   @expr.fvS

ATTR CExpr           [ | | bindNmMp     USE {`Map.union`} {Map.empty}: NmMp ]

ATTR AllMetaVal      [ bindNmMp: NmMp | | nameS: HsNameS ]

SEM CBound
  | Bind  		bindMeta	.	bindNmMp  	=  	@expr.bindNmMp
  | Meta  		cmetas  	.	bindNmMp  	=  	panicJust "InlineLetAlias.CBound.Meta.aspBindNmMp" $ Map.lookup acbaspkeyDefault @lhs.aspBindNmMp

SEM CMetaVal
  | Dict
    Val             lhs.nameS = Set.empty
  | DictClass
    DictInstance    lhs.nameS =  Set.fromList (concatMap trackNames @tracks)
  | * - Dict Val DictClass DictInstance
  					lhs.nameS =  Set.empty

SEM CMetaVal
  | DictClass       lhs.cTrf  =  CMetaVal_DictClass    (map (substTrack @lhs.bindNmMp) @tracks)
  | DictInstance    lhs.cTrf  =  CMetaVal_DictInstance (map (substTrack @lhs.bindNmMp) @tracks)


{
trackNames :: Track -> [HsName]
trackNames (TrackSelect n t) = trackNames t
trackNames (TrackVarApply x ts) = x : concatMap trackNames ts
trackNames _ = []

substTrack :: NmMp -> Track -> Track
substTrack m (TrackSelect n t) = TrackSelect n (substTrack m t)
substTrack m (TrackVarApply x ts) = TrackVarApply (maybe x (fromJust . cexprMbVar) (Map.lookup x m)) (map (substTrack m) ts)
substTrack _ t = t
}


