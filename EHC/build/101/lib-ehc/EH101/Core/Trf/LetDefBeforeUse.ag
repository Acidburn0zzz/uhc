MODULE {EH101.Core.Trf.LetDefBeforeUse} {cmodTrfLetDefBeforeUse}
{
import Data.Maybe
import EH101.Base.Common
import EH101.Core
import EH101.Ty
import EH101.AbstractCore
import qualified Data.Map as Map
import qualified Data.Set as Set
import EH101.Base.Debug
import EH101.Base.Builtin
import EH.Util.Utils (scc)

}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonLevLet.ag"
INCLUDE "Core/Trf/CommonFv.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
cmodTrfLetDefBeforeUse :: CModule -> CModule
cmodTrfLetDefBeforeUse cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CModule
  | Mod         loc         .   sccDefs     =   map (catMaybes . map (\n -> Map.lookup n @expr.defMp))
                                                $ scc [ (n, Set.toList $ defFvS d) | (n,d) <- Map.toList @expr.defMp ]
                            .   cTrf        =   let mk ds@(_:_:_) e = acoreLetRec              (map defCore ds) e
                                                    mk    [d]     e = acoreLet    (defCateg d) [defCore d]      e
                                                in  CModule_Mod
                                                      @moduleNm
                                                      (foldr mk @expr.letBody @sccDefs)
                                                      @ctagsMp

{
-- | A definition just administers the code (required for transformation) and what it uses (to reorder).
data Def
  = Def
      { defCateg        :: CBindCateg       -- the category of the binding
      , defCore         :: CBind            -- the actual code
      , defFvS          :: FvS              -- its used (free) vars
      }

emptyDef :: Def
emptyDef = Def CBindCateg_Rec (CBind_Bind hsnUnknown []) Set.empty

type DefMp = Map.Map HsName Def

defMpComb :: DefMp -> DefMp -> DefMp
defMpComb = Map.unionWith (\d1 d2 -> d1 {defFvS = defFvS d1 `Set.union` defFvS d2})

}
ATTR AllExpr AllBind [ | | defMp USE {`defMpComb`} {Map.empty} : DefMp ]

SEM CBind
  | Bind        lhs         .   defMp       =   Map.singleton @nm (emptyDef {defCore = @cTrf, defFvS = @bindAspects.fvS})

SEM CExpr
  | Let         lhs         .   defMp       =   if @isGlobal
                                                then Map.map (\d -> d {defCateg = @categ}) @binds.defMp `defMpComb` @body.defMp
                                                else Map.empty
  | * - Let Ann lhs         .   defMp       =   Map.empty

ATTR CExpr [ | | letBody : CExpr ]

SEM CExpr
  | Let         lhs         .   letBody     =   @body.letBody
  | * - Let     lhs         .   letBody     =   @cTrf
