MODULE {EH101.Core.Trf.LamGlobalAsArg} {cmodTrfLamGlobalAsArg}
{
import EH.Util.Utils
import Data.Maybe
import qualified Data.Set as Set
import Data.List
import qualified Data.Map as Map
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Core
import EH101.Ty
import EH101.Core.Utils
import EH101.AbstractCore
import EH101.Base.Debug
import EH.Util.Pretty
import Debug.Trace

}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/Trf/CommonFv.ag"
INCLUDE "Core/Trf/CommonLev.ag"
INCLUDE "Core/Trf/CommonGlobalAsArg.ag"
WRAPPER CodeAGItf

PRAGMA nocycle

{
cmodTrfLamGlobalAsArg :: CModule -> CModule
cmodTrfLamGlobalAsArg cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllCodeNT [ | gUniq: Int | ]

SEM CodeAGItf
  | AGItf       module      .   gUniq       =   0

SEM CBound
  | Bind        expr        .   gUniq       =   @lhs.gUniq + Map.size @argMpNew


ATTR AllCodeNT [ lamFvSMp: FvSMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamFvSMp    =   Map.empty

SEM CExpr
  | Let         loc         .   lamFvSMp    =   (let  start varS = fvsClosure @binds.bindLamS @lhs.lamS varS @lhs.lamFvSMp @binds.fvSMp
                                                 in   case @categ of
                                                        CBindCateg_Rec
                                                          ->  fvsTransClosure lm m
                                                          where (m,lm)  = start (@lhs.varS `Set.union` @binds.bindVarS)
                                                        _ ->  m
                                                          where (m,_)   = start @lhs.varS
                                                )
                                                `Map.union` @lhs.lamFvSMp

ATTR AllCodeNT [ argMp: CVarReplNmMp | | ]

SEM CodeAGItf
  | AGItf       module      .   argMp       =   Map.empty

SEM CBound
  | Bind        expr        .   argMp       =   @argMpNew `Map.union` @lhs.argMp

{
type AspBindLamArgInfo = (LamArgMp,Env)

}
ATTR AllBound   [ aspBindLamArgMp: {ACoreBindAspMp AspBindLamArgInfo} | | gathAspBindLamArgMp USE {`Map.union`} {Map.empty}: {ACoreBindAspMp AspBindLamArgInfo} ]

SEM CBind
  | Bind		loc			.	aspBindLamArgMp
  											=	@bindAspects.gathAspBindLamArgMp

SEM CBound
  | Bind  		lhs			.	gathAspBindLamArgMp
  											=	Map.singleton acbaspkeyDefault
  											                  ( @expr.bindLamArgMp
  											                  , @expr.envUp
  											                  )

SEM CExpr
  | App			arg			.	aspBindLamArgMp
  											=	Map.empty

{
type LamArgMp = Map.Map HsName CVarIntroL

}
ATTR AllBind CExpr [ | | bindLamArgMp USE {`Map.union`} {Map.empty}: LamArgMp ]
ATTR AllMetaVal [ bindLamArgMp: LamArgMp | | ]

SEM CBound
  | Meta  		cmetas  	.	( bindLamArgMp
                                , envFinal
                                ) 			=  	panicJust "LamGlobalAsArg.CBound.Meta.aspBindLamArgMp" $ Map.lookup acbaspkeyDefault @lhs.aspBindLamArgMp

ATTR AllCodeNT [ lamArgMp: LamArgMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamArgMp    =   Map.empty

SEM CExpr
  | Let         loc         .   lamArgMp    =   @binds.bindLamArgMp `Map.union` @lhs.lamArgMp

ATTR CMetaVal CMetas [ | | isInstance: {Bool} ]

SEM CMetaVal
  | DictInstance    lhs.isInstance = True
  | *-DictInstance  lhs.isInstance = False

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBound
  | Bind        loc         .   (argNewL,argMpNew,bindLamArgMp)
                                            =   if {- @isLiftable && not @isGlobal -} isJust @expr.mbLam
                                                then  let  argLevL = fvLAsArg @lhs.introCVarIntroMp $ panicJust "LamGlobalAsArg.CBind.Bind.argLevL" $ Map.lookup @lhs.nm $ @lhs.lamFvSMp
                                                           (argOL,argNL,argONMp) = fvLArgRepl @lhs.gUniq $ argLevL
                                                      in   (argNL, argONMp, @lhs.nm `Map.singleton` argOL)
                                                else  ([],Map.empty, Map.empty)

SEM CBound
  | Bind        lhs         .   cTrf        =   --trace ("use of global: " ++ show @lhs.nm ++ " uses " ++ show @bindLamArgMp ++ "\n"
                                                --      ++ (if @bindMeta.isInstance then ("instance " ++ show @lhs.nm ++ " finds " ++ show @expr.bindLamArgMp ++ "\n") else "")
                                                --      ) $
                                                (acoreBoundVal1Metas @lhs.nm @bindMeta.cTrf $ acoreLam [(n) | (n,cvi) <- @argNewL] @expr.cTrf)
                bindMeta    . bindLamArgMp  =  @expr.bindLamArgMp


SEM CExpr
  | Var         lhs         .   cTrf        =   let  r n = fvVarRepl @lhs.argMp n
                                                     v1 = r @nm
                                                     mk as = acoreApp v1 $ [(r a) | (a,cvi) <- as]
                                                     v2 = maybe v1 mk $ Map.lookup @nm $ @lhs.lamArgMp
                                                in   v2


{

type Env = Map.Map HsName Track

metaExtendTrack :: LamArgMp -> Env -> Track -> Track
metaExtendTrack mp env (TrackVarApply nm ps) = let r = Map.lookup nm mp
                                                   xs = maybe [] assocLKeys r
                                                   ts = map (\x -> Map.findWithDefault (TrackVarApply x []) x env) xs
                                               in  -- trace (show nm ++ " extended with " ++ show ts) $
                                                         (TrackVarApply nm (ts++ps))
metaExtendTrack _ _ t = t

}

ATTR AllExprOnly CBound [ mbCtxCount:{Maybe Int} isDictClass:{Bool} | | ]

SEM CModule
  | Mod  expr.mbCtxCount = Nothing
         expr.isDictClass = False

SEM CBoundL
  | Cons hd.mbCtxCount = Nothing
         hd.isDictClass = False

SEM CBound
  | FFE  expr.mbCtxCount = Nothing
         expr.isDictClass = False

SEM CAlt
  | Alt  expr.mbCtxCount = Nothing
         expr.isDictClass = False

SEM CPatFld
  | Fld  offset.mbCtxCount = Nothing
         offset.isDictClass = False

SEM CBound
  | Bind  expr.mbCtxCount = if @bindMeta.isDictInstance
                            then Just 0
                            else Nothing
          expr.isDictClass = @bindMeta.isDictClass
  | Val   expr.mbCtxCount = Nothing						-- TBD
          expr.isDictClass = False						-- TBD

SEM CExpr
  | Lam   body.mbCtxCount = do { n <- @lhs.mbCtxCount
                               ; return (n+1)
                               }
  | Let   body.mbCtxCount = Nothing
          body.isDictClass = False


ATTR CMetaVal CMetas [ | | isDictClass:Bool isDictInstance:Bool ]

SEM CMetaVal
  | DictClass      lhs.isDictClass    = True
  | *-DictClass    lhs.isDictClass    = False
  | DictInstance   lhs.isDictInstance = True
  | *-DictInstance lhs.isDictInstance = False



ATTR CMetas CMetaVal [ | | mbTrack : {Maybe Track} ]
ATTR CMetas CMetaVal [ envFinal:Env  | | ]


SEM CMetaVal
  | Track          lhs.mbTrack  =  Just @track
  | *-Track        lhs.mbTrack  =  Nothing

SEM CBound
  | Bind  bindMeta.envFinal = @expr.envUp


ATTR AllBind CExpr [ | | envUp USE {`Map.union`} {Map.empty} : Env ]

SEM CBound
  | Bind   lhs.envUp  =  maybe (Map.empty)
                               (\t -> Map.singleton @lhs.nm t)
                               @bindMeta.mbTrack

SEM CExpr
  | Let    lhs.envUp = Map.union @binds.envUp @body.envUp
  | Lam    lhs.envUp = maybe (if @lhs.isDictClass
                              then Map.insert @argNm TrackSelf @body.envUp
                              else @body.envUp
                             )
                             (\n -> Map.insert @argNm (TrackCtx n) @body.envUp)
                             @lhs.mbCtxCount
  | *-Let
      Lam  lhs.envUp = Map.empty


 SEM CMetaVal
   |  DictClass      lhs.cTrf = CMetaVal_DictClass    (map (metaExtendTrack @lhs.bindLamArgMp @lhs.envFinal) @tracks)
   |  DictInstance   lhs.cTrf = CMetaVal_DictInstance (map (metaExtendTrack @lhs.bindLamArgMp @lhs.envFinal) @tracks)

