MODULE {EH101.Core.Trf.FloatToGlobal} {cmodTrfFloatToGlobal}
{
import EH.Util.Utils
import qualified EH.Util.FastSeq as Seq
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Core
import EH101.Ty
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.List (partition)
import EH101.AbstractCore
import EH101.Base.Debug
import EH.Util.Pretty
import Debug.Trace

}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/Trf/CommonFv.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonLevLet.ag"
INCLUDE "Core/CommonPred.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/Trf/CommonFloat.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
cmodTrfFloatToGlobal :: CModule -> CModule
cmodTrfFloatToGlobal cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllBind AllExprOnly   [ isLocalInInstance : {Bool} | | ]
ATTR CMetaVal CMetas  [ | | isInstance : {Bool} ]

SEM CMetaVal
  | DictInstance        lhs         .   isInstance          =   True
  | * - DictInstance    lhs         .   isInstance          =   False

SEM CBound
  | Bind                expr        .   isLocalInInstance   =   -- trace ("Bind " ++ show @nm ++ " passes " ++ show @bindMeta.isInstance)  $
                                                                @bindMeta.isInstance || @lhs.isLocalInInstance


SEM CExpr
  | Let                 body        .   isLocalInInstance   =   -- trace ("Let passes to body " ++ show @lhs.isLocalInInstance)  $
                                                                @lhs.isLocalInInstance
                        binds       .   isLocalInInstance   =   -- trace ("Let passes to binds " ++ show @lhs.isLocalInInstance)  $
                                                                @lhs.isLocalInInstance
  | * - Let             loc         .   isLocalInInstance   =   False

SEM CAlt
  | Alt                 expr        .   isLocalInInstance   =   False

SEM CModule
  | Mod                 expr        .   isLocalInInstance   =   False

SEM CPatFld
  | Fld                 offset      .   isLocalInInstance   =   False
                        bind        .   isLocalInInstance   =   False

ATTR AllBind   [ | | cLamBinds,
                     cLargeCAFBinds,
                     cSmallCAFBinds   USE {`Seq.union`} {Seq.empty}: {Seq.FastSeq CBind}                          ]


SEM CBound
  | Bind        loc . cBindTrf          =   acoreBind1Asp1 @lhs.nm @cTrf
                lhs . ( cLamBinds
                      , cLargeCAFBinds
                      , cSmallCAFBinds
                      )                 =   if isJust @expr.mbLam
                                            then ( Seq.singleton @cBindTrf
                                                 , Seq.empty
                                                 , Seq.empty
                                                 )
                                            else if @loc.isClosurableBind
                                                    || @lhs.isLocalInInstance
                                            then ( Seq.empty
                                                 , Seq.singleton @cBindTrf
                                                 , Seq.empty
                                                 )
                                            else ( Seq.empty
                                                 , Seq.empty
                                                 , Seq.singleton @cBindTrf
                                                 )
  -- | FFI
  | FFE
                lhs . cSmallCAFBinds    =   Seq.singleton (acoreBind1Asp1 @lhs.nm @cTrf)


ATTR AllCodeNT [ | | cFloatedBindGrps USE {`Seq.union`} {Seq.empty}: {Seq.FastSeq (CBindCateg,Seq.FastSeq CBind)} ]

SEM CExpr
  | Let         lhs . cFloatedBindGrps  =   if @isGlobal
                                            then Seq.empty
                                            else @loc.bindingGroupsToFloat

SEM CExpr
  | Let         loc.( bindingsToKeep
                    , bindingsToFloat
                    )                   =   if @isGlobal
                                            then  ( @binds.cLargeCAFBinds `Seq.union` @binds.cSmallCAFBinds `Seq.union` @binds.cLamBinds
                                                  , Seq.empty
                                                  )
                                            else if @categ == CBindCateg_Strict
                                            then  ( @binds.cLargeCAFBinds `Seq.union` @binds.cSmallCAFBinds
                                                  , @binds.cLamBinds
                                                  )
                                            else  ( @binds.cSmallCAFBinds
                                                  , @binds.cLamBinds `Seq.union` @binds.cLargeCAFBinds
                                                  )


SEM CExpr
  | Let         loc.bindingGroupsToCertainlyInsert
                                        =   if @isGlobal
                                            then -- merge inner floating binds if a recursive group; by definition no strict defs are floated, plain defs safely can be recursive
                                                 case @categ of
                                                   CBindCateg_Rec -> Seq.singleton (@categ, (flatten $ Seq.map snd @binds.cFloatedBindGrps) `Seq.union` @loc.bindingsToKeep)
                                                   _              -> @binds.cFloatedBindGrps `Seq.union` Seq.singleton (@categ, @loc.bindingsToKeep)
                                            else Seq.singleton (@categ, @loc.bindingsToKeep)

SEM CExpr
  | Let         loc.bindingGroupsToPossiblyFloat
                                        =   if @isGlobal
                                            then Seq.empty
                                            else (Seq.singleton (@categ, @loc.bindingsToFloat) `Seq.union` @binds.cFloatedBindGrps `Seq.union` @body.cFloatedBindGrps)

SEM CExpr
  | Let         loc.( bindingGroupsToInsert
                    , bindingGroupsToFloat
                    )                   =   move (@loc.bindingGroupsToCertainlyInsert, @loc.bindingGroupsToPossiblyFloat)


{
flatten :: Seq.FastSeq (Seq.FastSeq a) -> Seq.FastSeq a
flatten = Seq.unions . Seq.toList

}
{
move insflt@(ins,flt)
  = insflt

}
ATTR CodeAGItf [ | | cTrf: CModule ]
ATTR AllCodeNT [ | | cTrf: SELF    ]

SEM CExpr
  | Let         lhs . cTrf              =   foldr (\(c,b) r -> acoreLet c (Seq.toList b) r) @body.cTrf
                                            $ Seq.toList @loc.bindingGroupsToInsert
