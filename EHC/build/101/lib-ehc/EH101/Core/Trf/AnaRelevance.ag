MODULE {EH101.Core.Trf.AnaRelevance} {cmodTrfAnaRelevance}
{
import EH101.Ty
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Gam
import EH101.Opts
import EH101.Base.Optimize
import EH101.Core
import EH101.VarMp
import EH101.Substitutable
import Data.Maybe
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Applicative
import EH.Util.Utils
import EH101.Foreign.Extract
import EH101.AbstractCore
import EH101.AnaDomain
import EH101.AnaDomain.Utils
import EH101.Gam
import EH101.Gam.DataGam
import EH101.LamInfo
import EH101.AnaDomain.Trf.Instantiate
import EH101.Base.Debug
import EH.Util.Pretty
import EH101.AnaDomain.Pretty
import EH101.BuiltinPrims
import EH101.Foreign
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonFFI.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/Trf/CommonStructureInfo.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/Trf/CommonFv.ag"
INCLUDE "Core/CommonLamInfo.ag"
INCLUDE "Core/CommonGathLamInfo.ag"
WRAPPER CodeAGItf

-- PRAGMA strictcase
PRAGMA nocycle

{
cmodTrfAnaRelevance
  :: EHCOpts
     -> DataGam
     -> LamMp
     -> CModule
     -> ( CModule
        , LamMp
        )
cmodTrfAnaRelevance
     opts dataGam
     lamMp
     cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { opts_Inh_CodeAGItf = opts
                               , dataGam_Inh_CodeAGItf = dataGam
                               , lamMp_Inh_CodeAGItf = lamMp
                               })
     in   ( cTrf_Syn_CodeAGItf t
          , gathLamMp_Syn_CodeAGItf t
          )

}
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]

{
data WhatToRelevInfer
  = WhatToRelevInfer_InstToBot			-- specialize/instantiate types to bot (strict)
  | WhatToRelevInfer_Quant				-- quantify
  deriving Eq

}
ATTR AllCodeNT [ whatTo: {[WhatToRelevInfer]} | | ]

SEM CodeAGItf
  | AGItf       loc         .   whatTo          =   case optimizeOptionStictnessAnalysisQuant (ehcOptOptimizeOptionMp @lhs.opts) of
                                                      OptimizeOptionValue_StrictnessAnalysis_NoQuant          -> [                                                    ]
                                                      OptimizeOptionValue_StrictnessAnalysis_QuantInstantiate -> [ WhatToRelevInfer_Quant, WhatToRelevInfer_InstToBot ]
                                                      _ {- OptimizeOptionValue_StrictnessAnalysis_Quant -}    -> [ WhatToRelevInfer_Quant                             ]

SEM CodeAGItf
  | AGItf       loc         .	howUnionGathLamInfo
  												=	id

SEM CodeAGItf
  | AGItf       loc         .   howMergeLamInfo	=   (\(LamInfo {laminfoBindAspMp=m}) i -> i {laminfoBindAspMp = m `Map.union` laminfoBindAspMp i})

SEM CBound
  | Bind        loc         .   doBindStrict    =   WhatToRelevInfer_InstToBot `elem` @lhs.whatTo
                lhs         .   bindLamMp       =   let l = [ (acbaspkeyDefaultRelevTy, LamInfoBindAsp_RelevTy @bindTy) ]
                                                            -- ++ (if @doBindStrict then [(acbaspkeyStrict, LamInfoBindAsp_RelevTy @strictTy2)] else [])
                                                    in  Map.singleton @lhs.nm (emptyLamInfo {laminfoBindAspMp = Map.fromList l})
                loc         .   doBindStrict    :   Bool

ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]

SEM *
  | *           loc         .   amso            :   {AMSOut RelevTy}
                loc         .   amsoUp          :   {AMSOut RelevTy}
                loc         .   amsoDw          :   {AMSOut RelevTy}
                loc         .   ams             :   AnaMatchState
                loc         .   amsUp           :   AnaMatchState
                loc         .   amsDw           :   AnaMatchState
                loc         .   bindTy          :   RelevTy
                loc         .   quantTy         :   RelevTy

{
type REnv    = Gam HsName RelevTy

-- | lookup in REnv first, then global LamMp
renvLookup :: HsName -> REnv -> LamMp -> Maybe RelevTy
renvLookup n renv lammp = gamLookup n renv <|> (fmap libindaspRelevTy $ lamMpLookupAsp n acbaspkeyDefaultRelevTy lammp)

}
ATTR AllCodeNT [ | gUniq: UID | ]

SEM CodeAGItf
  | AGItf       loc         .   gUniq           =   uidStart



ATTR AllCodeNT [ env: REnv | | ]

SEM CodeAGItf
  | AGItf       loc         .   env             =   emptyGam

SEM CBound
  | Bind        expr        .   env             =   gamAddGam @exprEnv @lhs.env

SEM CExpr
  | Var         loc         .   mbEnvTy         =   fmap (relevtyInst @lUniq) (renvLookup @nm @lhs.env @lhs.lamMp)
                            .   (envTy,envQualS)=   maybe (top, Set.empty) id @mbEnvTy
                loc         .   envTy           :   RelevTy
                loc         .   envQualS        :   RelevQualS
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Let         binds       .   env             =   gamAddGam @binds.gathRecEnv @lhs.env
                body        .   env             =   gamAddGam @binds.gathEnv    @lhs.env

SEM CAlt
  | Alt         loc         .   mbCTagEnv       =   do { ct <- @pat.mbCTag
                                                       ; (argTyL,_) <- relevTyArgsFromCTag True ct Nothing (length @pat.fldNmL) @lhs.dataGam @lUniq
                                                       ; return (gamFromAssocL $ zip @pat.fldNmL argTyL, argTyL)
                                                       }
                loc         .   patFldGivenTyL  =   maybe (map freshLazy $ mkNewLevUIDL (length @pat.fldNmL) @lUniq3)
                                                          snd @mbCTagEnv
                            .   patFldUsedTyL   =   map fresh $ mkNewLevUIDL (length @pat.fldNmL) @lUniq2
                            .   patEnv          =   gamFromAssocL $ zip @pat.fldNmL @patFldUsedTyL
                                                    -- maybe (gamFromAssocL $ zip @pat.fldNmL @patFldUsedTyL)
                                                    --       id @mbCTagEnv
                pat         .   patFldTyL       =   zip @patFldGivenTyL @patFldUsedTyL
                expr        .   env             =   gamAddGam @patEnv @lhs.env
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq
                loc         .   lUniq3          :   UNIQUEREF gUniq
                loc			.	patFldUsedTyL	:	{[RelevTy]}

ATTR CPat CPatFldL CPatFld [ | patFldTyL: {[(RelevTy,RelevTy)]} | ]

SEM CPatFld
  | Fld         (loc.patFldTy,lhs.patFldTyL)    =   hdAndTl' (panic $ "patFldTyL: " ++ show @fldNm) @lhs.patFldTyL
                loc         .   fldCoe          =   let (tgiven,tused) = @patFldTy
                                                    in  RelevCoe_CastTy tgiven tused


ATTR AllBind -- AllPatFld AllPat
              [ | | gathEnv    USE {`gamUnion`} {emptyGam}: REnv ]
ATTR AllBind  [ | | gathRecEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CBound
  | Bind        loc         .   gathEnv         =   gamSingleton @lhs.nm @quantTy
                            .   gathRecEnv      =   gamSingleton @lhs.nm $ tup123to1 $ relevtyQuant [RelevTyQuantHow_Rec] emptyRVarMp Set.empty @ty

ATTR AllExpr [ knTy: RelevTy | | ]

SEM CModule
  | Mod         expr        .   knTy            =   RelevTy_None

SEM CBound
  | Bind        expr        .   knTy            =   @exprKnTy

SEM CExpr
  | App         arg         .   knTy            =   @argTy
                func        .   knTy            =   case @lhs.knTy of
                                                      RelevTy_Fun q v qs as r -> RelevTy_Fun q           v  qs (fresh @lUniq : as) r
                                                      t                       -> RelevTy_Fun RQuant_None [] [] [fresh @lUniq     ] t
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Case        expr        .   knTy            =   @lhs.knTy -- freshStrict @lUniq2
                loc         .   lUniq2          :   UNIQUEREF gUniq

SEM CPatFld
  | Fld         offset      .   knTy            =   @lhs.knTy -- Case

-- | the type of the case itself (instead of alternatives)
ATTR AllPat AllAlt [ knTyCase: RelevTy | | ]

SEM CExpr
  | Case        alts        .   knTyCase        =   @lhs.knTy

SEM CAltL
  | Cons        hd          .   knTy            =   @altKnDwTy

SEM CExpr
  | Int Char    loc         .   litTy           =   bot
                            .   (amso,ams)      =   amsLE @lhs.rvarMp @litTy @lhs.knTy
                loc         .   litTy           :   RelevTy
  | Var         loc         .   (amso,ams)      =   let mk envTy knTy
                                                          = case (envTy,knTy) of
                                                              (RelevTy_Ana ana,t@(RelevTy_Fun _ _ _ a r@(RelevTy_Ana rAna)))
                                                                -> ( amso' {amsoCoe = RelevCoe_Eval ana rAna <.> RelevCoe_CastTy envTy envTy' <.> amsoCoe amso'}
                                                                   , ams'  {amsGathQual = Set.insert (RelevQual_SubEval ana rAna) $ amsGathQual ams'}
                                                                   )
                                                                where (amso',ams') = amsLE @lhs.rvarMp envTy' t
                                                                      envTy' = anaMkBotFun $ length a
                                                                      ty'@(RelevTy_Ana ana') = fresh @lUniq2
                                                              (t1,t2)
                                                                -> ( amsoMkOk t1 t2 (RelevCoe_CastTy t1 t2)
                                                                   , emptyAnaMatchState
                                                                   )
                                                    in  case @mbEnvTy of
                                                          Just (envTy,_)
                                                            | amsoIsOk amso -> o
                                                            | otherwise     -> mk envTy @lhs.knTy
                                                            where o@(amso,ams) = amsLE @lhs.rvarMp envTy @lhs.knTy
                                                          _                 -> mk (fresh @lUniq3) @lhs.knTy
                loc         .   lUniq2          :   UNIQUEREF gUniq
                loc         .   lUniq3          :   UNIQUEREF gUniq
  | Tup         loc         .   (tupTy,tupQualS)=   let r = fresh @lUniq2
                                                        arity = whatExprAppArity @lhs.whatAbove
                                                    in  maybe (RelevTy_Err "CExpr.Tup.tupTy", Set.empty) (\(a,qs) -> (RelevTy_Fun RQuant_None [] [] a r, qs))
                                                        $ relevTyArgsFromCTag False @tag (Just r) arity @lhs.dataGam @lUniq
                            .   (amso,ams)      =   amsLE @lhs.rvarMp @tupTy @lhs.knTy
                loc         .   tupTy           :   RelevTy
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq
  | FFI         loc         .   (ffiTy,ffiQualS)=   let (r@(RelevTy_Ana re) ,qr) = (fresh @lUniq, [])       -- TBD: deal with @primResNeedsEval
                                                        (as,qa) = relevTyArgs (const fresh) (\(RelevTy_Ana x) (RelevTy_Ana y) -> [RelevQual_SubEval x y]) @lUniq2 (take (length @argTyL) @primArgNeedsEvalL) r
                                                    in  (RelevTy_Fun RQuant_None [] [] as r, Set.fromList $ qr ++ qa)
                            .   (amso,ams)      =   amsLE @lhs.rvarMp @ffiTy @lhs.knTy
                loc         .   ffiTy           :   RelevTy
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq
  | App         loc         .   funTy           =   case @func.ty of
                                                      t@(RelevTy_Fun _ _ _ (_:_) _) -> t
                                                      _                             -> anaMkBotFun 1
                            .   (argTy,resTy,resFunTy)
                                                =   case @funTy of
                                                      RelevTy_Fun q v qs (a:as) r -> (a,r,RelevTy_Fun q v qs as r)
                loc         .   funTy           :   RelevTy
                loc         .   argTy           :   RelevTy

SEM CAltL
  | Cons        loc         .   (amsoDw,amsDw)  =   amsLE @lhs.rvarMp @altKnDwTy @lhs.knTy     -- both are guaranteed vars, so this enforces a Qual
                            .   rvarMpDw        =   amsLocalVarMp @amsDw |+> @lhs.rvarMp
                            .   rvarMpUp        =   @rvarMpDw


ATTR CAltL [ altId: UID  altNrMax: Int | | altNr: Int ]

SEM CAltL
  | Nil         loc         .   altNr           =   0
  | Cons        loc         .   altNr           =   @tl.altNr + 1
  | *           loc         .   altNr           :   Int

SEM CExpr
  | Case        alts        .   altNrMax        =   @alts.altNr
                            .   altId           =   @lUniq
                loc         .   lUniq           :   UNIQUEREF gUniq

SEM CAltL
  | Cons        loc         .   altKnUpTy       =   fresh @lUniq
                loc         .   altKnUpTy       :   RelevTy
                loc         .   altKnDwTy       =   fresh @lUniq2
                loc         .   altKnDwTy       :   RelevTy
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq

ATTR CExpr CAltL [ altMbScrutTy: MbRelevTy | | ]
ATTR AllBind [ | | altMbScrutTy USE {<|>} {Nothing} : MbRelevTy ]

SEM CBound
  | Bind        lhs         .   altMbScrutTy    =   do v <- @expr.mbVar
                                                       renvLookup v @lhs.env Map.empty -- @lhs.lamMp

SEM CAlt CBound CModule MbCExpr CPatFld
  | *           loc         .   altMbScrutTy    =   Nothing

ATTR CExpr CBound CAlt [ | | coe: RelevCoe ]

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   coe             =   @lhs.finalRVarMp `varUpd` amsoCoe @amso
  | App         lhs         .   coe             =   if @lhs.isTopApp
                                                    then @lhs.finalRVarMp `varUpd` @resCoe
                                                    else RelevCoe_Id
  | * - Var Int Char Tup FFI App Let
                lhs         .   coe             =   RelevCoe_Id

SEM CExpr
  | App         loc         .   hereArgCoe      =   @arg.coe <.> (@lhs.finalRVarMp `varUpd` @argCoe)
                            .   hereFunCoe      =   case @func.whatBelow of
                                                      ExprIsApp _ -> RelevCoe_Id
                                                      _           -> @func.coe
  | Lam         loc         .   hereBodyCoe     =   case @body.whatBelow of
                                                      ExprIsLam -> RelevCoe_Id
                                                      _         -> @body.coe

SEM CBound
  | Bind        loc         .   hereBindCoe     =   @expr.coe <.> maybe RelevCoe_Id (@finalRVarMp `varUpd`) @mbBindCoe
  | * - Val		lhs			.	coe				=	RelevCoe_Id

SEM CAltL
  | Cons        loc         .   hereAltCoe      =   @hd.coe <.> (@hdFinalRVarMp `varUpd` amsoCoe @amsoDw)

SEM CPatFld
  | Fld         loc         .   hereOffCoe      =   @lhs.finalRVarMp `varUpd` @offset.coe
                            .   hereFldCoe      =   @lhs.finalRVarMp `varUpd` @fldCoe

ATTR CExpr [ | | funCoe: RelevCoe ]

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   funCoe          =   last $ relevCoeToComposeList $ amsoCoe @amso
  | App         (loc.argCoe,loc.resCoe,lhs.funCoe)
                                                =   case @func.funCoe of
                                                      RelevCoe_Fun (a:as) r -> (a,r,RelevCoe_Fun as r)
                                                      _                     -> (RelevCoe_Err "CExpr.App.a", RelevCoe_Err "CExpr.App.r", RelevCoe_Err "CExpr.App.f")
  | * - Var Int Char Tup FFI App Ann CaseAltFail
                lhs         .   funCoe          =   RelevCoe_Err "CExpr.unimpl"

ATTR CExpr CAltL [ | | ty: RelevTy ]

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   ty              =   amsoHi @amso
  | App         lhs         .   ty              =   if @lhs.isTopApp then @resTy else @resFunTy
  | Case        lhs         .   ty              =   @alts.ty
  | * - Var Int Char Tup FFI App Case Ann CaseAltFail
                lhs         .   ty              =   RelevTy_Err "unimpl"

SEM CAltL
  | *           lhs         .   ty              =   @lhs.knTy


ATTR AllNT [ | rvarMp: RVarMp | ]

SEM CodeAGItf
  | AGItf       loc         .   rvarMp          =   emptyRVarMp

SEM CBound
  | Bind        lhs         .   rvarMp          =   @quantVarMp |+> @rvarMpExpr

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   rvarMp          =   amsLocalVarMp @ams |+> @lhs.rvarMp
  | Case        lhs         .   rvarMp          =   @alts.rvarMp        -- skip @dflt
  | Let         body        .   rvarMp          =   @binds.extraBindRVarMp |+> @binds.rvarMp

SEM CAltL
  | Cons        hd          .   rvarMp          =   @rvarMpUp

ATTR AllBind [ forQuantRVarMp: RVarMp | | ]

SEM CExpr
  | Let         binds       .   forQuantRVarMp  =   @binds.rvarMp
  | Lam App     loc         .   forQuantRVarMp  =   emptyRVarMp

SEM CPatFld
  | Fld			bind        .   forQuantRVarMp  =   emptyRVarMp

ATTR AllNT [ finalRVarMp: RVarMp | | ]

SEM CodeAGItf
  | AGItf       module      .   finalRVarMp     =   @module.rvarMp

SEM CBound
  | Bind        loc         .   finalRVarMp     =   {- @extraBindRVarMp |+> -} @lhs.finalRVarMp

SEM CAltL
  | Cons        loc         .   hdFinalRVarMp   =   @altSolveVarMp -- |+> @lhs.finalRVarMp
                hd          .   finalRVarMp     =   @hdFinalRVarMp


ATTR AllBind [ | | extraBindRVarMp USE {|+>} {emptyRVarMp}: RVarMp ]

SEM CBound
  | Bind        loc         .   extraBindRVarMp =   if @doBindStrict then @strictVarMp else emptyRVarMp
                                                    -- @strictVarMp

ATTR AllCodeNT [ | | qualS USE {`Set.union`} {Set.empty} : RelevQualS ]

SEM CExpr
  | Var         lhs         .   qualS           =   Set.union @envQualS (amsGathQual @ams)
  | FFI         lhs         .   qualS           =   Set.union @ffiQualS (amsGathQual @ams)
  | Tup         lhs         .   qualS           =   Set.union @tupQualS (amsGathQual @ams)
  | Int Char    lhs         .   qualS           =   amsGathQual @ams
  | Case        lhs         .   qualS           =   Set.unions [@expr.qualS, @altQualSIntersect] -- @alts.qualS]       -- skip @dflt

SEM CBound
  | Bind        lhs         .   qualS           =   Set.unions [amsGathQual @amsBind, @expr.qualS]

ATTR CAltL [ | | altQualSL: {[RelevQualS]} ]

SEM CAltL
  | Cons        lhs         .   altQualSL       =   Set.unions [@hd.qualS, amsGathQual @amsDw] : @tl.altQualSL
  | Nil         lhs         .   altQualSL       =   []

SEM CExpr
  | Case        loc         .   altQualSLSubs   =   map (Set.map (@alts.rvarMp `varUpd`)) @alts.altQualSL
                            .   altQualSLSolv1  =   let bnd = @lhs.boundRelevTyVarS
                                                        s q = (Set.map (m `varUpd`) q', m)
                                                            where (q',m) = assSolve bnd q
                                                    in  map s @altQualSLSubs
                            .   altQualSLSolv   =   map fst @altQualSLSolv1
                            .   altQualSIntersect
                                                =   foldr1 Set.intersection @altQualSLSolv
                loc         .   altQualSIntersect
                                                :   RelevQualS
                loc         .   altQualSLSubs   :   {[RelevQualS]}
                loc         .   altQualSLSolv   :   {[RelevQualS]}
                loc			.	altQualSLSolv1	:	{[(RelevQualS,RVarMp)]}

SEM CExpr
  | Case        loc         .   altQualSLSolv2  =   let s (q,m) = (Set.map (m3 `varUpd`) q', m4)
                                                                where m2 = m |+> @lhs.finalRVarMp
                                                                      (q',m3) = assSolve Set.empty (Set.map (m2 `varUpd`) q)
                                                                      m4 = m3 |+> m2
                                                    in  map s @altQualSLSolv1
                            .   altSolveLVarMp  =   map snd @altQualSLSolv2
                loc         .   altSolveLVarMp  :   {[RVarMp]}

ATTR CAltL [ altSolveLVarMp: {[RVarMp]} | | ]

SEM CAltL
  | Cons        (loc.altSolveVarMp,tl.altSolveLVarMp)
                                                =   hdAndTl' (panic "altSolveLVarMp") @lhs.altSolveLVarMp

SEM CExpr
  | Let         loc         .   bindsCanParticpateInOuterSolving
                                                =   @categ == CBindCateg_Strict
                            .   bindsQualSSubs  =   Set.map (@binds.rvarMp `varUpd`) @binds.qualS
                            .   bindsQualSOuter =   if @bindsCanParticpateInOuterSolving then @bindsQualSSubs else Set.empty
                            .   bindsQualSSolv1 =   if @bindsCanParticpateInOuterSolving
                                                    then (Set.empty, emptyRVarMp)
                                                    else let (q,m) = assSolve @lhs.boundRelevTyVarS @bindsQualSSubs
                                                         in  (Set.map (m `varUpd`) q, m)

                loc         .   bindsCanParticpateInOuterSolving
                                                :   Bool

SEM CExpr
  | Let         loc         .   bindsQualSSolv2 =   let (q,m) = @bindsQualSSolv1
                                                        m2 = m |+> @lhs.finalRVarMp
                                                        (q',m3) = assSolve Set.empty (Set.map (m2 `varUpd`) q)
                                                    in  (Set.map (m3 `varUpd`) q', m3 |+> m2)
                            .   bindsSolveVarMp =   snd @bindsQualSSolv2

ATTR AllExpr [ boundRelevTyVarS: UIDS | | ]

SEM CBound
  | Bind        expr        .   boundRelevTyVarS=   @exprBoundS

SEM CModule
  | Mod         expr        .   boundRelevTyVarS=   Set.empty

SEM CBound
  | Bind        loc         .   (ty,exprKnTy,exprEnv,exprBoundS,bindConstrain)
                                                =   let noConstrain _ _ _ = (emptyAnaMatchState, Nothing)
                                                        strictConstrain m t knTy = (ams, Just $ amsoCoe amso)
                                                          where (amso,ams) = amsLE m t knTy
                                                    in  case @expr.mbLam of
                                                          Just nmL
                                                            -> (ty, r', exprEnv, varFreeSet ty, noConstrain)
                                                            where us@(r:as) = mkNewLevUIDL (1 + length nmL) @lUniq
                                                                  r' = fresh r
                                                                  as' = map fresh as
                                                                  exprEnv = gamFromAssocL (zip nmL as')
                                                                  ty = RelevTy_Fun RQuant_None [] [] as' r'
                                                          _ | isStrict  -> (bTy, bTy, emptyGam, Set.empty, strictConstrain)
                                                            | otherwise -> (bTy, bTy, emptyGam, Set.empty, noConstrain)
                                                                               -- (bTy, eTy, emptyGam, Just $ RelevCoe_Cast $ RelevCoe_Eval eAna bAna)
                                                            where isStrict = @lhs.letBindingsCateg == CBindCateg_Strict
                                                                  (_,u1,u2) = mkNewLevUID2 @lUniq
                                                                  eTy@(RelevTy_Ana eAna) = fresh u1
                                                                  bTy@(RelevTy_Ana bAna) = fresh u2
                            .   (amsBind,mbBindCoe)
                                                =   @bindConstrain @expr.rvarMp @exprKnTy @lhs.knTy
                            .   rvarMpExpr      =   amsLocalVarMp @amsBind |+> @expr.rvarMp
                            .   (quantTy,quantVarMp,quantRemQualS)
                                                =   case @ty of
                                                      t@(RelevTy_Fun _ _ _ _ _)
                                                        -> relevtyQuant ([RelevTyQuantHow_Solve] ++ how)
                                                                        @rvarMpExpr @expr.qualS t
                                                        where how | WhatToRelevInfer_Quant `elem` @lhs.whatTo = [RelevTyQuantHow_RemoveAmbig,RelevTyQuantHow_Quant]
                                                                  | otherwise                                 = []
                                                      t -> (m `varUpd` t, m, q)
                                                        where (q,m) = assSolve @lhs.boundRelevTyVarS (Set.map (@rvarMpExpr `varUpd`) @expr.qualS)
                            .   bindTy          =   @lhs.forQuantRVarMp `varUpd` @quantTy
                            .   (strictTy,strictVarMp)
                                                =   case @bindTy of
                                                      t@(RelevTy_Fun _ _ qs a r@(RelevTy_Ana (AnaEval_Var rv)))
                                                        -> (sty, smp2 |+> smpAssume2 |+> smp1 |+> smpAssume1)
                                                        where smpAssume1 = rvarmpEvalUnit rv bot
                                                              (RelevTy_Fun _ vs' qs' a' r',smp1,rem1)
                                                                = relevtyQuant [RelevTyQuantHow_Solve,RelevTyQuantHow_RemoveAmbig,RelevTyQuantHow_Quant]
                                                                               smpAssume1 (Set.fromList qs `Set.union` @quantRemQualS) (RelevTy_Fun RQuant_None [] [] a (smpAssume1 `varUpd` r))
                                                              smpAssume2 = rvarmpUnions [ rvarmpEvalUnit v top | v <- vs' ]
                                                              (sty,smp2,_)
                                                                = relevtyQuant [RelevTyQuantHow_Solve,RelevTyQuantHow_RemoveAmbig,RelevTyQuantHow_Quant]
                                                                               smpAssume2 (Set.fromList qs' `Set.union` rem1) (RelevTy_Fun RQuant_None [] [] (smpAssume2 `varUpd` a') r')
                                                      t -> (m `varUpd` t, m)
                                                        where (q,m) = assSolve Set.empty (Set.map (@lhs.forQuantRVarMp `varUpd`) @quantRemQualS)
                            .   debugTy1        =   case @rvarMpExpr `varUpd` @ty of
                                                      RelevTy_Fun _ _ _ a r
                                                        -> RelevTy_Fun RQuant_None v q a r
                                                        where q = @rvarMpExpr `varUpd` Set.toList @expr.qualS
                                                              v = Set.toList $ Set.unions [varFreeSet q, varFreeSet a, varFreeSet r]
                                                      t -> t
                            .   debugTy2        =   case @lhs.finalRVarMp `varUpd` @ty of
                                                      RelevTy_Fun _ _ _ a r
                                                        -> RelevTy_Fun RQuant_None [] q a r
                                                        where q = @lhs.finalRVarMp `varUpd` Set.toList @expr.qualS
                                                      t -> t
                            .	strictTy2		=	@lhs.finalRVarMp `varUpd` @strictTy
                            .   tyAspectL       =   [ CBound_RelevTy acbaspkeyDefault @bindTy
                                                    -- , CBound_RelevTy acbaspkeyStrict  @strictTy
                                                    -- , CBound_RelevTy acbaspkeyDebug @debugTy2
                                                    ]
                                                    ++ (if @doBindStrict
                                                        then [CBound_RelevTy acbaspkeyStrict @strictTy2]
                                                        else []
                                                       )
                loc         .   ty              :   RelevTy
                loc         .   strictTy        :   RelevTy
                loc         .   strictTy2       :   RelevTy
                loc         .   exprKnTy        :   RelevTy
                loc         .   quantVarMp   	:   RVarMp
                loc         .   strictVarMp   	:   RVarMp
                loc         .   quantRemQualS   :   RelevQualS
                loc         .   exprEnv         :   REnv
                loc         .   mbBindCoe       :   {Maybe RelevCoe}
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   amsBind         :   AnaMatchState
                loc         .   bindConstrain   :   {RVarMp -> RelevTy -> RelevTy -> (AnaMatchState,Maybe RelevCoe)}
                loc         .   exprBoundS      :   UIDS

ATTR AllBound [ | | tyAspectL  USE {++} {[]}: {[CBound]} ]
ATTR AllBound [ | | valAspectL USE {++} {[]}: {[CBound]} ]

{
dbg opts t1 t2 amso ams = CExpr_Ann (CExprAnn_Debug $ showPP $ "?:" >#< t1 >#< "<=" >#< t2 >-< "ams:" >#< ams >-< "amso:" >#< amso)
dbgApp opts a f f2 = CExpr_Ann (CExprAnn_Debug $ showPP $ "argTy:" >#< a >#< "funTy:" >#< f >#< "func.ty:" >#< f2)
dbgBind opts m env = CExpr_Ann (CExprAnn_Debug $ showPP $ "env:" >#< (m `varUpd` env))
dbgCase opts bnd as asslv asinter = CExpr_Ann (CExprAnn_Debug $ showPP $ "bnd:" >#< pp1 bnd >-< "altQualSL:" >#< ppl as >-< "altQualSLSlv:" >#< ppl asslv >-< "altQualSLInt:" >#< pp1 asinter)
  where pp1 s = ppParensCommas $ Set.toList s
        ppl l = ppCurlysCommasBlock (map pp1 l)

}
{
annCoe :: RelevCoe -> CExpr -> CExpr
annCoe RelevCoe_Id e =                            e
annCoe c           e = CExpr_Ann (CExprAnn_Coe c) e

}
SEM CExpr
  | Var         loc         .   dbg             =   dbg     @lhs.opts @envTy @lhs.knTy @amso @ams
  | Int Char    loc         .   dbg             =   dbg     @lhs.opts @litTy @lhs.knTy @amso @ams
  | Tup         loc         .   dbg             =   dbg     @lhs.opts @tupTy @lhs.knTy @amso @ams
  | FFI         loc         .   dbg             =   dbg     @lhs.opts @ffiTy @lhs.knTy @amso @ams
  | Case        loc         .   dbg             =   dbgCase @lhs.opts @lhs.boundRelevTyVarS @altQualSLSubs @altQualSLSolv @altQualSIntersect

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBound
  | Bind        lhs         .   cTrf            =   CBound_Bind @bindMeta.cTrf $
                                                    dbgBind @lhs.opts @lhs.finalRVarMp @gathEnv $
                                                    annCoe @hereBindCoe @expr.cTrf

SEM CBind
  | Bind        loc         .   cTrf            =   CBind_Bind @nm (@bindAspects.tyAspectL ++ @bindAspects.valAspectL ++ @bindAspects.cTrf)

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   cTrf            =   -- @dbg $
                                                    @cTrf
  | Lam         lhs         .   cTrf            =   acoreLam1 @argNm $ annCoe @hereBodyCoe @body.cTrf
  | App         lhs         .   cTrf            =   let a = -- dbgApp @lhs.opts @argTy @funTy @func.ty $
                                                            maybe @arg.cTrf (\(a,e) -> acoreBound1AspkeyVal a (annCoe @hereArgCoe e)) $ acoreBoundMbVal @arg.cTrf
                                                        app = acoreApp1Bound (annCoe @hereFunCoe @func.cTrf) a
                                                    in  app
  | Case        lhs         .   cTrf            =   -- @dbg $
                                                    @cTrf

SEM CAltL
  | Cons        lhs         .   cTrf            =   case @hd.cTrf of
                                                      CAlt_Alt p e -> CAlt_Alt p (annCoe @hereAltCoe e) : @tl.cTrf

SEM CPatFld
  | Fld         lhs         .   cTrf            =   CPatFld_Fld @lbl (annCoe @hereOffCoe @offset.cTrf) @bind.cTrf [CBindAnn_Coe @hereFldCoe]

ATTR AllExpr [ | | oTrf: SELF ]

SEM CBound
  | Bind        loc         .   valAspectL      =   [ -- CBound_Val acbaspkeyStrict @expr.oTrf
                                                    ]
