MODULE {EH101.Core.Trf.LetUnrec} {cmodTrfLetUnrec}
{
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Core
import EH101.Ty
import EH101.AbstractCore
import EH101.Base.Debug
import EH.Util.Utils (scc)
import Data.Maybe
import qualified Data.Map as Map
import qualified Data.Set as Set

}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/Trf/CommonFv.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
cmodTrfLetUnrec :: CModule -> CModule
cmodTrfLetUnrec cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

{
type UseMp = Map.Map HsName [HsName]

useMpComb :: UseMp -> UseMp -> UseMp
useMpComb = Map.unionWith (++)

}
ATTR AllCodeNT [ inNmL: {[HsName]} | | useMp USE {`useMpComb`} {Map.empty}: UseMp ]

SEM CodeAGItf
  | AGItf       module      .   inNmL       =   []

SEM CExpr
  | Var         lhs         .   useMp       =   Map.fromList (zip @lhs.inNmL (repeat [@nm]))
  | Let         lhs         .   useMp       =   @remUseMp `useMpComb` @body.useMp
{-
  | Lam			lhs			.	useMp		=	Map.delete @arg @body.useMp

SEM CAlt
  | Alt			lhs			.	useMp		=	foldr Map.delete @expr.useMp @pat.nmL
-}

SEM CBound
  | Bind        expr        .   inNmL       =   @lhs.nm : @lhs.inNmL
                lhs         .   useMp       =   (@lhs.nm `Map.singleton` []) `useMpComb` @expr.useMp

{
type BindMp = Map.Map HsName (CExpr,CMetas)

}
ATTR AllBind [ | | bindMp USE {`Map.union`} {Map.empty}: BindMp ]

SEM CBound
  | Bind        lhs         .   bindMp      =   @lhs.nm `Map.singleton` (@expr.cTrf,@bindMeta.cTrf)

SEM CExpr
  | Let         loc         .   (remUseMp,cTrf)
                                            =   if @categ == CBindCateg_Rec
                                                then  let  h = Map.filterWithKey (\k e -> k `Map.member` @binds.bindMp) @binds.useMp
                                                           o = scc . Map.toList $ h
                                                           mk c ns b = acoreLet c [ acoreBind1MetasTy n m Ty_Any e | n <- ns, (e,m) <- maybeToList (Map.lookup n @binds.bindMp) ] b
                                                           t = foldr (\bs b
                                                                         -> case bs of
                                                                               [n] | n `elem` Map.findWithDefault [] n h
                                                                                                -> mk CBindCateg_Rec bs b
                                                                                   | otherwise  -> mk CBindCateg_Plain bs b
                                                                               _                -> mk CBindCateg_Rec bs b
                                                                     )
                                                                     @body.cTrf o
                                                      in   (@binds.useMp `Map.difference` h,t)
                                                else  (@binds.useMp,CExpr_Let @categ @binds.cTrf @body.cTrf)

