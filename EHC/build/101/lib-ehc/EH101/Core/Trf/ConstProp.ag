MODULE {EH101.Core.Trf.ConstProp} {cmodTrfConstProp}
{
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Opts
import EH101.Core
import EH101.Ty
import EH101.AbstractCore
import Data.Maybe

}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/CommonBindNm.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
cmodTrfConstProp :: EHCOpts -> CModule -> CModule
cmodTrfConstProp opts cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { opts_Inh_CodeAGItf = opts
                               })
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]

ATTR CExpr [ | | appLam: CExpr  appArgL: {[CBound]} ]

SEM CExpr
  | App         loc         .   appLam      =   @func.appLam
                            .   appArgL     =   @arg.cTrf : @func.appArgL
  | * - App Ann lhs         .   appLam      =   @cTrf
                            .   appArgL     =   []

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | App         lhs         .   cTrf        =   if @lhs.isTopApp
                                                then  case (acoreExprMbVar @appLam,reverse @appArgL) of
                                                        (Just n,[e1,e2]) | n == (ehcOptBuiltin @lhs.opts ehbnPrimAddInt) && isJust i1 && isJust i2
                                                          -> acoreInt (fromInteger $ snd (fromJust i1) + snd (fromJust i2))
                                                          where i1 = acoreExprMbInt $ acoreUnBoundVal e1
                                                                i2 = acoreExprMbInt $ acoreUnBoundVal e2
                                                        _ -> @cTrf
                                                else  @cTrf

