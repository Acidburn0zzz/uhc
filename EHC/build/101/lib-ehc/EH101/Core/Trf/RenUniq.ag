MODULE {EH101.Core.Trf.RenUniq} {RenUniqOpts (..), emptyRenUniqOpts
, cmodTrfRenUniq}
{
import Data.Maybe
import Data.Char
import Control.Monad (liftM)
import qualified Data.Map as Map
import EH.Util.Utils
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.Core
import EH101.Ty
import EH101.AbstractCore
import EH101.Base.Debug
import EH.Util.Pretty

}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLevLet.ag"
INCLUDE "Core/CommonBindNm.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
}
{
data RenUniqOpts
  = RenUniqOpts
      { renuniqOptResetOnlyInLam    :: Bool             -- restart numbering in lambda only, throwing away all name modifiers previously added
      }

emptyRenUniqOpts :: RenUniqOpts
emptyRenUniqOpts = RenUniqOpts False

}
{
cmodTrfRenUniq :: RenUniqOpts -> CModule -> CModule
cmodTrfRenUniq ropts cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf { gIniq_Inh_CodeAGItf = 1
                                             -- , gUniq_Inh_CodeAGItf = uidStart
                                             , ropts_Inh_CodeAGItf = ropts
                                             })
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllCodeNT CodeAGItf [ ropts: RenUniqOpts | | ]

{
newIniq :: Int -> Int -> (Int,[Int])
newIniq nr seed = (seed+nr, [seed .. seed + nr -1])

}
ATTR AllCodeNT [ | gIniq: Int | ]
ATTR CodeAGItf [ gIniq: Int | | ]

SEM CExpr
  | Let         (binds.gIniq,loc.lIniq)     =   newIniq (length @binds.nmL) @lhs.gIniq
  | Lam         (body.gIniq,loc.lIniq)      =   newIniq 1 @lhs.gIniq

SEM CBound
  | Bind Val    expr        .   gIniq       =   if   renuniqOptResetOnlyInLam @lhs.ropts
                                                then 1
                                                else @lhs.gIniq
                lhs         .   gIniq       =   if   renuniqOptResetOnlyInLam @lhs.ropts
                                                then @lhs.gIniq
                                                else @expr.gIniq

SEM CAlt
  | Alt         (pat.gIniq,loc.lIniq)       =   newIniq (length @pat.nmL) @lhs.gIniq

ATTR AllExpr [ moduleNm: HsName | | ]

SEM CModule
  | Mod         expr        .   moduleNm    =   @moduleNm

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

{
type NmMp = Map.Map HsName HsName
type ARenMp
  = ( NmMp          -- forward map, from old -> new
    , NmMp          -- backward map, from new -> old
    )

emptyARenMp :: ARenMp
emptyARenMp = (Map.empty, Map.empty)

}
{
-- breaks assumption that globals are qualified, locals not. Problem in future when records are used for globals and access differs.
mkUniqGlob :: NmMp -> HsName -> HsName -> Maybe Int -> (HsName,NmMp)
mkUniqGlob mb q n mbU
  = (
      (if hsnIsQual n
       then id
       else hsnSetQual q
      ) $
      maybe n (\u -> hsnUniqifyInt HsNameUniqifier_GloballyUnique u n) mbU
    , mb
    )

}
{
-- breaks assumption that globals are qualified, locals not. Problem in future when records are used for globals and access differs.
mkUniqLoc :: NmMp -> HsName -> HsName -> Maybe Int -> (HsName,NmMp)
mkUniqLoc mb q n mbU
  = ( -- tr "mkUniqLoc" (n >#< n2 >#< n3 >#< n5) $
      n5
    , Map.insert n5 n mb
    )
  where n2 = hsnStripUniqifiers $ hsnQualified n
        n3 = case hsnBaseUnpack n2 of
               Just ('_':_, _) -> mkHNm "_"
               _               -> n2
        n5 | Map.member n3 mb = hsnUniqifyInt HsNameUniqifier_Blank (panicJust "RenUniq.mkUniqLoc" mbU) $ hsnStripUniqifiers n3
           | otherwise        = n3
           -- where mbExists@(~(Just n4)) = Map.lookup n3 mb

}
{
aRenAdd :: RenUniqOpts -> Bool -> HsName -> [HsName] -> [Int] -> ARenMp -> ARenMp
aRenAdd ropts isGlob q nL uL mfb@(mf,mb)
  = foldr (\(n,u) (mf,mb) -> let (n',mb') = mkNm mb n u in (Map.insert n n' mf,mb')) mfb $ zip nL uL
  where mkNm mb n u
          | doChng && isUnqualifiedGlob
                       = mkUniq mb q n Nothing
          | doChng     = mkUniq mb q n (Just u)
          | otherwise  = (n,mb)
          where doChng
                   = isChangeable
                     || isUnqualifiedGlob
                isUnqualifiedGlob = isGlob && not onlyLam && isNothing (hsnQualifier n) && n /= hsnMain
                isChangeable = not isGlob || n `Map.member` mf
                onlyLam = renuniqOptResetOnlyInLam ropts
                mkUniq | onlyLam   = mkUniqLoc
                       | otherwise = mkUniqGlob

}
{
aRenRepl :: ARenMp -> HsName -> HsName
aRenRepl (mf,_) n = maybe n id . Map.lookup n $ mf

}
ATTR CExpr [ | accumARenMp: ARenMp | ]

SEM CExpr
  | Let         loc         .   isGlobal    =   @lhs.lev == cLevModule
                            .   addToARenMp =   \m -> aRenAdd @lhs.ropts @isGlobal
                                                              @lhs.moduleNm
                                                              @binds.nmL @lIniq m
                body        .   accumARenMp =   if   @isGlobal
                                                then @addToARenMp @lhs.accumARenMp
                                                else              @lhs.accumARenMp
                loc         .   aRenMp      =   if   @isGlobal
                                                then              @lhs.aRenMp
                                                else @addToARenMp @lhs.aRenMp
                lhs         .   accumARenMp =   @body.accumARenMp
  | Lam         body        .   accumARenMp =   aRenAdd @lhs.ropts False
                                                        @lhs.moduleNm
                                                        [@argNm] @lIniq @lhs.aRenMp
                loc         .   aRenMp      =   @body.accumARenMp
  | * - Lam Let Char Int String Tup FFI Var Ann
        CoeArg Hole
        Integer
                first__     .   accumARenMp =   @lhs.aRenMp
                loc         .   aRenMp      =   @last__.accumARenMp
  | * - Let Ann lhs         .   accumARenMp =   @lhs.accumARenMp
                loc         .   accumARenMp =   @lhs.aRenMp

SEM CAlt
  | Alt         expr        .   accumARenMp =   aRenAdd @lhs.ropts False
                                                        @lhs.moduleNm
                                                        @pat.nmL @lIniq @lhs.aRenMp
                loc         .   aRenMp      =   @expr.accumARenMp

SEM CBound
  | Bind Val
    FFE
                expr        .   accumARenMp =   @lhs.aRenMp
                loc         .   aRenMp      =   @expr.accumARenMp

SEM CModule
  | Mod         expr        .   accumARenMp =   @lhs.aRenMp
                loc         .   aRenMp      =   @expr.accumARenMp

SEM MbCExpr
  | Just        just        .   accumARenMp =   @lhs.aRenMp
                loc         .   aRenMp      =   @just.accumARenMp

SEM CPatFld
  | Fld         offset      .   accumARenMp =   @lhs.aRenMp
                loc         .   aRenMp      =   @offset.accumARenMp

ATTR AllCodeNT [ aRenMp: ARenMp  lev: Int | | ]
ATTR AllBind AllPat [ | | nmL USE {++} {[]}: {[HsName]} ]

ATTR AllExprOnly
     AllAlt
     AllBind    [ protectedBindingNames : {[HsName]} | | ]
ATTR AllMetaVal [ | | protectableBindingNames : {[HsName]} ]

SEM CodeAGItf
  | AGItf       module      .   aRenMp      =   emptyARenMp
                            .   lev         =   cLevModule
SEM CBind
  | Bind        lhs         .   nmL         =   if   @nm `elem` @lhs.protectedBindingNames
                                                then []
                                                else [@nm]

SEM CPatFld
  | Fld         lhs         .   nmL         =   {- [@nm] ++ -} [@fldNm] -- @pat.nmL

SEM CPat
  | Var         lhs         .   nmL         =   [@pnm]
  | Con         lhs         .   nmL         =   @rest.nmL ++ @binds.nmL

SEM CPatRest
  | Var         lhs         .   nmL         =   [@nm]

SEM CExpr
  | Lam         body        .   lev         =   if @body.isLamBody then @lhs.lev + 1 else @lhs.lev

SEM CAlt
  | Alt         expr        .   lev         =   @lhs.lev + 1

ATTR CExpr [ | | isLamBody: Bool ]

SEM CExpr
  | Lam         lhs         .   isLamBody   =   False
  | * - Lam Ann lhs         .   isLamBody   =   True

SEM CExpr
  | Var         lhs         .   cTrf        =   acoreVar (aRenRepl @lhs.aRenMp @nm)
  | Lam         lhs         .   cTrf        =   acoreLam1 (aRenRepl @aRenMp @argNm) @body.cTrf

SEM CBind
  | Bind        lhs         .   cTrf        =   CBind_Bind (aRenRepl @lhs.aRenMp @nm) @bindAspects.cTrf

SEM CPatFld
  | Fld         lhs         .   cTrf        =   CPatFld_Fld @lbl @offset.cTrf (acoreBind1Nm1 $ aRenRepl @aRenMp @fldNm) @fldAnns.cTrf -- @pat.cTrf

SEM CPat
  | Var         lhs         .   cTrf        =   CPat_Var (aRenRepl @lhs.aRenMp $ @pnm)

SEM CPatRest
  | Var         lhs         .   cTrf        =   CPatRest_Var (aRenRepl @lhs.aRenMp @nm)


SEM CBound
  | Bind         expr.protectedBindingNames  =   @bindMeta.protectableBindingNames ++ @lhs.protectedBindingNames

SEM CMetaVal
  | DictClass
    DictInstance lhs.protectableBindingNames   =   [ nm  | TrackVarApply nm _ <- @tracks ]
  | Dict         lhs.protectableBindingNames  =   []
  | Val Track    lhs.protectableBindingNames   =   []

SEM CModule
  | Mod          expr.protectedBindingNames  =   []

SEM CPatFld
  | Fld          offset.protectedBindingNames  =   []
                 bind  .protectedBindingNames  =   []
