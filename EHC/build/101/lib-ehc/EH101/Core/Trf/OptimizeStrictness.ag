MODULE {EH101.Core.Trf.OptimizeStrictness} {cmodTrfOptimizeStrictness}
{
import Data.Maybe
import EH101.Base.Common
import EH101.Opts
import EH101.Core
import EH101.Ty
import EH101.AbstractCore
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.List
import Data.Maybe
import EH.Util.Utils
import EH101.LamInfo
import EH101.Base.Debug
import EH101.Base.Builtin

}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLamInfo.ag"
INCLUDE "Core/CommonGathLamInfo.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/CommonPred.ag"
WRAPPER CodeAGItf

PRAGMA nocycle novisit

{
cmodTrfOptimizeStrictness
  :: EHCOpts
     -> LamMp
     -> CModule
     -> ( CModule
        , LamMp
        )
cmodTrfOptimizeStrictness
     opts
     lamMp
     cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { opts_Inh_CodeAGItf = opts
                               , lamMp_Inh_CodeAGItf = lamMp
                               })
     in   ( cTrf_Syn_CodeAGItf t
          , gathLamMp_Syn_CodeAGItf t
          )

}
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CodeAGItf
  | AGItf       loc         .   howUnionGathLamInfo
                                                =   Map.union @gathLamMp

SEM CodeAGItf
  | AGItf       loc         .   howMergeLamInfo =   (\(LamInfo {laminfoBindAspMp=m}) i -> i {laminfoBindAspMp = m `Map.union` laminfoBindAspMp i})

SEM CBind
  | Bind        lhs         .   bindLamMp       =   case @mbStrictArgsRes of
                                                      Just (t,_,_) -> Map.singleton @nm (emptyLamInfo {laminfoBindAspMp = Map.fromList l})
                                                                   where l = [(acbaspkeyStrict, LamInfoBindAsp_RelevTy t)]
                                                      _            -> Map.empty

ATTR CExpr CBound MbCExpr AllAlt [ anaEvalCtxt: AnaEval | | ]

SEM CBoundL
  | Cons        loc         .   anaEvalCtxt     =   top

SEM CBound
  | * - Bind    loc         .   anaEvalCtxt     =   top

SEM CModule
  | *           loc         .   anaEvalCtxt     =   top

SEM CPatFld
  | *           loc         .   anaEvalCtxt     =   bot

SEM *
  | *			loc			.	anaEvalCtxt		: 	AnaEval

ATTR AllBound [ | | gathStrictTyL USE {++} {[]}: {[RelevTy]} ]

SEM CBound
  | RelevTy     loc         .   gathStrictTyL   =   if @aspectKeyS == acbaspkeyStrict
                                                    then [@relevTy]
                                                    else []

ATTR AllBound [ mbStrictArgsRes: {Maybe (RelevTy,[AnaEval],AnaEval)} | | ]

SEM CBind
  | Bind        loc         .   mbStrictArgsRes =   case @bindAspects.gathStrictTyL of
                                                      [t@(RelevTy_Fun _ _ _ a r)]
                                                        -> Just (t, map relevtyAnaEval a, relevtyAnaEval r)
                                                      _ -> Nothing

SEM CExpr
  | App			arg			.	mbStrictArgsRes	=	Nothing

SEM CBound
  | Bind        loc         .   doWorkerWrapper =   isJust @lhs.mbStrictArgsRes

ATTR CExpr [ lamArgAnaEvalL: {[AnaEval]} | | ]

SEM CBound
  | Bind        (expr.lamArgAnaEvalL,expr.anaEvalCtxt)
                                                =   maybe ([],top) tup123to23 @lhs.mbStrictArgsRes
  | * - Bind    loc         .   lamArgAnaEvalL  =   []

SEM CModule CPatFld MbCExpr CAlt
  | *           loc         .   lamArgAnaEvalL  =   []

SEM CExpr
  | Lam         (loc.argAnaEval,body.lamArgAnaEvalL)
                                                =   hdAndTl' top @lhs.lamArgAnaEvalL
  | * - Lam Ann loc         .   lamArgAnaEvalL  =   []

ATTR AllBound [ | | cTrfBoundL USE {++} {[]} : {[CBound]} ]

SEM CBound
  | Bind        loc         .   wrapper         =   case (@expr.mbLam,@lhs.mbStrictArgsRes) of
                                                      (Just as, Just (_,evs,_))
                                                        -> [ CBound_Val acbaspkeyNone
                                                           $ acoreLam wrapperArgs
                                                           $ (\b -> foldr ($) b bodyWrappers)
                                                           $ acoreApp (CExpr_Var (ACoreBindRef @lhs.nm (Just acbaspkeyStrict)))
                                                           $ map acoreVar workerArgs
                                                           ]
                                                        where (wrapperArgs,workerArgs,bodyWrappers) = unzip3 $ zipWith mk as evs
                                                              mk a AnaEval_WHNF = (a, a', acoreLet1Strict a' (acoreVar a))
                                                                 where a' = hsnUniqify HsNameUniqifier_Evaluated a
                                                              mk a _            = (a, a , id                             )
                                                      _ -> []
                            .   worker          =   if @doWorkerWrapper then [CBound_Val acbaspkeyStrict @expr.cTrf] else []
                            .   oldbinding      =   if @doWorkerWrapper then [] else [@cTrf]
                lhs         .   cTrfBoundL      =   @worker ++ @wrapper ++ @oldbinding
  | FFE         lhs         .   cTrfBoundL      =   [@cTrf]
  | * - Bind
        FFE
                lhs         .   cTrfBoundL      =   []

SEM CBind
  | Bind        lhs         .   cTrf            =   CBind_Bind @nm @bindAspects.cTrfBoundL

SEM CExpr
  | Var         loc         .   strictRef       =   acbrefAspAnd acbaspkeyStrict @ref
                            .   mbStrict        =   case fmap libindaspRelevTy $ lamMpLookupAsp2 @strictRef @lhs.lamMp of
                                                      Just (t@(RelevTy_Fun _ _ _ a r))
                                                        -> Just (t, map relevtyAnaEval a, relevtyAnaEval r)
                                                      _ -> Nothing

SEM CExpr
  | Var         lhs         .   cTrf            =   CExpr_Var $ maybe @ref (const @strictRef) @mbStrict

ATTR CExpr [ | | appArgAnaEvalL: {[AnaEval]} ]
ATTR CExpr [ | | appResAnaEval :   AnaEval   ]

SEM CExpr
  | Var         (lhs.appArgAnaEvalL,lhs.appResAnaEval)
                                                =   maybe ([],top) tup123to23 @mbStrict
  | App         (arg.anaEvalCtxt,lhs.appArgAnaEvalL)
                                                =   hdAndTl' top @func.appArgAnaEvalL
  | * - Var App Ann
                lhs         .   appArgAnaEvalL  =   []
                            .   appResAnaEval   =   top

