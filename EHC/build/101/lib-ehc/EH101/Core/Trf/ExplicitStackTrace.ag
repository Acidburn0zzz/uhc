MODULE {EH101.Core.Trf.ExplicitStackTrace} {cmodTrfExplicitStackTrace}
{
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Opts
import EH101.Core
import EH101.Ty
import EH101.LamInfo
import EH101.AbstractCore
import Data.Maybe
import qualified Data.Map as Map

}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonLevLet.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/CommonLamInfo.ag"
INCLUDE "Core/CommonGathLamInfo.ag"
WRAPPER CodeAGItf

PRAGMA nocycle

{
cmodTrfExplicitStackTrace :: EHCOpts -> LamMp -> CModule -> (CModule,LamMp)
cmodTrfExplicitStackTrace opts lamMp cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { opts_Inh_CodeAGItf = opts
                               , lamMp_Inh_CodeAGItf = lamMp
                               })
     in   ( cTrf_Syn_CodeAGItf t
          , debugLamMp_Syn_CodeAGItf t `Map.union`
            gathLamMp_Syn_CodeAGItf  t
            -- [ | (n,) <- debugLamMp_Syn_CodeAGItf t ]
          )

}
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]

SEM CodeAGItf
  | AGItf       loc         .	howUnionGathLamInfo
  												=	Map.union @gathLamMp

SEM CodeAGItf
  | AGItf       loc         .   howMergeLamInfo =   (\(LamInfo {laminfoStackTrace=t}) i -> i {laminfoStackTrace=t})

ATTR CExpr [ | | isTraceCandidate: Bool ]
ATTR CExpr [ | | traceCandidateLamArgs: {[HsName]}
                 traceCandidateLamBody: CExpr
           ]

SEM CExpr
  | Lam         lhs         .   isTraceCandidate
                                            =   True
                            .   traceCandidateLamArgs
                                            =   @argNm : @body.traceCandidateLamArgs
                            .   traceCandidateLamBody
                                            =   @body.traceCandidateLamBody
  | * - Lam     lhs         .   isTraceCandidate
                                            =   False
                            .   traceCandidateLamArgs
                                            =   []
                            .   traceCandidateLamBody
                                            =   @cTrf

SEM CBound
  | Bind        loc         .   isTraceCandidate
                                            =   @lhs.isGlobal || @expr.isTraceCandidate

ATTR AllExpr AllBind [ mbInStackTraceCtxt: {Maybe HsName} | | ]

SEM CModule
  | Mod         loc         .   mbInStackTraceCtxt
                                            =   Nothing

{
mbStackTrace :: EHCOpts -> Bool -> HsName -> StackTraceInfo
mbStackTrace opts isCand nm
  | isCand && ehcOptTargetFlavor opts == TargetFlavor_Debug
              = StackTraceInfo_HasStackTraceEquiv (hsnSuffix nm "-$explstacktraced")
  | otherwise = StackTraceInfo_None

}
SEM CBound
  | Bind        (loc.mbStackTrace,lhs.bindLamMp)
                                            =   let mbt = mbStackTrace @lhs.opts @isTraceCandidate @lhs.nm
                                                in  (mbt,Map.singleton @lhs.nm (emptyLamInfo {laminfoStackTrace = mbt}))

ATTR AllCodeNT [ | uniq: Int | ]

SEM CodeAGItf
  | AGItf       loc         .   uniq        =   0

SEM CBound
  | Bind        loc         .   uniq        =   @lhs.uniq + 1
                            .   nmStackTrace=   mkHNm $ "_$" ++ show @lhs.uniq ++ "_stacktrace"

ATTR AllBind [ | | bindCTrfL USE {++} {[]}: {[CBind]} ]

SEM CBound
  | Bind        (loc.bindCTrfL,loc.mbInStackTraceCtxt,loc.newLamMp)
                                            =   case @mbStackTrace of
                                                  StackTraceInfo_HasStackTraceEquiv dbNm | @isTraceCandidate
                                                    -> ( [ acoreBind1Cat CBindCateg_Plain dbNm (acoreLam1 @nmStackTrace @expr.cTrf)
                                                         , acoreBind1MetasTy @lhs.nm @bindMeta.cTrf Ty_Any
                                                           $ acoreLam   @expr.traceCandidateLamArgs
                                                           $ acoreApp   (acoreVar dbNm)
                                                                        ( acoreVar (ehcOptBuiltin @lhs.opts ehbnDataListAltNil)
                                                                        : map acoreVar @expr.traceCandidateLamArgs
                                                                        )
                                                         ]
                                                       , Just @nmStackTrace
                                                       , Map.fromList
                                                           [ (dbNm, emptyLamInfo {laminfoStackTrace = StackTraceInfo_IsStackTraceEquiv @lhs.nm})
                                                           ]
                                                       )
                                                  _ -> ([acoreBind1Asp1 @lhs.nm @cTrf], @lhs.mbInStackTraceCtxt, Map.empty)
  | * - Bind    loc         .   bindCTrfL   =   [acoreBind1Asp1 @lhs.nm @cTrf]

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | Let         lhs         .   cTrf        =   CExpr_Let @categ @binds.bindCTrfL @body.cTrf
  | Var         lhs         .   cTrf        =   case Map.lookup @nm @lhs.lamMp of
                                                  Just (LamInfo {laminfoStackTrace=StackTraceInfo_HasStackTraceEquiv dbNm})
                                                    -> case @lhs.mbInStackTraceCtxt of
                                                         Just stTrNm
                                                           -> acoreApp1 (acoreVar dbNm)
                                                                        (acoreApp (acoreVar hsnStackTracePush) [acoreBuiltinString @lhs.opts (show @nm), acoreVar stTrNm])
                                                         _ -> @cTrf
                                                  _ -> @cTrf

ATTR
  AllCodeNT
  CodeAGItf
    [ | | debugLamMp USE {`Map.union`} {Map.empty}: LamMp ]

SEM CBound
  | Bind        lhs         .   debugLamMp
                                            =   @newLamMp `Map.union` @expr.debugLamMp

SEM CBind
  | *           loc         .   cTrf        :   CBind

SEM CBound
  | *           loc         .   cTrf        :   CBound

