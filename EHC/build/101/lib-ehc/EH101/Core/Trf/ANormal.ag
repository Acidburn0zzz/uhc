MODULE {EH101.Core.Trf.ANormal} {cmodTrfANormal}
{
import EH101.Base.Common
import EH101.Ty
import EH101.Base.Builtin
import Data.Maybe
import qualified Data.Set as Set
import Data.List as List
import qualified Data.Map as Map
import qualified EH.Util.FastSeq as Seq
import EH101.AbstractCore
import EH101.Core
import EH101.Base.Debug

}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/CommonBindNm.ag"
INCLUDE "Core/Trf/CommonFv.ag"
INCLUDE "Core/Trf/CommonLev.ag"
WRAPPER CodeAGItf

PRAGMA nocycle

{
cmodTrfANormal :: HsName -> UID -> CModule -> CModule
cmodTrfANormal modNm uniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf
                                 { gUniq_Inh_CodeAGItf = uniq
                                 , modNm_Inh_CodeAGItf = modNm
                                 })
     in   cTrf_Syn_CodeAGItf t

}
ATTR AllCodeNT CodeAGItf [ modNm: HsName | | ]

ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | App         (func.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq
  | Lam         (body.gUniq,loc.lUniq,loc.lUniq2)
                                            =   mkNewLevUID2 @lhs.gUniq
  | Let         (binds.gUniq,loc.lUniq)     =   mkNewUID @lhs.gUniq
  | Case TupDel TupIns TupUpd
                (expr.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq

{
type LevBindSq = Seq.FastSeq (Int,(CBindCateg,CBindL))

levBindSplit :: Int -> LevBindSq -> (LevBindSq,LevBindSq)
levBindSplit lev b
  =  let (b1,b2) = partition (\(l,_) -> l >= lev) $ Seq.toList b
     in  (Seq.fromList b1,Seq.fromList b2)

}
ATTR AllCodeNT [ | | levBindSq USE {Seq.:++:} {Seq.empty}: LevBindSq ]
ATTR AllBind [ | | bindL USE {++} {[]}: {AssocL Int CBind} ]

SEM CExpr
  | App         lhs         .   levBindSq   =   @arg.levBindSq Seq.:++: @func.levBindSq Seq.:++: @levBindSq
  | Case        lhs         .   levBindSq   =   @expr.levBindSq Seq.:++: @alts.levBindSq Seq.:++: @dflt.levBindSq Seq.:++: @levBindSq
  | TupDel      lhs         .   levBindSq   =   @expr.levBindSq Seq.:++: @offset.levBindSq Seq.:++: @levBindSq
  | TupIns TupUpd
                lhs         .   levBindSq   =   @expr.levBindSq Seq.:++: @offset.levBindSq Seq.:++: @fldExpr.levBindSq Seq.:++: @levBindSq
  | Let         (loc.hereBindSq,loc.remBindSq)
                                            =   let ((hl,_):_) = @binds.bindL
                                                    b1  = @binds.levBindSq
                                                    b2  = Seq.singleton (@strLev hl,(@categ,assocLElts @binds.bindL))
                                                    b12 = Seq.singleton (@maxBindLev,(CBindCateg_Rec,concat $ List.map (\(_,(_,b)) -> b) $ Seq.toList $ (b1 Seq.:++: b2)))
                                                    b3  = @body.levBindSq
                                                    b   = case @categ of
                                                            CBindCateg_Rec -> b12 Seq.:++: b3
                                                            _              -> b1  Seq.:++: b2 Seq.:++: b3
                                                in  (b,Seq.empty)
                lhs         .   levBindSq   =   @remBindSq Seq.:++: @levBindSq
  | Lam         loc         .   (hereBindSq,remBindSq)
                                            =   (@body.levBindSq,Seq.empty) -- levBindSplit @lev @body.levBindSq
                lhs         .   levBindSq   =   @remBindSq Seq.:++: @levBindSq

SEM CBound
  | Bind        lhs         .   bindL       =   [(@expr.levOf,acoreBind1Asp1 @lhs.nm @cTrf)]
  -- | FFI
  | FFE
                lhs         .   bindL       =   [(cLevModule,acoreBind1Asp1 @lhs.nm @cTrf)]

SEM CAlt
  | Alt         (loc.hereBindSq,lhs.levBindSq)
                                            =   (@expr.levBindSq,Seq.empty)

{
data AppTop = AppYesLet | AppNoLet deriving (Eq,Ord)
data LamTop = LamYesLet | LamNoLet deriving (Eq,Ord)

}
ATTR AllExprOnly CBound [ appTrfIsOk: AppTop | | ]

SEM CModule
  | Mod         expr        .   appTrfIsOk  =   AppYesLet

SEM CBound
  | Bind
    FFE
  				expr        .   appTrfIsOk  =   AppNoLet

SEM CPatFld
  | Fld         offset      .   appTrfIsOk  =   AppYesLet

SEM CExpr
  | App         func        .   appTrfIsOk  =   AppNoLet
                arg         .   appTrfIsOk  =   AppYesLet
  | TupIns TupUpd TupDel
                loc         .   appTrfIsOk  =   AppYesLet
  | Lam Let     body        .   appTrfIsOk  =   AppNoLet
  | * - App Lam Let TupIns TupUpd TupDel Ann CaseAltFail
                loc         .   appTrfIsOk  =   AppYesLet

SEM CAlt
  | Alt         expr        .   appTrfIsOk  =   AppYesLet

SEM CBoundL
  | Cons        hd          .   appTrfIsOk  =   AppNoLet

ATTR AllExprOnly CBound [ lamTrfIsOk: LamTop | | ]

SEM CModule
  | Mod         expr        .   lamTrfIsOk  =   LamYesLet

SEM CBound
  | Bind
    FFE
  				expr        .   lamTrfIsOk  =   LamNoLet

SEM CPatFld
  | Fld         offset      .   lamTrfIsOk  =   LamNoLet

SEM CExpr
  | TupIns TupUpd
                fldExpr     .   lamTrfIsOk  =   LamYesLet
  | Lam         body        .   lamTrfIsOk  =   LamNoLet
  | * - Lam TupIns TupUpd Ann CaseAltFail
                loc         .   lamTrfIsOk  =   LamYesLet

SEM CAlt
  | Alt         expr        .   lamTrfIsOk  =   LamYesLet

SEM CBoundL
  | Cons        hd          .   lamTrfIsOk  =   LamNoLet

ATTR AllExprOnly CBound [ letTrfIsOk: Bool | | ]

SEM CModule
  | Mod         expr        .   letTrfIsOk  =   False

SEM CBound
  | Bind
    FFE
  				expr        .   letTrfIsOk  =   False

SEM CPatFld
  | Fld         offset      .   letTrfIsOk  =   True

SEM CExpr
  | TupIns TupUpd
                fldExpr     .   letTrfIsOk  =   True
  | App         loc         .   letTrfIsOk  =   True
  | * - App TupIns TupUpd Ann CaseAltFail
                loc         .   letTrfIsOk  =   False

SEM CAlt
  | Alt         expr        .   letTrfIsOk  =   False

SEM CBoundL
  | Cons        hd          .   letTrfIsOk  =   False

SEM CExpr
  | App Lam Case TupDel TupIns TupUpd Let
                loc         .   trNm        =
                                                hsnQualUniqify @lhs.modNm $
                                                uidHNm @lUniq
  | Lam         loc         .   trNm2       =
                                                hsnQualUniqify @lhs.modNm $
                                                uidHNm @lUniq2


{
mkTrf :: Bool -> Int -> Int -> HsName -> CExpr -> (CExpr,LevBindSq)
mkTrf cond outerLev hereLev n e
  =  if cond
     then (acoreVar n,Seq.singleton (hereLev,(CBindCateg_Plain,[acoreBind1 n e])))
     else (e,Seq.empty)

}
{
mkLetTrf' :: LevBindSq -> CExpr -> (Bool,CExpr)
mkLetTrf' bs ce
  =  let  l = Seq.toList bs
     in   (not (List.null l),foldr (\(_,(c,b)) e -> acoreLet c b e) ce l)

mkLetTrf :: LevBindSq -> CExpr -> CExpr
mkLetTrf bs ce = snd (mkLetTrf' bs ce)

}
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CAlt
  | Alt         lhs         .   cTrf        =   CAlt_Alt @pat.cTrf (mkLetTrf @hereBindSq @expr.cTrf)

SEM CExpr
  | TupIns TupUpd TupDel
                loc         .   trfIsOk     =   @lhs.appTrfIsOk == AppYesLet && @lhs.isTopTup
  | App Case    loc         .   trfIsOk     =   @lhs.appTrfIsOk == AppYesLet && @lhs.isTopApp
  | Lam         loc         .   trfIsOk     =   @lhs.lamTrfIsOk == LamYesLet
  | Let         loc         .   trfIsOk     =   @lhs.letTrfIsOk

SEM CExpr
  | TupIns TupUpd TupDel
                (lhs.cTrf,loc.levBindSq)    =   mkTrf @trfIsOk @lhs.lev @levOf @trNm @cTrf
  | App Case    (lhs.cTrf,loc.levBindSq)    =   mkTrf @trfIsOk @lhs.lev @levOf @trNm @cTrf
  | Lam         (lhs.cTrf,loc.levBindSq)    =   let mkTLB = mkTrf @trfIsOk @lhs.lev @levOf @trNm
                                                          . acoreLam1 @argNm
                                                          . mkLetTrf @hereBindSq
                                                in  if cexprIsLam @body.cTrf && not (List.null (Seq.toList @hereBindSq))
                                                    then mkTLB (CExpr_Let CBindCateg_Plain [acoreBind1Cat CBindCateg_Plain @trNm2 @body.cTrf] (acoreVar @trNm2))
                                                    else mkTLB @body.cTrf
  | Let         (lhs.cTrf,loc.levBindSq)    =   mkTrf @trfIsOk @lhs.lev @levOf @trNm $ mkLetTrf @hereBindSq @body.cTrf

