MODULE {EH101.Core.Trf.AnnBasedSimplify} {cmodTrfAnnBasedSimplify}
{
import EH101.Base.Builtin
import EH101.Base.Common
import EH101.Base.Bits
import EH101.Opts
import EH101.Core
import EH101.Ty
import Data.Maybe
import qualified Data.Set as Set
import EH101.AbstractCore

}
{
}
{
}
{
}
INCLUDE "Core/AbsSyn.ag"
INCLUDE "Core/CommonLev.ag"
INCLUDE "Core/CommonCtxtPred.ag"
INCLUDE "Core/Trf/CommonStructureInfo.ag"
INCLUDE "Core/CommonBindNm.ag"
WRAPPER CodeAGItf

PRAGMA strictcase

{
cmodTrfAnnBasedSimplify :: EHCOpts -> CModule -> CModule
cmodTrfAnnBasedSimplify opts cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { opts_Inh_CodeAGItf = opts
                               })
     in   cTrf_Syn_CodeAGItf t

}
{
data Prop
  = Prop_None
  | Prop_HasTy              Ty          -- has ty
  | Prop_IsTyInt                        -- is of type Int
  | Prop_IsTyInteger                    -- is of type Integer
  | Prop_IsInteger          CExpr       -- is an Integer
  | Prop_IsIntegerConst     Integer     -- is an Integer constant
  | Prop_IsIntConst         Int         -- is an Int constant

type PropS = Set.Set Prop

}
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]

ATTR AllExprOnly CBound AllAlt [ propDown: Prop | | ]

SEM CExpr
  | Ann         expr        .   propDown    =   @ann.prop
  | App         loc         .   propDown    =   Prop_None

SEM CBoundL
  | Cons        hd          .   propDown  	=   Prop_None

SEM CModule
  | Mod         expr        .   propDown    =   Prop_None

SEM CBound
  | Bind Val
    FFE
                loc         .   propDown    =   Prop_None

SEM CPatFld
  | Fld         loc         .   propDown    =   Prop_None

ATTR CExprAnn [ | | prop : Prop ]

SEM CExprAnn
  | Ty          loc         .   prop        =   Prop_HasTy @ty
  | * - Ty      loc         .   prop        =   Prop_None


ATTR CExpr CBound [ | | propUp: Prop ]

SEM CExpr
  | App         loc         .   propUp      =   if @lhs.isTopApp
                                                then case (@func.mbFunVar,reverse (zip (map acoreUnBoundVal @argL) @propUpL),@lhs.propDown) of
                                                       (Just f,[(CExpr_String s,_)],_)
                                                         |    f == (ehcOptBuiltin @lhs.opts ehbnPackedStringToInteger)
                                                         -> Prop_IsIntegerConst $ read s
                                                       (Just f,[_,(e,Prop_IsIntegerConst i)],Prop_HasTy t)
                                                         |    f == (ehcOptBuiltin @lhs.opts ehbnFromInteger)
                                                         -> if t == tyInt
                                                            then -- E.g.: fromInteger dict... (packedStringToInteger "123") :: Int
                                                                 Prop_IsIntConst $ fromInteger i
                                                            else if t == tyInteger
                                                            then -- E.g.: fromInteger dict... (packedStringToInteger "123") :: Integer
                                                                 if signedFitsInBits 30 i
                                                                 then Prop_IsInteger $ acoreApp (acoreVar $ ehcOptBuiltin @lhs.opts ehbnPrimIntToInteger) [acoreInt2 i]
                                                                 else Prop_IsInteger e
                                                            else Prop_None
                                                       _ -> Prop_None
                                                else Prop_None
  | * - App     loc         .   propUp      =   Prop_None

SEM CBound
  | * - Val		loc			.	propUp      =   Prop_None

ATTR CExpr [ | | propUpL: {[Prop]} ]

SEM CExpr
  | App         loc         .   propUpL     =   @arg.propUp : @func.propUpL
  | * - App Ann lhs         .   propUpL     =   []

ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | App         lhs         .   cTrf        =   case @propUp of
                                                  Prop_IsIntConst i
                                                    -> acoreInt i
                                                  Prop_IsInteger e
                                                    -> e
                                                  _ -> @cTrf

