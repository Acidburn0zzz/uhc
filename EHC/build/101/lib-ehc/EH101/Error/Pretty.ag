MODULE {EH101.Error.Pretty} {ppErr, ppErrs, ppErrL
, mkPPErr}
{
import Data.List
import Data.Char
import Data.Maybe
import EH.Util.Pretty
import EH.Util.Utils
import EH101.Base.Common
import EH101.Error
import EH101.Ty
import EH101.Ty.Pretty
import EH.Util.ParseErrPrettyPrint hiding (ppErr)
import EH.Util.FPath
import EH101.Core
import EH101.Core.Pretty

}
{
}
{
}
{
}
{
}
{
}
INCLUDE "Error/AbsSyn.ag"
WRAPPER Err

{
ppErrs :: ErrL -> PP_Doc
ppErrs errL = if null errL then empty else ppCmt ("***ERROR(S):" >-< indent 2 (ppErrL errL))

}
{
ppErrL :: ErrL -> PP_Doc
ppErrL errL = if null errL then empty else vlist (map ppErr errL)

ppErr :: Err -> PP_Doc
ppErr err =  let  r = wrap_Err (sem_Err err) (Inh_Err {nestDepth_Inh_Err=0})
             in   pp_Syn_Err r

}
{
mkPPErr :: PP a => Range -> a -> Err
mkPPErr r = Err_PP r . pp

}
{
ppMsgErr :: PP msg => msg -> PP_Doc -> Range -> PP_Doc
ppMsgErr msg err r
  = mke (msg >|< ":" >-< indent 2 err)
  where mke x | isEmptyRange r = x
              | otherwise      = r  >|< ":" >-< indent 2 x

}
{
ppUnifyErr :: PP msg => msg -> Ty -> Ty -> FIMode -> Ty -> Ty -> FIMode -> Range -> PP_Doc
ppUnifyErr msg t1 t2 fim t1d t2d fimd r
  =  ppMsgErr msg    (    "failed to fit:"  >#< (let p1 = ppTy t1
                                                     p2 = m fim  >|< ppTy t2
                                                 in  if tyIsSimple t1 then p1 >|< p2 else p1 >-< p2)
                     >-<  "problem with :"  >#< (ppTy t1d >|< m fimd >|< ppTy t2d)
                     )
                     r
  where  m fim = " " ++ show fim ++ " "

}
ATTR Err ErrL [ nestDepth: Int | | isNestPP USE {`const`} {False}: Bool ]
ATTR ErrL [ | | isEmpty: Bool ]

SEM Err
  | NestedIn            errL    .   nestDepth   =   if @errL.isEmpty then 0 else @lhs.nestDepth+1
                        lhs     .   isNestPP    =   True

SEM ErrL
  | Nil                 lhs     .   isNestPP    =   True
  | Cons                lhs     .   isNestPP    =   @hd.isNestPP && @tl.isNestPP

SEM ErrL
  | Nil                 lhs     .   isEmpty     =   True
  | Cons                lhs     .   isEmpty     =   False

{
ppNmAndRange :: PP x => [(x,Maybe [(Range,Maybe PP_Doc)])] -> PP_Doc
ppNmAndRange nmL
  = case catMaybes $ map snd $ nmL of
      [] -> ppListSep "" "" ", " $ map fst $ nmL
      _  -> vlist [ n >|< (if null rs then empty else ":" >#< vlist rs)
                  | (n,mbrs) <- nmL
                  , let rs = maybe [] (\rs -> [ maybe (pp r) (\i -> r >#< ppParens i) mbinfo
                                              | (r,mbinfo) <- rs, not (isEmptyRange r)
                                              ]
                                      ) mbrs
                  ]

strCapHeading :: String -> String -> String
strCapHeading kind title@(ht:tt)
  = maybeHd title (const (strCapitalize kind ++ " " ++ [toLower ht] ++ tt)) kind

}
ATTR Err [ | | pp: PP_Doc ]
ATTR ErrL [ | | ppL: {[PP_Doc]} ]

SEM Err
  | UnifyClash          lhs     .  pp   =   ppUnifyErr  "Type clash"
                                                        @ty1 @ty2 @ty1detail @ty2detail
                                                        @range
  | PatArity            lhs     .  pp   =   ppMsgErr    ("Type has wrong arity for pattern")
                                                        ("type :" >#< @ty >-< "arity:" >#< @arity)
                                                        @range
  | PatArity2           lhs     .  pp   =   ppMsgErr    (strCapHeading @kind "has wrong arity for pattern")
                                                        (@kind >#< ":" >#< @what >-< "arity:" >#< @arity)
                                                        @range

SEM Err
  | NamesNotIntrod      lhs     .  pp   =   ppMsgErr    (strCapHeading @kind "Names not in scope")
                                                        (ppNmAndRange @nmL)
                                                        @range
  | NamesDupIntrod      lhs     .  pp   =   ppMsgErr    ("Name(s) for " ++ @kind ++ "(s) introduced more than once")
                                                        -- (strCapHeading @kind "Names introduced more than once")
                                                        (ppNmAndRange @nmL)
                                                        @range
  | NestedIn            loc     .  pp   =   let  h =  if @lhs.nestDepth == 1 && @errL.isNestPP
                                                      then (text "..." >#<)
                                                      else if @lhs.nestDepth <= 1 || @lhs.nestDepth >= 1 && not @errL.isNestPP
                                                      then \x -> ppMsgErr ("In `" >|< @wher >|< "'") x emptyRange
                                                      else id
                                            in   h (vlist @errL.ppL)

SEM ErrL
  | Nil                 lhs     .  ppL  =   []
  | Cons                lhs     .  ppL  =   @hd.pp : @tl.ppL

SEM Err
  | Fixity              lhs     .  pp   =   ppMsgErr    "Fixity mismatch between" (ppListSep "" "" ", " [@op1,@op2])
                                                        @range

SEM Err
  | UnifyOccurs         lhs     .  pp   =   ppUnifyErr  "Infinite type"
                                                        @ty1 @ty2 (mkTyVar @tvar) @ty2detail
                                                        @range

SEM Err
  | UnifyClash          lhs     .  pp   :=  ppUnifyErr  "Type clash"
                                                        @ty1 @ty2 @fiMode @ty1detail @ty2detail @fiModeD
                                                        @range
  | UnifyOccurs         lhs     .  pp   :=  ppUnifyErr  "Infinite type"
                                                        @ty1 @ty2 @fiMode (mkTyVar @tvar) @ty2detail @fiModeD
                                                        @range
  | OccurCycle          lhs     .  pp   =   ppMsgErr    "Occur cycle"
                                                        (    "type var:" >#< pp @tvar
                                                         >-< "to type :" >#< pp @ty
                                                        )
                                                        @range

SEM Err
  | Newtype             lhs     .  pp   =   ppMsgErr    ("Newtype must have exactly 1 constructor with 1 field")
                                                        ("Type:" >#< @tyNm)
                                                        @range
  | FunPatternLengths   lhs     .  pp   =   ppMsgErr    ("Nr of arguments to function must be equal for all function alternatives")
                                                        ("Function:" >#< @funNm)
                                                        @range

SEM Err
  | MissingRowLabels    lhs     .  pp   =   ppMsgErr    ("Missing label(s) in row")
                                                        ("Label(s):" >#< ppCommas' @nmL >-< "Row     :" >#< ppTy @ty)
                                                        @range
  | TooManyRowLabels    lhs     .  pp   =   ppMsgErr    "Too many label(s) to fit in row"
                                                        ("Label(s):" >#< ppCommas' @nmL >-< "Row     :" >#< ppTy @ty)
                                                        @range

SEM Err
  | MissingDataFields   lhs     .  pp   =   ppMsgErr    ("Missing field(s) in data construction")
                                                        ("Field(s)   :" >#< ppCommas' @nmL >-< "Constructor:" >#< pp @con)
                                                        @range
  | MissingAnyDataField lhs     .  pp   =   ppMsgErr    ("No data constructor has all fields")
                                                        ("Field(s):" >#< ppCommas' @nmL >-< "Type    :" >#< pp @tyNm)
                                                        @range
  | DuplicateDataFields lhs     .  pp   =   ppMsgErr    ("Duplicate field(s) in data construction/update")
                                                        ("Field(s):" >#< ppCommas' @nmL)
                                                        @range
  | InconsistentIntros  lhs     .  pp   =   ppMsgErr    ("Inconsistent " ++ @kind ++ " introductions for")
                                                        ("names:" >#< ppCommas' @nmL)
                                                        @range

SEM Err
  | FileNotFound        lhs     .  pp   =   ppMsgErr    "File not found"
                                                        (    "file name         :" >#< @fileName
                                                         >-< "searched locations:" >#< vlist (map (text.show) @locations)
                                                         -- >-< "attempted suffixes:" >#< ppCommas' (map pp $ catMaybes @suffixes)
                                                        )
                                                        @range
  | AmbiguousExport     lhs     .  pp   =   ppMsgErr    "Ambiguous export"
                                                        (    "name   :" >#< @name
                                                         >-< "exports:" >#< ppNmAndRange @entities
                                                        )
                                                        @range
  | PP                  lhs     .  pp   =   @pp

SEM Err
  | IllegalFFIWay       lhs     .  pp   =   ppMsgErr    "Illegal foreign interface"
                                                        (    "to:" >#< @ffiWay
                                                        )
                                                        @range
  | TyCoreMatchClash    lhs     .  pp   :=  ppMsgErr    "TyCore type mismatch"
                                                        (    "between          :" >#< @ty1
                                                         >-< "and              :" >#< @ty2
                                                         >-< "in detail between:" >#< @ty1detail
                                                         >-< "and              :" >#< @ty2detail
                                                        )
                                                        @range
  | TyCoreSeqLevels     lhs     .  pp   :=  ppMsgErr    "TyCore sequence nr of levels error"
                                                        (    "#levels        :" >#< @hereLev
                                                         >-< "must be #levels:" >#< @mustLev
                                                         >-< "in             :" >#< @ty
                                                        )
                                                        @range
  | NoCoerceDerivation  lhs     .  pp   =   ppMsgErr    "Cannot derive coercion for type application"
                                                        (    "type function:" >#< pp @func
                                                         >-< "type arg     :" >#< pp @arg
                                                        )
                                                        @range

SEM Err
  | PrfCutOffReached    lhs     .  pp   =   ppMsgErr    "Proof cut off limit reached"
                                                        (    "limit:" >#< pp @depth
                                                         >-< "pred :" >#< pp @pred
                                                        )
                                                        @range
  | NotProvenPreds      lhs     .  pp   =   ppMsgErr    "Predicates remain unproven"
                                                        -- (    "preds:" >#< (ppAssocLV [ (pp p, t >-< vlist r) | ((p,r),t) <- @preds ] )
                                                        (    "preds:" >#< (vlist [ pp p >-< indent 2 (("at   :" >#< vlist r) >-< ("trace:" >#< t)) | ((p,r),t) <- @preds ] )
                                                        )
                                                        @range
  | AmbigPreds          lhs     .  pp   =   ppMsgErr    "Predicates leading to ambiguous type"
                                                        (    "preds                :" >#< (ppAssocLV $ assocLMapElt vlist @preds)
                                                        >-<  "bindings             :" >#< ppAssocLV @inBinds
                                                        >-<  "bindings (quantified):" >#< ppAssocLV @inQBinds
                                                        )
                                                        @range
  | OverlapPreds        lhs     .  pp   =   ppMsgErr    "Proofs for predicates overlap"
                                                        (    vlist . map (\(p,evs) -> p >#< ":" >#< ppBracketsCommas evs) $ @overl
                                                        )
                                                        @range
  | TyHasFreeTVars      lhs     .  pp   =   ppMsgErr    "Type has free type variables (not allowed)"
                                                        (    "type:" >#< pp @ty
                                                        )
                                                        @range
  | DeclsNotAllowed     lhs     .  pp   =   ppMsgErr    ("Declarations are not allowed " ++ @inside)
                                                        (vlist [ k >|< ":" >#< ppCommas ns | (k,ns) <- @decls ]
                                                        )
                                                        @range
  | ValWithoutSig       lhs     .  pp   =   ppMsgErr    ("Instance members without corresponding signature from class")
                                                        (    "names:" >#< ppCommas @nmL
                                                        )
                                                        @range
  | NoMostSpecificPred  lhs     .  pp   =   ppMsgErr    "Cannot determine most specific predicate"
                                                        (    "preds:" >#< vlist [@pred1,@pred2]
                                                        )
                                                        @range
  | EvidenceAltsLeft    lhs     .  pp   =   ppMsgErr    "Evidence alternatives left (TBD: more info)"
                                                        (    empty
                                                        )
                                                        @range

SEM Err
  | MalformedPred       lhs     .  pp   =   ppMsgErr    ("Type cannot be parsed as context")
                                                        (    "type:" >#< @pp
                                                        )
                                                        @range

SEM Err
  | TyBetaRedLimit      lhs     .  pp   =   ppMsgErr    "Type synonym expansion limit reached"
                                                        (    "limit          :" >#< pp @limit
                                                         >-< "type           :" >#< pp @ty
                                                         >-< "last expansion :" >#< pp @tyTo
                                                        )
                                                        @range

SEM Err
  | MayOnlyHaveNrMain   lhs     .  pp   =   ppMsgErr    "Number of definitions for 'main' exceeds limit"
                                                        (                                         "limit                :" >#< @nrAllowed
                                                         >-<                                      "module               :" >#< @modNm
                                                         >-< (if null @prevModNmL then empty else "previously defined in:" >#< ppCommas' @prevModNmL)
                                                        )
                                                        @range
  | MayNotHaveMain      lhs     .  pp   =   ppMsgErr    "May not have a 'main'"
                                                        ("module:" >#< @modNm
                                                        )
                                                        @range
  | MustHaveMain        lhs     .  pp   =   ppMsgErr    "No 'main' defined"
                                                        empty
                                                        @range
  | ModNameMismatch     lhs     .  pp   =   ppMsgErr    "Module names do not match"
                                                        (    "filename        :" >#< @nmOfFile
                                                         >-< "name from source:" >#< @nmFromSrc
                                                        )
                                                        @range
  | AmbiguousNameRef    lhs     .  pp   =   ppMsgErr    ("Ambiguous " ++ @kind ++ " name reference")
                                                        (    (take 12 (@kindName ++ repeat ' ') ++
                                                                         ":") >#< @nm
                                                         >-< "may refer to:"  >#< vlist (map pp @nmAlts)
                                                        )
                                                        @range
  | MutRecModules       lhs     .  pp   =   ppMsgErr    "Mutually recursive modules"
                                                        (    "modules:" >#< vlist (map ppCommas' @mutRecL)
                                                        )
                                                        @range

SEM Err
  | MalformedTy         lhs     .  pp   =   ppMsgErr    ("Malformed " ++ @kind ++ " for " ++ @purpose)
                                                        (    @kind >|< ":" >#< ppTy @ty
                                                        )
                                                        @range
  | NoDerivFor          lhs     .  pp   =   ppMsgErr    ("No deriving for")
                                                        (    "predicate:" >#< @pred
                                                        )
                                                        @range
  | NoDerivForData      lhs     .  pp   =   ppMsgErr    ("Data type has wrong structure for deriving")
                                                        (    "data type :" >#< @ty
                                                         >-< "class name:" >#< @clNm
                                                         >-< "because   :" >#< @reason
                                                        )
                                                        @range

SEM Err
  | FusionBuildInverse  lhs     .  pp   =   ppMsgErr    ("Fusion build/unbuild pair are not each others type level inverse")
                                                        (    "type 1        :" >#< @ty1
                                                         >-< "type 2 inverse:" >#< @ty2
                                                        )
                                                        @range

SEM Err
  | InconsistentHI      lhs     .  pp   =   ppMsgErr    (".hi file cannot be used with this compiler")
                                                        (    "module              :" >#< @modNm
                                                         >-< "file                :" >#< @file
                                                         >-< "this compiler       :" >#< (concat $ intersperse " / " @expected)
                                                         >-< "compiler of .hi file:" >#< (concat $ intersperse " / " @inHI    )
                                                        )
                                                        @range
  | WrongMagic          lhs     .  pp   =   ppMsgErr    (".hi file has wrong magic number")
                                                        (    "module              :" >#< @modNm
                                                         >-< "file                :" >#< @file
                                                        )
                                                        @range

