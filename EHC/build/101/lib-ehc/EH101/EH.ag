MODULE {EH101.EH} {AGItf (..), Decl (..), Decls, TyExpr (..), Expr (..), PatExpr (..)
, ExprAnn (..), PatExprAnn (..), TyExprAnn (..)
, mkLet
, TyExprs, TyVar (..), TyVars, CaseAlt (..), CaseAlts, DataConstr (..), DataConstrs
, mkCase, mkCase', mkIf, mkIf', mkError, mkStr, mkAlt
, KiExpr (..), KiExprAnn (..)
, RecExpr (..), RecPatExpr (..), RowTyExpr (..), DataField (..), DataFields, DataFieldExpr (..), DataFieldPatExpr (..)
, module EH101.Base.Target
, mkLet', mkIf''
, ehIsDeclVal
, PrExpr (..), PrExprs
, mkUnit, mkError'
, FuncDep (..), FuncDeps
, MbTyExpr
, mkEH}
{
import EH101.Base.Common
import EH101.Base.Builtin
import EH101.HS (Range)
import EH101.Ty
import qualified Data.Set as Set
import EH101.Base.Target (FFIWay)
import EH101.Foreign

}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
{
}
INCLUDE "EH/AbsSyn.ag"
{
ehIsDeclVal :: Decl -> Bool
ehIsDeclVal (Decl_Val _ _ _) = True
ehIsDeclVal _                = False

}
{
mkLet' :: Bool -> Range -> Maybe [Decl] -> Expr -> Expr
mkLet' isStrict r md e
  = case md of
      Just d@(_:_) -> rngLift r Expr_Let isStrict d e
      _            -> e

mkLet :: Range -> Maybe [Decl] -> Expr -> Expr
mkLet = mkLet' False

}
{
mkUnit :: Range -> Expr
mkUnit r = rngLift r Expr_Rec (rngLift r RecExpr_Empty)

}
{
mkError':: HsName -> Range -> String -> Expr
mkError' e r m
  = mkApp [rngLift r Expr_Var e,mkStr r (show r ++ ": " ++ m)]

mkError :: Range -> String -> Expr
mkError = mkError' hsnError

mkStr :: Range -> String -> Expr
mkStr r s
  = rngLift r Expr_SConst s

}
{
mkIf'' :: [HsName] -> Range -> Expr -> Expr -> Expr -> Maybe UIDS -> UIDS -> Expr
mkIf'' (bn:tn:fn:_) r c t e i failS
  = case c of
      Expr_Con _ n
          | n == tn -> t
          | n == fn -> e
      _ -> mkCase' r
             ( rngLift r Expr_TypeAs (rngLift r TyExpr_Con bn) c )
             i failS False
             [ mkAlt r (rngLift r PatExpr_Con tn) t
             , mkAlt r (rngLift r PatExpr_Con fn) e
             ]

}
{
mkIf' :: [HsName] -> Range -> Expr -> Expr -> Expr -> Expr
mkIf' ns r c t e = mkIf'' ns r c t e Nothing Set.empty

}
{
mkIf :: Range -> Expr -> Expr -> Expr -> Expr
mkIf = mkIf' [hsnBool,hsnTrue,hsnFalse]

}
{
mkAlt :: Range -> PatExpr -> Expr -> CaseAlt
mkAlt r p e = rngLift r CaseAlt_Pat p e

}
{
mkCase' :: Range -> Expr  -> Maybe UIDS -> UIDS -> Bool -> [CaseAlt] -> Expr
mkCase' r c id failS istup as
  = rngLift r Expr_Case c as id failS istup

mkCase :: Range -> Expr -> [(PatExpr,Expr)] -> Expr
mkCase r c as
  = mkCase' r c Nothing Set.empty False [ mkAlt r p e | (p,e) <- as ]

}
{
mkEH :: (Range -> x) -> x
mkEH = rngLift emptyRange

}
{
instance SemApp Expr where
  semRngApp    r  = rngLift r Expr_App
  semRngAppTop r  = rngLift r Expr_AppTop
  semRngVar    r  = rngLift r Expr_Var . mkHNm
  semRngCon    r  = rngLift r Expr_Con . mkHNm
  semRngParens r  = rngLift r Expr_Parens
  mkProdApp l
    = mkEH Expr_Rec $ mkEH RecExpr_Empty `mkRow` l
    where mkRow = foldl (\r e -> mkEH RecExpr_Ext r Nothing e)

}
{
instance SemApp PatExpr where
  semRngApp    r  = rngLift r PatExpr_App
  semRngAppTop r  = rngLift r PatExpr_AppTop
  semRngVar    r  = rngLift r PatExpr_Var . mkHNm
  semRngCon    r  = rngLift r PatExpr_Con . mkHNm
  semRngParens r  = rngLift r PatExpr_Parens
  mkProdApp l
    = mkEH PatExpr_Rec $ mkEH RecPatExpr_Empty `mkRow` l
    where mkRow = foldl (\r e -> mkEH RecPatExpr_Ext r Nothing e)

}
{
instance SemApp TyExpr where
  semRngApp    r  = rngLift r TyExpr_App
  semRngAppTop r  = rngLift r TyExpr_AppTop
  semRngVar    r  = rngLift r TyExpr_Var . mkHNm
  semRngCon    r  = rngLift r TyExpr_Con . mkHNm
  semRngParens r  = rngLift r TyExpr_Parens
  mkProdApp l
    = mkEH TyExpr_Row $ mkEH RowTyExpr_Empty `mkRow` l
    where mkRow = foldl (\r e -> mkEH RowTyExpr_Ext r Nothing e)
  unTop (TyExpr_AppTop _ x)       = unTop x
  unTop (TyExpr_Parens _ x)       = unTop x
  unTop (TyExpr_Ann  _ _ x)       = unTop x
  unTop x                         = x
  isApp1 (TyExpr_App _ f a)       = Just (f,a)
  isApp1 _                        = Nothing
  isCon (TyExpr_Con _ n)          = Just n
  isCon _                         = Nothing

}
{
instance SemApp KiExpr where
  semRngApp    r  = rngLift r KiExpr_App
  semRngAppTop r  = rngLift r KiExpr_AppTop
  semRngVar    r  = rngLift r KiExpr_Var . mkHNm
  semRngCon    r  = rngLift r KiExpr_Con . mkHNm
  semRngParens r  = rngLift r KiExpr_Parens

}
