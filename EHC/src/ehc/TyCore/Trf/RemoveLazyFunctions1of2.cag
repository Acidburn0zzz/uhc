%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Remove lazy bound lambdas, part 1 of 2
%%%
%%% First part of transformation, removes unnecessary lazy definitions.
%%% Note that the output of this first part is not a Type Correct program.
%%% 
%%% For example:
%%% > let id = {\x -> |x|}
%%% >     id :: {{Int} -> Int}
%%% > in |id|
%%% 
%%% Becomes:
%%% > let id = \x -> |x|
%%% >     id :: {Int} -> Int
%%% > in |id|
%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.RemoveLazyFunctions1of2}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras)
%%]

%%[(8 codegen) hs import(Data.Maybe)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/AbsSyn})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfRemoveLazyFunctions1of2 hs
cmodTrfRemoveLazyFunctions1of2 :: Module -> Module
cmodTrfRemoveLazyFunctions1of2 tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf : SELF ]
ATTR AllExpr   [ boundLazy : {Bool} | | ]

-- Top level environment propagation

SEM Module
  | Mod
                loc         .   boundLazy   =   False

SEM ValBind
  | Val
                l1          .   boundLazy   =   @l0.isDelayLam

-- Remove laziness

SEM Expr
  | Delay
                lhs         .   cTrf        =   if @isDelayLam
                                                then @expr.cTrf
                                                else @cTrf

  | Lazy
                lhs         .   cTrf        =   if @lhs.boundLazy
                                                then @expr.cTrf
                                                else @cTrf
                expr        .   boundLazy   =   False
%%]

%%[(8 codegen)
-- Attributes that are needed because AG doesn't have pattern matching

ATTR Expr
  [
  |
  | isLam       : {Bool}
    isDelayLam  : {Bool}
  ]

SEM Expr
  | Lam
                lhs         .   isLam       =   True
  | * - Lam
                lhs         .   isLam       =   False
  | Delay
                loc         .   isDelayLam  =   @expr.isLam
  | * - Delay
                lhs         .   isDelayLam  =   False
%%]

