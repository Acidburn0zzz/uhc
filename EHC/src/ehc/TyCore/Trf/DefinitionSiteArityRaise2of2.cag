%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Definition-site arity raising in TyCore
%%%
%%% To keep sharing when doing partial applications, this will only raise nested lambdas.
%%%
%%% For example:
%%% > \[a] -> \[b] -> let g = f a b
%%% >                 in \[c] -> [d] -> g c
%%%
%%% Becomes:
%%% > \[a, b] -> let g = f a b
%%% >            in \[c, d] -> g c
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.DefinitionSiteArityRaise2of2}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Control.Applicative)
%%]

%%[(8 codegen) hs import(Data.Bool.Extras, Data.Maybe, Data.List)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/Trf/ConstructTypeEnvironment})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfDefinitionSiteArityRaise hs
cmodTrfDefinitionSiteArityRaise2of2 :: Module -> Module
cmodTrfDefinitionSiteArityRaise2of2 tcmod
  = let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
    in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf    : SELF
    wrapper : SELF
  ]
ATTR AllExpr
  [ workerNm   : {HsName}
  |
  | workWrap      USE {|||} {Ignored}           : {WorkWrap}
  ]
ATTR Expr
  [
  |
  | lamArgs    : {[[Expr]]}
    mbVarNm    USE {<|>} {Nothing} : {Maybe HsName}
    appArgs    USE {++}  {[]}      : {[Expr]}
  ]

SEM Module
  | Mod
                loc         .   workerNm    =   error "Don't read this value"

SEM ValBindL
  | Cons        lhs         .   cTrf        =   case @hd.workWrap of
                                                  UpdatedWrapper -> @hd.wrapper : @tl.cTrf
                                                  _              -> @hd.cTrf    : @tl.cTrf

-- Worker/Wrapper
SEM ValBind
  | Val
                loc         .   workWrap    =   case (@isWrapper) of
                                                  (True) -> UpdatedWrapper
                                                  (_)    -> Ignored
                            .   isWrapper   =   @workerNm `Map.member` @lhs.tyEnv
                            .   workerNm    =   hsnFromString $ show @nm ++ "_worker"

SEM Expr
  | Let
                lhs         .   lamArgs     =   [] : @body.lamArgs
  | Lam
                lhs         .   lamArgs     =   list [[@arg.copy]] (\x xs -> (@arg.copy : x) : xs) @res.lamArgs
  | * - Lam Let
                lhs         .   lamArgs     =   []


-- Wrapper
SEM ValBind
  | Val
                lhs         .   wrapper     =   ValBind_Val @nm @bindMeta.cTrf @mlev @l1.cTrf @wrapperBody
                loc         .   wrapperBody =   if @workWrap == Introduced
                                                then newWrapperBody @workerNm @l0.lamArgs
                                                else @l0.wrapper

SEM Expr
  | App
                lhs         .   wrapper     =   if @func.mbVarNm == Just @lhs.workerNm
                                                then updatedWrapperApp @lhs.workerNm @appArgs @wt
                                                else @wrapper
                loc         .   wt          =   fromMaybe (tyErr "DefinitionSiteArityRaise2of2: App.workerType lookup")
                                                (@lhs.workerNm `Map.lookup` @lhs.tyEnv)
                            .   appArgs     =   @func.appArgs ++ [@arg.copy]
  | Var
                lhs         .   mbVarNm     =   Just @nm

{
-- This function will be in list-extras:Data.List.Extras
list :: b -> (a -> [a] -> b) -> [a] -> b
list b _ []     = b
list _ f (x:xs) = f x xs

newWrapperBody :: HsName -> [[Ty]] -> Expr
newWrapperBody nm argss = foldr Expr_Lam body (concat argss)
  where
    body :: Expr
    body = foldl Expr_App (Expr_Var nm) (map arg argss)

    arg :: [Expr] -> Expr
    arg args = Expr_Seq (map argSeq (concatMap unSeqs args))

    argSeq :: ExprSeq1 -> ExprSeq1
    argSeq (ExprSeq1_L0Bind nm _ _) = ExprSeq1_L0Val (Expr_Var nm) Nothing
    argSeq (ExprSeq1_L1Bind nm _)   = ExprSeq1_L1Val (Expr_Var nm)
    argSeq (ExprSeq1_L2Bind nm _)   = ExprSeq1_L2Val (Expr_Var nm)
    argSeq e                        = e

updatedWrapperApp :: HsName -> [Expr] -> Ty -> Expr
updatedWrapperApp nm args wt = f (init $ nrArgs wt) (concatMap unSeqs args)
  where
    f :: [Int] -> [ExprSeq1] -> Expr
    f []     _    = Expr_Var nm
    f (x:xs) args = let (args1, args2) = splitAt x args
                    in f xs args2 `Expr_App` Expr_Seq args1

    nrArgs :: Ty -> [Int]
    nrArgs (Expr_Seq es)    = [length es]
    nrArgs (Expr_Arrow l r) = nrArgs l ++ nrArgs r
    nrArgs _                = [1]
}
%%]

