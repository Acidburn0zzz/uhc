%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimize TyCore based on strictness annotations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.OptimizeStrictness} import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Control.Applicative, Control.Monad, Data.Maybe, qualified Data.Map as Map)
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]

-- for debug
%%[(8 codegen) hs import({%{EH}Base.Debug},EH.Util.Pretty)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/AbsSyn})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 tauphi).tcmodTrfOptimizeStrictness hs
cmodTrfOptimizeStrictness :: Module -> Module
cmodTrfOptimizeStrictness tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 tauphi)
ATTR AGItf [ | | cTrf: Module ]
ATTR AllCodeNT
  [ sigMap : {Map.Map HsName Expr}
    params : {Map.Map HsName ExprAnn}
  |
  | cTrf : SELF
    strictWrkr : SELF
    lazyWrppr  : SELF
    sigMap1 USE {`Map.union`} {Map.empty} : {Map.Map HsName Expr}
    leftVar USE {<|>} {Nothing} : {Maybe HsName}
    argPos USE {<|>} {Nothing} : {Maybe Int}
  ]
ATTR AllExpr
  [
  |
  | hasStrictW USE {||} {False} : {Bool}
  ]
ATTR AllExprBase
  [ strictName : {HsName}
  |
  |
    strictArgs USE {++} {[]} : {[Bool]}
  ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
                module      .   sigMap      =   @module.sigMap1
                module      .   params      =   Map.empty

SEM ValBindL
  | Cons        lhs         .   cTrf        =   if @hd.hasStrictW
                                                then @hd.strictWrkr : @hd.lazyWrppr : @tl.cTrf
                                                else @hd.cTrf : @tl.cTrf

SEM ValBind
  | Val         lhs         .   strictWrkr  =   ValBind_Val @loc.strictName @bindMeta.strictWrkr @mlev @l1.strictWrkr @l0.strictWrkr
                lhs         .   hasStrictW  =   @l1.hasStrictW -- If type isn't strict, neither is body
                lhs         .   lazyWrppr   =   trace (show @l1.strictArgs) $ ValBind_Val @nm @bindMeta.cTrf @mlev @l1.lazyWrppr (mkLazyWrapper @loc.strictName @l1.strictArgs @l0.lazyWrppr)
                l0          .   strictName  =   @loc.strictName
                loc         .   strictName  =   hsnFromString (show @nm ++ "_strict")

{
mkLazyWrapper :: HsName -> [Bool] -> Expr -> Expr
mkLazyWrapper n (_:sas) (Expr_Lam (Expr_Seq []) e) = Expr_Lam (Expr_Seq []) (mkLazyWrapper n sas e)
mkLazyWrapper n sas     e                          = f [] sas e
  where
    f :: [(HsName, Bool)] -> [Bool] -> Expr -> Expr
    f anns (b:sas) (Expr_Lam arg res) = Expr_Lam arg $ f ((paramName arg, b) : anns) sas res
    f anns _       _                  = foldr (\(n, b) e -> Expr_App e ((if b then mkExprUnThunk else singletonSeq) $ Expr_Var n)) (mkExprUnThunk $ Expr_Var n) anns
}

SEM Expr
  | App         lhs         .   strictWrkr  =   if isJust (@func.leftVar >>= \l -> Map.lookup l @lhs.params >>= \a -> case a of (ExprAnn_Strictness Strict) -> Just (); _ -> Nothing)
                                                then (singletonSeq @func.cTrf)
                                                else (Expr_App @func.cTrf @arg.cTrf)
  | Lam         lhs         .   strictWrkr  =   if isJust (paramAnn @arg.strictWrkr >>= \ann -> case ann of (ExprAnn_Strictness Strict) -> Just (); _ -> Nothing)
                                                then Expr_Lam @arg.strictWrkr @res.strictWrkr
                                                else Expr_Lam @arg.strictWrkr @res.strictWrkr
                res         .   params      =   maybe @lhs.params (\ann -> Map.insert (paramName @arg.cTrf) ann @lhs.params) (paramAnn (@arg.cTrf))
  | Arrow       lhs         .   strictWrkr  =   if @loc.isStrict
                                                then unAnn $ headSeq $ unThunkType @loc.strictSelf
                                                else mapSeq unAnn @loc.strictSelf
                lhs         .   hasStrictW  =   @loc.hasStrictW
                lhs         .   strictArgs  =   @arg.hasStrictW : @res.strictArgs
                loc         .   strictSelf  =   Expr_Arrow @arg.strictWrkr @res.strictWrkr
                loc         .   self        =   Expr_Arrow @arg.cTrf @res.cTrf
                loc         .   hasStrictW  =   @loc.isStrict || @arg.hasStrictW || @res.hasStrictW
                loc         .   isStrict    =   isThunkType @loc.self && isJust ((exprAnn $ headSeq $ unThunkType @loc.self) >>= \a -> case a of (ExprAnn_Strictness Strict) -> Just (); _ -> Nothing)
                lhs         .   lazyWrppr   =   Expr_Arrow @arg.lazyWrppr (unAnn @res.lazyWrppr)
  -- | Var         lhs         .   strictWrkr  =   annTrace (show $ Map.lookup @nm @lhs.params) $ Expr_Var @nm

{
annTrace :: String -> Expr -> Expr
annTrace s e = Expr_Ann (ExprAnn_GrinHint s) e

argType :: Maybe HsName -> Maybe Int -> Map.Map HsName Expr -> Maybe Expr
argType n x m = n >>= \n -> x >>= \x -> Map.lookup n m >>= arg x
  where
    arg :: Int -> Expr -> Maybe Expr
    arg 1 (Expr_Arrow l r) = Just l
    arg x (Expr_Arrow l r) = arg (x-1) r

resultType :: Maybe HsName -> Map.Map HsName Expr -> Maybe Expr
resultType n m = n >>= \n -> Map.lookup n m >>= res
  where
    res :: Expr -> Maybe Expr
    res (Expr_Arrow l r@(Expr_Arrow _ _)) = res r
    res (Expr_Arrow l r)                  = Just r

nilSeq :: Expr -> Bool
nilSeq (Expr_Seq []) = True
nilSeq _             = False

singletonSeq :: Expr -> Expr
singletonSeq e = Expr_Seq [ExprSeq1_L0Val e Nothing]

seqToList :: Expr -> [Expr]
seqToList (Expr_Seq [ExprSeq1_L0Val e _]) = [e]
seqToList e                               = [e]

mapSeq :: (Expr -> Expr) -> Expr -> Expr
mapSeq f (Expr_Seq xs) = Expr_Seq (map g xs)
  where
    g (ExprSeq1_L0Val e m) = ExprSeq1_L0Val (f e) m
    g e                    = error $ "TyCore.Trf.OptimizeStrictness.mapSeq: cannot map expression (" ++ show e ++ ")"
mapSeq _ e = e

headSeq :: Expr -> Expr
headSeq = head . seqToList

isThunkType :: Expr -> Bool
isThunkType (Expr_Arrow (Expr_Seq []) _) = True
isThunkType _                            = False

unThunkType :: Expr -> Expr
unThunkType (Expr_Arrow (Expr_Seq []) e) = e
unThunkType e                            = error $ "forceThunkType: type (" ++ show e ++ ") isn't a thunk type."

paramName :: Expr -> HsName
paramName (Expr_Seq [ExprSeq1_L0Bind n Nothing e]) = n
paramName e = error $ "OptimizeStrictness.paramName: not a valid bind (" ++ show e ++ ")"

paramAnn :: Expr -> Maybe ExprAnn
paramAnn (Expr_Seq [ExprSeq1_L0Bind _ Nothing e]) = let e' = headSeq e
                                                        ae = headSeq $ if isThunkType e' then unThunkType e' else e'
                                                    in case ae of (Expr_Ann a _) -> Just a; _ -> Nothing
paramAnn _                                        = Nothing

exprAnn :: Expr -> Maybe ExprAnn
exprAnn (Expr_Ann a _) = Just a
exprAnn _              = Nothing

unAnn :: Expr -> Expr
unAnn (Expr_Seq [ExprSeq1_L0Val (Expr_Ann _ e) m]) = Expr_Seq [ExprSeq1_L0Val e m]
unAnn (Expr_Ann _ e)                               = e
unAnn e                                            = e

}

-- SEM ExprAnn
--   | Strictness  lhs         .   cTrf        =   ExprAnn_GrinHint $ case @s of { Strict -> "Strict"; NonStrict -> "NonStrict"; x -> "Other" }

SEM Expr
  | App         lhs         .   argPos      =   @loc.argPos
                loc         .   argPos      =   fmap (+1) @func.argPos
  | Var         lhs         .   leftVar     =   Just @nm
                lhs         .   argPos      =   Just 0
SEM ValBind
  | Val         lhs         .   sigMap1     =   Map.singleton @nm @l1.cTrf

%%]

