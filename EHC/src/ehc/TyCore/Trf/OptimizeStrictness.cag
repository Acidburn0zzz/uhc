%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimize TyCore based on strictness annotations
%%%
%%% Note, this transformation:
%%%  - Requires explicit Lazy/Delay/Force constructs
%%%  - Expects Haskell-style lazyness (only singleton thunks), so [{[Int]}, {[Char]}]
%%%    instead of [{[Int, Char}]}]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.OptimizeStrictness} import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Control.Applicative, Control.Monad, Data.Maybe, qualified Data.Map as Map)
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras)
%%]

%%[1 hs import(Debug.Trace)
%%]

-- for debug
%%[(8 codegen) hs import({%{EH}Base.Debug},EH.Util.Pretty)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/AbsSyn})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 tauphi).tcmodTrfOptimizeStrictness hs
cmodTrfOptimizeStrictness :: Module -> Module
cmodTrfOptimizeStrictness tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 tauphi)
ATTR AGItf [ | | cTrf: Module ]
ATTR AllCodeNT
  [ params : {Map.Map HsName ExprAnn}
  |
  | cTrf : SELF
    strictWrkr : SELF
    lazyWrppr  : SELF
    varNm USE {<|>} {Nothing} : {Maybe HsName}
  ]
ATTR AllExpr
  [
  |
  | hasStrictW USE {||} {False} : {Bool}
  ]
ATTR AllExprBase
  [ strictName : {HsName}
  |
  |
    strictArgs USE {++} {[]} : {[Bool]}
    isStrict   USE {||} {False} : {Bool}
  ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
                module      .   params      =   Map.empty

SEM ValBindL
  | Cons        lhs         .   cTrf        =   if @hd.hasStrictW
                                                then @hd.strictWrkr : @hd.lazyWrppr : @tl.cTrf
                                                else @hd.cTrf : @tl.cTrf

SEM ValBind
  | Val         lhs         .   strictWrkr  =   ValBind_Val @loc.strictName @bindMeta.strictWrkr @mlev @l1.strictWrkr @l0.strictWrkr
                lhs         .   hasStrictW  =   @l1.hasStrictW -- If type isn't strict, neither is body
                lhs         .   lazyWrppr   =   ValBind_Val @nm @bindMeta.cTrf @mlev @l1.lazyWrppr (mkLazyWrapper @loc.strictName @l1.strictArgs @l0.lazyWrppr)
                l0          .   strictName  =   @loc.strictName
                loc         .   strictName  =   hsnFromString (show @nm ++ "_strict")

{
mkLazyWrapper :: HsName -> [Bool] -> Expr -> Expr
mkLazyWrapper n sas (Expr_Delay e) = Expr_Delay (mkLazyWrapper n sas e)
mkLazyWrapper n sas e              = f [] sas e
  where
    f :: [(HsName, Bool)] -> [Bool] -> Expr -> Expr
    f anns (b:sas) (Expr_Lam arg res) = Expr_Lam arg $ f ((paramName arg, b) : anns) sas res
    f anns _       _                  = foldr g (Expr_Force $ Expr_Var n) anns
    g (n, b) e = Expr_App e (bool singletonSeq Expr_Force b $ Expr_Var n)
}

SEM Expr
  | Var         lhs         .   varNm       =   Just @nm
  | Lam
                res         .   params      =   maybe @lhs.params
                                                      (\ann -> Map.insert (paramName @arg.cTrf) ann @lhs.params)
                                                      (paramAnn @arg.cTrf)
  | Lazy
                lhs         .   strictWrkr  =   if @loc.isStrict
                                                then unAnn $ head $ seqToList @expr.strictWrkr
                                                else Expr_Lazy @expr.strictWrkr
                lhs         .   isStrict    =   @loc.isStrict
                loc         .   isStrict    =   isStrictAnn (exprAnn $ headSeq $ @expr.cTrf)
                loc         .   hasStrictW  =   @loc.isStrict || @expr.hasStrictW
                lhs         .   lazyWrppr   =   Expr_Lazy (unAnn @expr.lazyWrppr)
  | Force
                lhs         .   strictWrkr  =   if hasStrictAnn @expr.varNm @lhs.params 
                                                then singletonSeq @expr.strictWrkr
                                                else Expr_Force @expr.strictWrkr
  | Arrow
                lhs         .   strictArgs  =   @arg.isStrict : @res.strictArgs

{
annTrace :: String -> Expr -> Expr
annTrace s e = Expr_Ann (ExprAnn_GrinHint s) e

hasStrictAnn :: Maybe HsName -> Map.Map HsName ExprAnn -> Bool
hasStrictAnn mbNm anns = isStrictAnn (mbNm >>= \l -> Map.lookup l anns)

isStrictAnn :: Maybe ExprAnn -> Bool
isStrictAnn = (== Just (ExprAnn_Strictness Strict))

singletonSeq :: Expr -> Expr
singletonSeq e = Expr_Seq [ExprSeq1_L0Val e Nothing]

seqToList :: Expr -> [Expr]
seqToList (Expr_Seq [ExprSeq1_L0Val e _]) = [e]
seqToList e                               = [e]

headSeq :: Expr -> Expr
headSeq = head . seqToList

paramName :: Expr -> HsName
paramName (Expr_Seq [ExprSeq1_L0Bind n Nothing e]) = n
paramName e = error $ "OptimizeStrictness.paramName: not a valid bind (" ++ show e ++ ")"


paramAnn :: Expr -> Maybe ExprAnn
paramAnn (Expr_Seq [ExprSeq1_L0Bind x Nothing (Expr_Lazy (Expr_Seq [ExprSeq1_L0Val e Nothing]))]) = exprAnn (headSeq e)
paramAnn (Expr_Seq [ExprSeq1_L0Bind _ Nothing e]) = exprAnn (headSeq e)
paramAnn _                                        = Nothing

exprAnn :: Expr -> Maybe ExprAnn
exprAnn (Expr_Ann a _) = Just a
exprAnn _              = Nothing

unAnn :: Expr -> Expr
unAnn (Expr_Seq [ExprSeq1_L0Val (Expr_Ann _ e) m]) = Expr_Seq [ExprSeq1_L0Val e m]
unAnn (Expr_Ann _ e)                               = e
unAnn e                                            = e
}


%%]

