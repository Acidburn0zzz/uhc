%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimize TyCore based on strictness annotations
%%%
%%% Note, this transformation:
%%%  - Requires explicit Lazy/Delay/Force constructs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.OptimizeStrictness2of2}
%%]

%%[(8 codegen) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Control.Applicative)
%%]

%%[(8 codegen) hs import(Data.Bool.Extras, Data.Maybe, Data.Monoid, Data.List)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/Trf/ConstructTypeEnvironment})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfOptimizeStrictness2of2 hs
cmodTrfOptimizeStrictness2of2 :: Module -> Module
cmodTrfOptimizeStrictness2of2 tcmod
  = let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
    in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf    : SELF
    wrapper : SELF
  ]
ATTR AllExpr
  [ newParams   : {Map.Map HsName (Maybe ValBind, [ExprSeq1])}
  |
  |
  ]
ATTR Expr
  [
  |
  |
    mbVarNm    USE {<|>} {Nothing} : {Maybe HsName}
    appArgs    USE {++}  {[]}      : {[Expr]}
    wrapperArgs                    : {[Expr]}
  ]
ATTR AllExprBase
  [
    workWrapL   : {Seq WorkWrap}
    workWrap    : {WorkWrap}
    bindType    : {BindType}
    lamArgsL    : {Seq [[Expr]]}
    lamArgs     : {[[Expr]]}
    workerNmL   : {Seq HsName}
    workerNm    : {HsName}
  |
  |
    workWrap    USE {|||}       {Ignored}   : {WorkWrap}
    workWrapL   USE {`mappend`} {mempty}    : {Seq WorkWrap}
    lamArgsL    USE {`mappend`} {mempty}    : {Seq [[Expr]]}
    lamArgs                                 : {[[Expr]]}
    wrapperL    USE {`mappend`} {mempty}    : {[Expr]}
    workerNmL   USE {`mappend`} {mempty}    : {Seq HsName}
  ]


-- Worker/Wrapper
SEM ExprSeq1L
  | Cons
                lhs         .   cTrf        =   if @lhs.bindType == NoBind
                                                then @cTrf
                                                else case head @lhs.workWrapL of
                                                       UpdatedWrapper -> @hd.wrapper : @tl.cTrf
                                                       _              -> @hd.cTrf    : @tl.cTrf
                            .   workWrapL   =   @hd.workWrap : @tl.workWrapL
                hd
                            .   workWrap    =   head @lhs.workWrapL
                            .   workerNm    =   head @lhs.workerNmL
                            .   bindType    =   NoBind
                tl
                            .   workWrapL   =   tail @lhs.workWrapL
                            .   workerNmL   =   tail @lhs.workerNmL

SEM ExprSeq1
  | L0Val
                l0          .   newParams   =   strictParams @l0.wrapperArgs
  | L0Bind L1Bind L2Bind
                lhs         .   workerNmL   =   [@workerNm]
                loc         .   workWrap    =   case (@isWorker, @isWrapper) of
                                                  (False, True) -> UpdatedWrapper
                                                  (_,     _)    -> Ignored
                            .   workerNm    =   hsnFromString (show @nm ++ "_worker")
                            .   isWorker    =   "_worker" `isSuffixOf` show @nm
                            .   isWrapper   =   hsnFromString (show @nm ++ "_worker") `Map.member` @lhs.tyEnv
                            .   hasWorker   =   any (\x -> length x > 1) @lhs.lamArgs


SEM ValBind
  | Val
                bind        .   bindType    =   NameTypeBind
                            .   lamArgsL    =   @lamArgsL
                            .   workWrapL   =   @bind.workWrapL
                            --  Dummy data
                            .   lamArgs     =   []

                l0          .   bindType    =   BodyBind
                            .   lamArgsL    =   @lamArgsL
                            .   workWrapL   =   @bind.workWrapL
                            .   workerNmL   =   @bind.workerNmL

                bindMeta    .   bindType    =   NoBind
                loc         .   lamArgsL    =   @l0.lamArgsL ++ repeat [] -- example: let [x, y] = dup [3]

SEM Expr
  | Let
                lhs         .   lamArgs     =   [] : @body.lamArgs
  | Lam
                lhs         .   lamArgs     =   list [[@arg.cTrf]] (\xs xss -> (@arg.cTrf : xs) : xss) @res.lamArgs
                lhs         .   wrapperArgs =   @arg.copy : @res.wrapperArgs
  | * - Lam Let
                lhs         .   lamArgs     =   []
                lhs         .   wrapperArgs =   []

SEM Expr
  | App
                lhs         .   wrapper     =   if @func.mbVarNm == Just @lhs.workerNm
                                                then updatedWrapperApp @lhs.workerNm @appArgs @lhs.newParams
                                                else @wrapper
                loc         .   appArgs     =   @func.appArgs ++ [@arg.copy]
  | Var
                lhs         .   mbVarNm     =   Just @nm

  -- Code below not correct, removes annotations that shouldn't have
  | Ann
                lhs         .   wrapper     =   if @ann.cTrf == ExprAnn_Strictness Strict
                                                then @expr.wrapper
                                                else @wrapper

{
-- This function will be in list-extras:Data.List.Extras
list :: b -> (a -> [a] -> b) -> [a] -> b
list b _ []     = b
list _ f (x:xs) = f x xs

strictParams :: [Expr] -> Map.Map HsName (Maybe ValBind, [ExprSeq1])
strictParams args = Map.unions $ map (Map.unions . map argNms . unSeqs) args
  where
    argNms (ExprSeq1_L0Bind nm m e) = argNms' (flip ExprSeq1_L0Bind m) (flip ExprSeq1_L0Val m) nm e
    argNms (ExprSeq1_L1Bind nm e)   = argNms' ExprSeq1_L1Bind ExprSeq1_L1Val nm e
    argNms (ExprSeq1_L2Bind nm e)   = argNms' ExprSeq1_L2Bind ExprSeq1_L2Val nm e
    argNms _                        = Map.empty

    argNms' eb ev nm e = case (argElem e) of
                        (b, [e']) -> Map.singleton nm $ ( if b then Just $ ValBind_Val (Expr_Seq [eb (mkHNm (show nm ++ "_e")) e']) Nothing 0 (Expr_Force $ Expr_Var nm) else Nothing
                                                        , [ev (Expr_Var $ if b then mkHNm (show nm ++ "_e") else nm)])
                        (b, es')  -> Map.singleton nm $ ( if b then Just $ ValBind_Val (Expr_Seq $ zipWith (\x e' -> eb (mkHNm $ show nm ++ "_" ++ show x) e') [0..] es') Nothing 0 (Expr_Force $ Expr_Var nm) else Nothing
                                                        , zipWith (\x _ -> ev (Expr_Var $ if b then mkHNm (show nm ++ "_" ++ show x) else nm)) [0..] es')

    argElem (Expr_Lazy (Expr_Seq es))
      | all (ExprAnn_Strictness Strict `elem`) (map annsSeq1 es) = (True, map (unStrict . exprSeq1ToExpr) es)
    argElem (Expr_Lazy e)
      | ExprAnn_Strictness Strict `elem` anns e                  = let (_, x) = argElem e in (True, x)
    argElem (Expr_Ann (ExprAnn_Strictness Strict) e)             = let (_, x) = argElem e in (True, x)
    argElem e = (False, [e])

anns :: Ty -> [ExprAnn]
anns (Expr_Lazy e)  = anns e
anns (Expr_Ann a e) = a : anns e
anns _              = []

annsSeq1 :: ExprSeq1 -> [ExprAnn]
annsSeq1 (ExprSeq1_L0Val e _)    = anns e
annsSeq1 (ExprSeq1_L0LblVal _ e) = anns e
annsSeq1 (ExprSeq1_L0TagVal _ e) = anns e
annsSeq1 (ExprSeq1_L0Bind _ _ e) = anns e
annsSeq1 (ExprSeq1_L1Val e)      = anns e
annsSeq1 (ExprSeq1_L1Bind _ e)   = anns e
annsSeq1 (ExprSeq1_L2Val e)      = anns e
annsSeq1 (ExprSeq1_L2Bind _ e)   = anns e

unStrict :: Expr -> Expr
unStrict (Expr_Seq es)                                       = Expr_Seq $ map (argMap unStrict) es
unStrict (Expr_Lazy (Expr_Seq es))
  | all (ExprAnn_Strictness Strict `elem`) (map annsSeq1 es) = Expr_Seq $ map (argMap unStrict) es
unStrict (Expr_Lazy e)
  | ExprAnn_Strictness Strict `elem` anns e                  = unStrict e
unStrict (Expr_Ann (ExprAnn_Strictness Strict) e)            = unStrict e
unStrict e                                                   = e

argMap :: (Expr -> Expr) -> ExprSeq1 -> ExprSeq1
argMap f (ExprSeq1_L0Val e m)     = ExprSeq1_L0Val (f e) m
argMap f (ExprSeq1_L0LblVal nm e) = ExprSeq1_L0LblVal nm (f e)
argMap f (ExprSeq1_L0TagVal t e)  = ExprSeq1_L0TagVal t (f e)
argMap f (ExprSeq1_L0Bind nm m e) = ExprSeq1_L0Bind nm m (f e)
argMap f (ExprSeq1_L1Val e)       = ExprSeq1_L1Val (f e)
argMap f (ExprSeq1_L1Bind nm e)   = ExprSeq1_L1Bind nm (f e)
argMap f (ExprSeq1_L2Val e)       = ExprSeq1_L2Val (f e)
argMap f (ExprSeq1_L2Bind nm e)   = ExprSeq1_L2Bind nm (f e)

updatedWrapperApp :: HsName -> [Expr] -> Map.Map HsName (Maybe ValBind, [ExprSeq1]) -> Expr
updatedWrapperApp nm args pmEnv = Expr_Let ValBindCateg_Plain (concatMap (concatMap bnd . unSeqs) args) $ foldl Expr_App (Expr_Var nm) (map (Expr_Seq . concatMap arg . unSeqs) args)
  where
    bnd (ExprSeq1_L0Val (Expr_Delay (Expr_Force (Expr_Var nm))) _) = bnd' nm
    bnd (ExprSeq1_L0Val (Expr_Force (Expr_Var nm)) _)              = bnd' nm
    bnd (ExprSeq1_L0Val (Expr_Var nm) _)                           = bnd' nm

    bnd' nm = maybeToList $ fst $ fromJust $ Map.lookup nm pmEnv

    arg (ExprSeq1_L0Val (Expr_Delay (Expr_Force (Expr_Var nm))) _) = arg' nm
    arg (ExprSeq1_L0Val (Expr_Force (Expr_Var nm)) _)              = arg' nm
    arg (ExprSeq1_L0Val (Expr_Var nm) _)                           = arg' nm

    arg' nm = snd $ fromJust $ Map.lookup nm pmEnv
}
%%]

