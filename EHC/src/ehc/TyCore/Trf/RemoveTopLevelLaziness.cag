%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Remove top-level lazy bound lambdas
%%% 
%%% Perhaps beter to never generate them in the first place, but this is easier for now.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.RemoveTopLevelLaziness}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras)
%%]

%%[(8 codegen) hs import(Data.Maybe)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/AbsSyn})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfRemoveTopLevelLaziness hs
cmodTrfRemoveTopLevelLaziness :: Module -> Module
cmodTrfRemoveTopLevelLaziness tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf : SELF ]
ATTR AllExpr
  [ tlDelay : {Bool}
    rmLaziness : {Bool}
    rmForceVars : {[HsName]}
  |
  |
    rmLaziness : {Bool}
    strictVars USE {++} {[]} : {[HsName]}
  ]
ATTR Expr
  [
  |
  | isLam : {Bool}
    isVar : {Maybe HsName}
  ]

SEM Module
  | Mod
                tbinds      .   tlDelay     =   True
                            .   rmLaziness  =   False
                            .   rmForceVars =   []
                vbinds      .   tlDelay     =   True
                            .   rmForceVars =   @vbinds.strictVars

SEM ValBind
  | Val
                l1          .   rmLaziness  =   @l0.rmLaziness
                lhs         .   strictVars  =   bool [] [@nm] @l0.rmLaziness


SEM Expr
  | Delay
                lhs         .   rmLaziness  =   @rmLaziness
                lhs         .   cTrf        =   if @rmLaziness
                                                then @expr.cTrf
                                                else @original
                loc         .   original    =   Expr_Delay @expr.cTrf
                loc         .   rmLaziness  =   @lhs.tlDelay && @expr.isLam
                expr        .   tlDelay     =   False
                expr        .   rmLaziness  =   False

  | Force
                lhs         .   cTrf        =   maybe @original
                                                      (\n -> bool @original
                                                                  @expr.cTrf
                                                                  (elem n @lhs.rmForceVars))
                                                      @expr.isVar
                loc         .   original    =   Expr_Force @expr.cTrf

  | Lazy
                lhs         .   cTrf        =   if @lhs.rmLaziness
                                                then @expr.cTrf
                                                else @original
                loc         .   original    =   Expr_Lazy @expr.cTrf
                expr        .   rmLaziness  =   False

%%]
Module_Mod Test []
[ValBind_Val id Nothing 0
  (Expr_Arrow
     (Expr_Seq [])
     (Expr_Arrow
       (Expr_Seq [ExprSeq1_L0Val (Expr_Arrow (Expr_Seq []) (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing])) Nothing])
       (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing])))
  (Expr_Lam (Expr_Seq []) (Expr_Lam (Expr_Seq [ExprSeq1_L0Bind x Nothing (Expr_Arrow (Expr_Seq []) (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing]))]) (Expr_App (Expr_Var x) (Expr_Seq []))))
,ValBind_Val main Nothing 0
  (Expr_Arrow (Expr_Seq []) (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing]))
  (Expr_Lam (Expr_Seq []) (Expr_Int 3 (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing])))]

  id
    :: Expr_Arrow
        (Expr_Seq [ExprSeq1_L0Val (Expr_Delay (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing])) Nothing])
        (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing]))
    = Expr_Delay
       (Expr_Lam (Expr_Seq [ExprSeq1_L0Bind x Nothing (Expr_Delay (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing]))]) (Expr_Force (Expr_Var x)))
  main
    :: Expr_Delay (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing])
    = Expr_Delay (Expr_Int 3 (Expr_Seq [ExprSeq1_L0Val (Expr_Var Int) Nothing]))
%%[(8 codegen)

SEM Expr
  | Lam
                lhs         .   isLam       =   True
  | * - Lam
                lhs         .   isLam       =   False
  | Var
                lhs         .   isVar       =   Just @nm
  | * - Var
                lhs         .   isVar       =   Nothing

{
annTrace :: String -> Expr -> Expr
annTrace s e = Expr_Ann (ExprAnn_GrinHint s) e
}
%%]

