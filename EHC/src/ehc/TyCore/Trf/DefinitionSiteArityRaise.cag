%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Definition-site arity raising in TyCore
%%%
%%% To keep sharing when doing partial applications, this will only raise nested lambdas.
%%%
%%% For example:
%%% > \[x] -> \[y] -> let g = f x y
%%% >                 in \[z] -> g z
%%%
%%% Becomes:
%%% > \[x, y] -> let g = f x y
%%% >            in \[z] -> g z
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.DefinitionSiteArityRaise}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras)
%%]

%%[(8 codegen) hs import(Data.Maybe)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/AbsSyn})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfDefinitionSiteArityRaise hs
cmodTrfDefinitionSiteArityRaise :: Module -> Module
cmodTrfDefinitionSiteArityRaise tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf : SELF
    worker : SELF
    wrapper : SELF
  ]
ATTR AllExpr
  [
  |
  | hasWorker USE {||} {False} : {Bool}
  ]
ATTR Expr
  [
  |
  |
    lamArgs  : {[Expr]}
    lamTails : {[Expr]}
    arrArgs  : {[Expr]}
    arrTails : {[Expr]}
  ]

SEM ValBindL
  | Cons        lhs         .   cTrf        =   if @hd.hasWorker
                                                then @hd.worker : @hd.wrapper : @tl.cTrf
                                                else @hd.cTrf : @tl.cTrf

-- Worker
SEM ValBind
  | Val
                lhs         .   hasWorker   =   isJust @newLamTail
                lhs         .   worker      =   ValBind_Val @workerNm @bindMeta.cTrf @mlev @newArr @newLam
                loc         .   newLam      =   maybe @l0.cTrf
                                                      (\e -> Expr_Lam (Expr_Seq @newLamSeq) e)
                                                      @newLamTail
                loc         .   newArr      =   maybe @l1.cTrf
                                                      (\e -> Expr_Arrow (Expr_Seq @newArrSeq) e)
                                                      @newArrTail
                loc         .   newLamSeq   =   concatMap seqToList @l0.lamArgs
                            .   newLamTail  =   if @nrArgs > 1
                                                then Just $ @l0.lamTails !! (@nrArgs - 1)
                                                else Nothing
                            .   newArrSeq   =   take (@nrArgs) $ concatMap seqToList @l1.arrArgs
                            .   newArrTail  =   if @nrArgs > 1
                                                then Just $ @l1.arrTails !! (@nrArgs - 1)
                                                else Nothing
                            .   nrArgs      =   length @loc.newLamSeq
                            .   workerNm    =   hsnFromString (show @nm ++ "_worker")

-- Wrapper
SEM ValBind
  | Val
                lhs         .   wrapper     =   ValBind_Val @nm @bindMeta.cTrf @mlev @l1.cTrf @wrapLambdas
                loc         .   wrapLambdas =   foldr Expr_Lam (@wrapBody) @l0.lamArgs
                            .   wrapBody    =   foldl Expr_App (Expr_Var @workerNm `Expr_App` @fstSeq) @sndSeq
                            .   fstSeq      =   Expr_Seq . mkTySeqVals . map (mkExprThunk . mkExprUnThunk . Expr_Var)
                                                  $ take @nrArgs @varNms
                            .   sndSeq      =   map (Expr_Seq . mkTySeqVals . return . mkExprThunk . mkExprUnThunk . Expr_Var)
                                                  $ drop @nrArgs @varNms
                            .   varNms      =   mapMaybe bindNm @newLamSeq

-- Collect lambda args and bodies
SEM Expr
  | Lam
                lhs         .   lamArgs     =   @arg.cTrf : @res.lamArgs
                            .   lamTails    =   @res.cTrf : @res.lamTails
  | Arrow
                lhs         .   arrArgs     =   @arg.cTrf : @res.arrArgs
                            .   arrTails    =   @res.cTrf : @res.arrTails
  | * - Lam Arrow
                lhs         .   lamArgs     =   []
                            .   lamTails    =   []
                            .   arrArgs     =   []
                            .   arrTails    =   []

{
bindNm :: ExprSeq1 -> Maybe HsName
bindNm (ExprSeq1_L0Bind nm _ _) = Just nm
bindNm _                        = Nothing

seqToList :: Expr -> [ExprSeq1]
seqToList (Expr_Seq es) = es
seqToList e             = error $ "DefinitionSiteArityRaise.seqToList: Expr '"
                                    ++ show e ++ "' not a Expr_Seq."
}
%%]

