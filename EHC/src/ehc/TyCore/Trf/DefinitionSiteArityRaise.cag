%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Definition-site arity raising in TyCore
%%%
%%% To keep sharing when doing partial applications, this will only raise nested lambdas.
%%%
%%% For example:
%%% > \[a] -> \[b] -> let g = f a b
%%% >                 in \[c] -> [d] -> g c
%%%
%%% Becomes:
%%% > \[a, b] -> let g = f a b
%%% >            in \[c, d] -> g c
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.DefinitionSiteArityRaise}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras, Data.Maybe, Data.List)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/Trf/ConstructTypeEnvironment})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfDefinitionSiteArityRaise hs
cmodTrfDefinitionSiteArityRaise :: Module -> Module
cmodTrfDefinitionSiteArityRaise tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf    : SELF
    worker  : SELF
    wrapper : SELF
  ]
ATTR AllExpr
  [
  |
  | hasWorker USE {||}  {False}   : {Bool}
    workWrap  USE {|||} {Ignored} : {WorkWrap}
    arrTail                       : SELF
  ]
ATTR Expr
  [
  |
  |
    workerArgs : {[Expr]}
    lamArgs    : {[[Expr]]}
    arrArgs    : {[Expr]}
  ]

SEM ValBindL
  | Cons        lhs         .   cTrf        =   case @hd.workWrap of
                                                  Ignored        -> @hd.cTrf    : @tl.cTrf
                                                  Introduced     -> @hd.worker  : @hd.wrapper : @tl.cTrf
                                                  UpdatedWorker  -> @hd.worker  : @tl.cTrf
                                                  UpdatedWrapper -> @hd.wrapper : @tl.cTrf

-- Worker/Wrapper
SEM ValBind
  | Val
                lhs         .   workWrap    =   case (@isWorker, @isWrapper, @hasWorker) of
                                                  (True,  False, True) -> UpdatedWorker
                                                  (False, True,  True) -> UpdatedWrapper
                                                  (False, False, True) -> Introduced
                                                  (_,     _,     _)    -> Ignored
                loc         .   isWorker    =   "_worker" `isSuffixOf` (show @nm)
                            .   isWrapper   =   hsnFromString (show @nm ++ "_worker") `Map.member` @lhs.tyEnv
                            .   hasWorker   =   list False (\x _ -> length x > 1) @l0.lamArgs
                            .   workerNm    =   if @isWorker then @nm else hsnFromString (show @nm ++ "_worker")

-- Worker
SEM ValBind
  | Val
                lhs         .   worker      =   ValBind_Val @workerNm @bindMeta.cTrf @mlev @workerType @workerBody
                loc         .   workerType  =   workerType @l0.lamArgs @l1.arrArgs @l1.arrTail
                            .   workerBody  =   workerBody @l0.workerArgs @l0.worker

-- Wrapper
SEM ValBind
  | Val
                lhs         .   wrapper     =   ValBind_Val @nm @bindMeta.cTrf @mlev @l1.cTrf @wrapperBody
                loc         .   wrapperBody =   newWrapperBody @workerNm @l0.lamArgs

-- Collect lambda args and bodies
SEM Expr
  | Let
                lhs         .   lamArgs     =   [] : @body.lamArgs
                            .   worker      =   Expr_Let @categ @vbinds.cTrf (workerBody @body.workerArgs @body.worker)
  | Lam
                lhs         .   workerArgs  =   @arg.copy : @res.workerArgs
                lhs         .   lamArgs     =   list [[@arg.copy]] (\x xs -> (@arg.copy : x) : xs) @res.lamArgs
                            .   worker      =   @res.worker
  | Arrow
                lhs         .   arrArgs     =   @arg.copy : @res.arrArgs
                            .   arrTail     =   @res.arrTail
  | * - Lam Arrow
                lhs         .   workerArgs  =   []
                            .   arrArgs     =   []
  | * - Lam Let
                lhs         .   lamArgs     =   []

{
-- This function will be in list-extras:Data.List.Extras
list :: b -> (a -> [a] -> b) -> [a] -> b
list b _ []     = b
list _ f (x:xs) = f x xs

workerType :: [[Expr]] -> [Expr] -> Expr -> Expr
workerType []     _    res = res
workerType (x:xs) args res = let (args1, args2) = splitAt (length x) args
                             in Expr_Arrow (Expr_Seq $ concatMap unSeqs args1)
                                           (workerType xs args2 res)

workerBody :: [Expr] -> Expr -> Expr
workerBody args body = Expr_Lam (Expr_Seq $ concatMap unSeqs args) body

newWrapperBody :: HsName -> [[Expr]] -> Expr
newWrapperBody nm argss = foldr Expr_Lam body (concat argss)
  where
    body :: Expr
    body = foldl Expr_App (Expr_Var nm) (map arg argss)

    arg :: [Expr] -> Expr
    arg args = Expr_Seq (map argSeq (concatMap unSeqs args))

    argSeq :: ExprSeq1 -> ExprSeq1
    argSeq (ExprSeq1_L0Bind nm _ _) = ExprSeq1_L0Val (Expr_Var nm) Nothing
    argSeq (ExprSeq1_L1Bind nm _)   = ExprSeq1_L1Val (Expr_Var nm)
    argSeq (ExprSeq1_L2Bind nm _)   = ExprSeq1_L2Val (Expr_Var nm)
    argSeq e                        = e
}
%%]

