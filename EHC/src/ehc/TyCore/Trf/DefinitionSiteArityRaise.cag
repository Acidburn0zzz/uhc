%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Definition-site arity raising in TyCore
%%%
%%% To keep sharing when doing partial applications, this will only raise nested lambdas.
%%%
%%% For example:
%%% > \[a] -> \[b] -> let g = f a b
%%% >                 in \[c] -> [d] -> g c
%%%
%%% Becomes:
%%% > \[a, b] -> let g = f a b
%%% >            in \[c, d] -> g c
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.DefinitionSiteArityRaise}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras, Data.Maybe, Data.List)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/Trf/ConstructTypeEnvironment})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfDefinitionSiteArityRaise hs
cmodTrfDefinitionSiteArityRaise :: Module -> Module
cmodTrfDefinitionSiteArityRaise tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t

-- Status of Worker/Wrapper transformation
data WorkWrap
  = Introduced      -- A Worker and Wrapper were introduced
  | UpdatedWorker   -- Worker was updated
  | UpdatedWrapper  -- Wrapper was updated
  | Ignored         -- Nothing was done
  deriving Show

(|||) :: WorkWrap -> WorkWrap -> WorkWrap
x              ||| Ignored        = x
Ignored        ||| y              = y
Introduced     ||| Introduced     = Introduced
UpdatedWorker  ||| UpdatedWorker  = UpdatedWorker
UpdatedWrapper ||| UpdatedWrapper = UpdatedWrapper
_              ||| _              = error "(|||): Can't merge arguments."
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf    : SELF
    worker  : SELF
    wrapper : SELF
  ]
ATTR AllExpr
  [
  |
  | hasWorker USE {||}  {False}   : {Bool}
    workWrap  USE {|||} {Ignored} : {WorkWrap}
    arrTail  : SELF
  ]
ATTR Expr
  [
  |
  |
    workerArgs : {[Expr]}
    nrArgs   : {[Int]}
    lamArgs  : {[[Expr]]}
    arrArgs  : {[Expr]}
    arrTails : {[Expr]}
  ]

SEM ValBindL
  | Cons        lhs         .   cTrf        =   case @hd.workWrap of
                                                  Ignored        -> @hd.cTrf : @tl.cTrf
                                                  Introduced     -> @hd.worker : @hd.wrapper : @tl.cTrf
                                                  UpdatedWorker  -> @hd.worker : @tl.cTrf
                                                  UpdatedWrapper -> @hd.wrapper : @tl.cTrf

-- Worker/Wrapper
SEM ValBind
  | Val
                lhs         .   workWrap    =   case (@isWorker, @isWrapper, @hasWorker) of
                                                  (True,  False, True) -> UpdatedWorker
                                                  (False, True,  True) -> UpdatedWrapper
                                                  (False, False, True) -> Introduced
                                                  (_,     _,     _)    -> Ignored
                loc         .   isWorker    =   "_worker" `isSuffixOf` (show @nm)
                            .   isWrapper   =   hsnFromString (show @nm ++ "_worker") `Map.member` @lhs.tyEnv
                            .   hasWorker   =   list False (\x _ -> length x > 1) @l0.lamArgs
                            .   workerNm    =   hsnFromString (show @nm ++ "_worker")

-- Worker
SEM ValBind
  | Val
                lhs         .   worker      =   ValBind_Val @workerNm @bindMeta.cTrf @mlev @newType @newBody
                loc         .   newType     =   bar @l0.lamArgs @l1.arrArgs @l1.arrTail
                            .   newBody     =   foo @l0.workerArgs @l0.worker

-- Wrapper
SEM ValBind
  | Val
                lhs         .   wrapper     =   ValBind_Val @nm @bindMeta.cTrf @mlev @l1.cTrf @wrapperBody
                loc         .   varNms      =   mapMaybe bindNm $ concatMap seqToList (concat @l0.lamArgs)
                            .   wrapperBody =   foldr Expr_Lam (foldl Expr_App (Expr_Var @workerNm) $ baz @l0.lamArgs @varNms) (concat @l0.lamArgs)

-- Collect lambda args and bodies
SEM Expr
  | Let
                lhs         .   lamArgs     =   [] : @body.lamArgs
                lhs         .   nrArgs      =   0 : @body.nrArgs
                            .   worker      =   Expr_Let @categ @vbinds.cTrf (foo @body.workerArgs @body.worker)
  | Lam
                lhs         .   workerArgs  =   @arg.copy : @res.workerArgs
                lhs         .   lamArgs     =   let (x:xs) = @res.lamArgs
                                                in (@arg.copy : x) : xs
                            .   nrArgs      =   list [1] (\x xs -> x+1:xs) @res.nrArgs
                            .   worker      =   @res.worker
  | Arrow
                lhs         .   arrArgs     =   @arg.copy : @res.arrArgs
                            .   arrTails    =   @res.copy : @res.arrTails
                            .   arrTail     =   @res.arrTail
  | * - Lam Arrow
                lhs         .   workerArgs  =   []
                            .   arrArgs     =   []
                            .   arrTails    =   []
  | * - Lam Let
                lhs         .   lamArgs     =   [[]]
                lhs         .   nrArgs      =   []

{
list :: b -> (a -> [a] -> b) -> [a] -> b
list b _ []     = b
list _ f (x:xs) = f x xs


foo :: [Expr] -> Expr -> Expr
foo args body = Expr_Lam (Expr_Seq $ concatMap seqToList args) body

bar :: [[Expr]] -> [Expr] -> Expr -> Expr
bar []     _    res = res
bar (x:xs) args res = Expr_Arrow (Expr_Seq $ concatMap seqToList (take (length x) args))
                                 (bar xs (drop (length x) args) res)

baz :: [[Expr]] -> [HsName]-> [Expr]
baz []     _    = []
baz (x:xs) nms = Expr_Seq (mkTySeqVals (map Expr_Var (take (length x) nms))) : baz xs (drop (length x) nms)

bindNm :: ExprSeq1 -> Maybe HsName
bindNm (ExprSeq1_L0Bind nm _ _) = Just nm
bindNm (ExprSeq1_L1Bind nm _)   = Just nm
bindNm (ExprSeq1_L2Bind nm _)   = Just nm
bindNm _                        = Nothing

seqToList :: Expr -> [ExprSeq1]
seqToList (Expr_Seq es) = es
seqToList e             = error $ "DefinitionSiteArityRaise.seqToList: Expr '"
                                    ++ show e ++ "' not a Expr_Seq."
}
%%]

