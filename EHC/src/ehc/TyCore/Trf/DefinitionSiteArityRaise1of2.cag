%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Definition-site arity raising in TyCore
%%%
%%% To keep sharing when doing partial applications, this will only raise nested lambdas.
%%%
%%% For example:
%%% > \[a] -> \[b] -> let g = f a b
%%% >                 in \[c] -> [d] -> g c
%%%
%%% Becomes:
%%% > \[a, b] -> let g = f a b
%%% >            in \[c, d] -> g c
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.DefinitionSiteArityRaise1of2}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Control.Applicative)
%%]

%%[(8 codegen) hs import(Data.Bool.Extras, Data.Maybe, Data.Monoid, Data.List)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/Trf/ConstructTypeEnvironment})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfDefinitionSiteArityRaise hs
cmodTrfDefinitionSiteArityRaise1of2 :: Module -> Module
cmodTrfDefinitionSiteArityRaise1of2 tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf        : SELF
  ]
ATTR AllExpr
  [
  |
  |
    arrTail     : SELF
    worker      : SELF
    newWrapper  : SELF
  ]
ATTR Expr
  [
  |
  |
    arrArgs     : {[Expr]}
    workerArgs  : {[Expr]}
  ]
ATTR AllExprBase
  [
    workWrapL   : {[WorkWrap]}
    workWrap    : {WorkWrap}
    bindType    : {BindType}
    lamArgsL    : {Seq [[Expr]]}
    lamArgs     : {[[Expr]]}
    workerNmL   : {Seq HsName}
    workerNm    : {HsName}
  |
  |
    workWrap    USE {|||}       {Ignored}   : {WorkWrap}
    workWrapL   USE {`mappend`} {mempty}    : {Seq WorkWrap}
    lamArgsL    USE {`mappend`} {mempty}    : {Seq [[Expr]]}
    lamArgs                                 : {[[Expr]]}
    workerL     USE {`mappend`} {mempty}    : {[ExprSeq1]}
    newWrapperL USE {`mappend`} {mempty}    : {[Expr]}
    workerNmL   USE {`mappend`} {mempty}    : {Seq HsName}
  ]


-- Worker/Wrapper
SEM ExprSeq1L
  | Cons
                lhs         .   cTrf        =   if @lhs.bindType == NoBind
                                                then @cTrf
                                                else case head @lhs.workWrapL of
                                                       Introduced     -> @hd.worker  : @hd.newWrapper : @tl.cTrf
                                                       UpdatedWorker  -> @hd.worker  : @tl.cTrf
                                                       _              -> @hd.cTrf    : @tl.cTrf
                            .   workWrapL   =   @hd.workWrap : @tl.workWrapL
                            .   lamArgsL    =   @hd.lamArgs : @tl.lamArgsL
                            .   workerL     =   @hd.worker : @tl.workerL
                hd
                            .   workWrap    =   head @lhs.workWrapL
                            .   lamArgs     =   head @lhs.lamArgsL
                            .   bindType    =   NoBind
                            .   workerNm    =   head @lhs.workerNmL
                tl
                            .   lamArgsL    =   tail @lhs.lamArgsL
                            .   workWrapL   =   tail @lhs.workWrapL
                            .   workerNmL   =   tail @lhs.workerNmL

SEM ExprSeq1
  | L0Val
                lhs         .   worker      =   ExprSeq1_L0Val (workerBody @l0.workerArgs @l0.worker) @meta.worker
                lhs         .   newWrapper  =   ExprSeq1_L0Val (newWrapperBody @lhs.workerNm @lhs.lamArgs) @meta.newWrapper
  | L0Bind
                lhs         .   worker      =   ExprSeq1_L0Bind @workerNm Nothing (workerType (map length @lhs.lamArgs) @l1.arrArgs @l1.arrTail)
                lhs         .   newWrapper  =   ExprSeq1_L0Bind @nm @meta.newWrapper (newWrapperType @l1.arrArgs @l1.arrTail)
  | L1Bind
                lhs         .   worker      =   ExprSeq1_L1Bind @workerNm (workerType (map length @lhs.lamArgs) @l2.arrArgs @l2.arrTail)
  | L2Bind
                lhs         .   worker      =   ExprSeq1_L2Bind @workerNm (workerType (map length @lhs.lamArgs) @l3.arrArgs @l3.arrTail)
  | L0Bind L1Bind L2Bind
                lhs         .   workerNmL   =   [@workerNm]
                loc         .   workWrap    =   case (@isWorker, @isWrapper, @hasWorker) of
                                                  (True,  False, True) -> UpdatedWorker
                                                  (False, False, True) -> Introduced
                                                  (_,     _,     _)    -> Ignored
                            .   workerNm    =   hsnFromString (show @nm ++ "_worker")
                            .   isWorker    =   "_worker" `isSuffixOf` show @nm
                            .   isWrapper   =   hsnFromString (show @nm ++ "_worker") `Map.member` @lhs.tyEnv
                            .   hasWorker   =   any (\x -> length x > 1) @lhs.lamArgs


SEM ValBind
  | Val
                bind        .   bindType    =   NameTypeBind
                            .   lamArgsL    =   @lamArgsL
                            .   workWrapL   =   @bind.workWrapL
                            --  Dummy data
                            .   lamArgs     =   []

                l0          .   bindType    =   BodyBind
                            .   lamArgsL    =   @lamArgsL
                            .   workWrapL   =   @bind.workWrapL
                            .   workerNmL   =   @bind.workerNmL

                bindMeta    .   bindType    =   NoBind
                loc         .   lamArgsL    =   @l0.lamArgsL ++ repeat [] -- example: let [x, y] = dup [3]

SEM Expr
  | Let
                lhs         .   lamArgs     =   [] : @body.lamArgs
  | Lam
                lhs         .   lamArgs     =   list (\xs xss -> (@arg.cTrf : xs) : xss) [[@arg.cTrf]] @res.lamArgs
  | * - Lam Let
                lhs         .   lamArgs     =   []


-- Worker
SEM ValBind
  | Val
                loc         .   workerType  =   workerType (map length @l0.lamArgs) [] @bind.copy
                            .   workerBody  =   workerBody @l0.workerArgs @l0.worker

SEM Expr
  | Let
                lhs         .   worker      =   Expr_Let @categ @vbinds.cTrf (workerBody @body.workerArgs @body.worker)
  | Lam
                lhs         .   workerArgs  =   @arg.copy : @res.workerArgs
                            .   worker      =   @res.worker
  | Arrow
                lhs         .   arrArgs     =   @arg.copy : @res.arrArgs
                            .   arrTail     =   @res.arrTail
  | * - Lam Arrow
                lhs         .   workerArgs  =   []
                            .   arrArgs     =   []


{
-- This function will be in list-extras:Data.List.Extras
list :: (a -> [a] -> b) -> b -> [a] -> b
list _ b []     = b
list f _ (x:xs) = f x xs

workerType :: [Int] -> [Expr] -> Expr -> Expr
workerType []     _    res = res
workerType (x:xs) args res = let (args1, args2) = splitAt x args
                             in Expr_Arrow (Expr_Seq $ concatMap unSeqs args1)
                                           (workerType xs args2 res)

workerBody :: [Expr] -> Expr -> Expr
workerBody []   body = body
workerBody args body = Expr_Lam (Expr_Seq $ concatMap unSeqs args) body

newWrapperType :: [Expr] -> Expr -> Expr
newWrapperType args res = foldr Expr_Arrow res args

newWrapperBody :: HsName -> [[Expr]] -> Expr
newWrapperBody nm argss = foldr Expr_Lam body args
  where
    body :: Expr
    body = foldl Expr_App (Expr_Var nm) (map (Expr_Seq . map argSeq . unSeqs) args)

    args :: [Expr]
    args = concat argss

    argSeq :: ExprSeq1 -> ExprSeq1
    argSeq (ExprSeq1_L0Bind nm _ _) = ExprSeq1_L0Val (Expr_Var nm) Nothing
    argSeq (ExprSeq1_L1Bind nm _)   = ExprSeq1_L1Val (Expr_Var nm)
    argSeq (ExprSeq1_L2Bind nm _)   = ExprSeq1_L2Val (Expr_Var nm)
    argSeq e                        = e

}
%%]

