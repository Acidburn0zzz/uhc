%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Definition-site arity raising in TyCore
%%%
%%% To keep sharing when doing partial applications, this will only raise nested lambdas.
%%%
%%% For example:
%%% > \[a] -> \[b] -> let g = f a b
%%% >                 in \[c] -> [d] -> g c
%%%
%%% Becomes:
%%% > \[a, b] -> let g = f a b
%%% >            in \[c, d] -> g c
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}TyCore.Trf.DefinitionSiteArityRaise1of2}
%%]

%%[(8 tauphi) hs import({%{EH}TauPhi.Common})
%%]
 
%%[(8 codegen) hs import({%{EH}Base.Builtin},{%{EH}Base.Opts},{%{EH}Base.Common})
%%]

%%[(8 codegen) hs import(Data.Bool.Extras, Data.Maybe, Data.List)
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}TyCore})
%%]

%%[1 hs import(Debug.Trace)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({TyCore/Trf/ConstructTypeEnvironment})
WRAPPER AGItf
%%]

%%[(8 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).tcmodTrfDefinitionSiteArityRaise hs
cmodTrfDefinitionSiteArityRaise1of2 :: Module -> Module
cmodTrfDefinitionSiteArityRaise1of2 tcmod
  =  let  t = wrap_AGItf (sem_AGItf (AGItf_AGItf tcmod)) Inh_AGItf
     in   cTrf_Syn_AGItf t

data BindType = NameTypeBind | BodyBind | NoBind
  deriving (Eq, Show)
%%]

%%[(8 codegen)
ATTR AGItf [ | | cTrf : Module ]

SEM AGItf
  | AGItf       lhs         .   cTrf        =   @module.cTrf
%%]

%%[(8 codegen)
ATTR AllCodeNT
  [
  |
  | cTrf    : SELF
  ]
ATTR AllExpr
  [
  |
  | workWrap      USE {|||} {Ignored}           : {WorkWrap}
    arrTail                                     : SELF
    worker  : SELF
  ]
-- ATTR AllExprBase
--   [
--   |
--   |
--     workers   USE {++} {[]} : {[Expr]}
--   ]
ATTR Expr
  [
    bindType : {BindType}
  |
  |
    workerArgs : {[Expr]}
    lamArgs    : {[[Expr]]}
    nrArgs     : {[Int]}
    arrArgs    : {[Expr]}
  ]
ATTR AllExprSeq1
  [
  |
  |
    bindNms  USE {++} {[]} : {[HsName]}
    --workWraps   USE {++} {[]}   : {[WorkWrap]}
  ]

-- SEM ValBindL
--   | Cons        lhs         .   cTrf        =   case @hd.workWrap of
--                                                   Introduced     -> @hd.worker  : @hd.cTrf : @tl.cTrf
--                                                   UpdatedWorker  -> @hd.worker  : @tl.cTrf
--                                                   _              -> @hd.cTrf    : @tl.cTrf

SEM ExprSeq1L
  | Cons
                -- lhs         .   workers     =   @hd.worker : @tl.workers

SEM ExprSeq1
  | L0Val
                lhs         .   worker      =   ExprSeq1_L0Val (workerBody @l0.workerArgs @l0.worker) @meta.worker
  | L0Bind      lhs         .   workWraps   =   []
                            .   bindNms     =   [@nm]
  | L1Bind
                lhs         .   bindNms     =   [@nm]
  | L2Bind
                lhs         .   bindNms     =   [@nm]
                          --  .   isWorker    =   "_worker" `isSuffixOf` (show @nm)
                          --  .   isWrapper   =   hsnFromString (show @nm ++ "_worker") `Map.member` @lhs.tyEnv

-- Worker/Wrapper
SEM ValBind
  | Val
                loc         .   workWrap    =   case (@isWorker, @isWrapper, @hasWorker) of
                                                  (True,  False, True) -> UpdatedWorker
                                                  (False, False, True) -> Introduced
                                                  (_,     _,     _)    -> Ignored
                            .   hasWorker   =   list False (const . (> 1)) @l0.nrArgs
                            .   isWorker    =   "_worker" `isSuffixOf` (show @nm)
                            .   isWrapper   =   hsnFromString (show @nm ++ "_worker") `Map.member` @lhs.tyEnv
                            .   workerNm    =   if @isWorker then @nm else hsnFromString (show @nm ++ "_worker")
                            .   nm          =   hsnFromString "nothing"
                            .   areWorkers  =   unSeqs @bind.cTrf
                bind        .   bindType    =   NameTypeBind
                l0          .   bindType    =   BodyBind

SEM Expr
  | Seq         lhs         .   cTrf        =   (if @lhs.bindType == NameTypeBind then trace (show @seq.bindNms) else id ) @copy
  | Let
                lhs         .   lamArgs     =   [] : @body.lamArgs
                lhs         .   nrArgs      =   0 : @body.nrArgs
  | Lam
                lhs         .   lamArgs     =   list [[@arg.copy]] (\x xs -> (@arg.copy : x) : xs) @res.lamArgs
                lhs         .   nrArgs      =   list [1] (\x xs -> (x + 1) : xs) @res.nrArgs
  | * - Lam Let
                lhs         .   lamArgs     =   []
                lhs         .   nrArgs      =   []


-- Worker
SEM ValBind
  | Val
--                lhs         .   worker      =   @copy -- ValBind_Val @workerNm @bindMeta.cTrf @mlev @workerType @workerBody
                loc         .   workerType  =   workerType @l0.nrArgs [] @bind.copy -- @l1.arrArgs @l1.arrTail
                            .   workerBody  =   workerBody @l0.workerArgs @l0.worker

SEM Expr
  | Let
                lhs         .   worker      =   Expr_Let @categ @vbinds.cTrf (workerBody @body.workerArgs @body.worker)
  | Lam
                lhs         .   workerArgs  =   @arg.copy : @res.workerArgs
                            .   worker      =   @res.worker
  | Arrow
                lhs         .   arrArgs     =   @arg.copy : @res.arrArgs
                            .   arrTail     =   @res.arrTail
  | * - Lam Arrow
                lhs         .   workerArgs  =   []
                            .   arrArgs     =   []

{
-- This function will be in list-extras:Data.List.Extras
list :: b -> (a -> [a] -> b) -> [a] -> b
list b _ []     = b
list _ f (x:xs) = f x xs

workerType :: [Int] -> [Expr] -> Expr -> Expr
workerType []     _    res = res
workerType (x:xs) args res = let (args1, args2) = splitAt x args
                             in Expr_Arrow (Expr_Seq $ concatMap unSeqs args1)
                                           (workerType xs args2 res)

workerBody :: [Expr] -> Expr -> Expr
workerBody args body = Expr_Lam (Expr_Seq $ concatMap unSeqs args) body
}
%%]

