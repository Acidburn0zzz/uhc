%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Translate Cmm to JavaScript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen cmm javascript) hs module {%{EH}Cmm.ToJavaScript}
%%]

%%[(8 codegen cmm javascript) hs import({%{EH}Base.Builtin},{%{EH}Cmm},{%{EH}Base.Common} hiding (Range),{%{EH}Opts},qualified {%{EH}Config} as Cfg)
%%]

%%[(8 codegen cmm javascript) hs import({%{EH}Error})
%%]

%%[(8 codegen cmm javascript) hs import(qualified {%{EH}JavaScript} as JS)
%%]

%%[(88 codegen cmm javascript) hs import(UHC.Util.Pretty,{%{EH}Base.GenC})
%%]

%%[(8 codegen grin) hs import({%{EH}CodeGen.ValAccess} as VA)
%%]

%%[(8 codegen cmm javascript) hs import(Data.Maybe,Data.Char, UHC.Util.Utils, qualified Data.Map as Map, UHC.Util.FastSeq as Seq)
%%]
%%[(8 codegen cmm javascript) hs import(qualified Data.Bits as B (Bits), Data.Bits as B hiding (Bits))
%%]

%%[(8 codegen cmm javascript) import({Cmm/AbsSyn})
%%]

%%[(8 codegen cmm javascript).cmmMod2JavaScript hs export(cmmMod2JavaScript)
cmmMod2JavaScript :: EHCOpts -> Module -> (JS.JavaScriptModule, [Err])
cmmMod2JavaScript opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf {opts_Inh_AGItf = opts}
                       )
    in  (jsMod_Syn_AGItf t, [])
%%]

%%[(8 codegen cmm javascript)
WRAPPER AGItf
%%]
PRAGMA nocycle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% General info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Options

%%[(8 codegen cmm javascript)
ATTR AGItf AllNT [ opts: EHCOpts | | ]
%%]

Prefixing of global names ?? Or to be done outside

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen cmm javascript) hs
type JsTopStats = Seq.Seq JS.Stat
type JsBodyStats = Seq.Seq JS.Stat

(&) = Seq.union
{-# INLINE (&) #-}

s = Seq.singleton
{-# INLINE s #-}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of JavaScript
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen cmm javascript)
ATTR AGItf Module [ | | jsMod: {JS.JavaScriptModule} ]

SEM Module
  | Mod					lhs			.	jsMod	=	JS.JavaScriptModule_Mod (Seq.toList @decls.jsTopStats) [] []
%%]

Top level

%%[(8 codegen cmm javascript)
ATTR AllTopLevel Proc [ | | jsTopStats USE {&} {Seq.empty}: JsTopStats ]

SEM Proc
  | Proc				lhs			.	jsTopStats	=	s $ JS.Stat_FunDecl $ JS.Expr_Fun (Just @nm) @formals.nmL (JS.Stat_Block $ Seq.toList @body.jsBodyStats)

%%]

Body, Expr level

%%[(8 codegen cmm javascript)
ATTR AllBody [ | | jsBodyStats USE {&} {Seq.empty}: JsBodyStats ]
%%]

%%[(88 codegen cmm javascript)
SEM Decl
  | Const				lhs			.	c		=	gencUpdAssign "" (@ty.c >#< @nm) @expr.c
  | ConstArray			lhs			.	c		=	gencUpdAssign "" (@ty.c >#< @nm >|< "[]") (ppCurlysCommasBlock @exprs.lc)
  | Typedef				lhs			.	c		=	vlist $ map (\n -> gencTypeDecl n @ty.c) @nms
  -- | Regs
  -- | Target
  | Comment				lhs			.	c		=	gencCmt @str

SEM Proc
  | Proc				lhs			.	c		=	gencFunDef "void" @nm @formals.lc @body.lc

SEM Body
  | Body				lhs			.	c		=	ppCurlysBlock @decls.lc

SEM Formal
  | Formal				lhs			.	c		=	gencFunDefArg @ty.c @nm

SEM Import
  | Imp	ImpAs			lhs			.	c		=	gencInclude' "h" @nm

SEM Export
  | Exp	ExpAs			lhs			.	c		=	gencEndsemic $ gencExtern $ @ty.c >#< @nm
%%]

Top level global data

%%[(88 codegen cmm javascript)
SEM Datum
  -- | Nm
  -- | Align
  -- | Ty					lhs			.	c		=	gencUpdAssign (@ty.c 

SEM Init
  | Seq					lhs			.	c		=	gencArray @exprs.lc
  | Str					lhs			.	c		=	gencStr @str
  -- | Str16
%%]

Statement

%%[(88 codegen cmm javascript)
SEM BodyDecl
  -- | StackDecl

SEM Stmt
  | If                  lhs         .   c       =   "if" >#< ppParens @condExpr.c
                                                    >-< indent 2 @thenBody.c
                                                    >-< maybe empty (\c -> "else" >-< indent 2 c) @elseMbBody.mbc
  | Switch				lhs			.	c		=	gencSwitch @expr.c @arms.lc empty
  | Assign				lhs			.	c		=	vlist $ zipWith (\l r -> gencUpdAssign "" l r) @lval.lc @rhs.lc	-- TBD: parallel update ignored, assume given order is ok
  -- | Call
  -- | Jump
  -- | Ret
  | Label				lhs			.	c		=	gencLabel @nm
  -- | Cont
  -- | Goto
  -- | Cut

SEM LValue
  | Nm					lhs			.	c		=	pp @nm
  -- | Typed
%%]

Expression

%%[(8 codegen cmm javascript)
ATTR Expr Lit [ | | jsExpr: {JS.Expr} ]

SEM Expr
  | Int					lhs         .   jsExpr	=   JS.Expr_Int @val
  | Char				lhs         .   jsExpr	=   JS.Expr_Char @val
  | Str					lhs         .   jsExpr	=   JS.Expr_Str @val
  | Nm					lhs         .   jsExpr	=   JS.Expr_Var @nm
  | Op					lhs			.	jsExpr	=	@op.mkExpr @exprs.jsExprL
  | NdFldGet			lhs			.	jsExpr	=	JS.Expr_ObjFld @expr.jsExpr (fldNm @fld)
  | Nd					lhs			.	jsExpr	=	JS.Expr_Obj @elts.nmExprL

  -- TBD
  | * - Int Char Str Nm Op NdFldGet Nd
  						lhs			.	jsExpr	=	JS.Expr_Var hsnUnknown

SEM Lit
  | MInf				lhs			.	jsExpr	=	JS.Expr_Int $ negate (1 `shiftL` @sz)
  | PInf				lhs			.	jsExpr	=	JS.Expr_Int $ (1 `shiftL` @sz) - 1
  | MZero				lhs			.	jsExpr	=	JS.Expr_Int 0
  | PZero				lhs			.	jsExpr	=	JS.Expr_Int 0
  | True				lhs			.	jsExpr	=	JS.Expr_True
  | False				lhs			.	jsExpr	=	JS.Expr_False
%%]

DATA Expr
  | Round			val				: Round
  | Rat				nom				: Integer
  					denom			: Integer
  					mbTy			: MbTy
  | Float			val				: Double
  					mbTy			: MbTy
  | Typed			ty				: Ty
  					expr			: Expr
  					mbAssert		: MbAssert
  | Op				op				: Op
  					exprs			: ExprL


%%[(88 codegen cmm javascript)
SEM Expr
  | Int                 lhs         .   c       =   gencInt @mbTy.mbc (>|< "L") (show @val)
  -- | Lit
  -- | Round
  -- | Rat
  -- | Float
  -- | Char
  | Nm					lhs			.	c		=	pp @nm
  -- | Typed
  | Op					lhs			.	c		=	@op.lcmk @exprs.lc
%%]

Type

%%[(88 codegen cmm javascript)
SEM Ty
  -- | Bits
  | Nm					lhs			.	c		=	pp @nm
  -- | Struct
  -- | Ptr					lhs			.	c		=	ppParens $ @ty.c >|< "*"
%%]

Operator

%%[(8 codegen cmm javascript)
ATTR AllOp [ | | mkExpr: {[JS.Expr] -> JS.Expr} ]

SEM OpCode
  -- comparisons
  | Eq					lhs			.	mkExpr	=	JS.op "=="
  
  -- TBD
  | * - Eq				lhs			.	mkExpr	=	const JS.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% List/Maybe of ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

List

%%[(8 codegen cmm javascript)
ATTR AllFormal [ | | nmL USE {++} {[]}: {[HsName]} ]

SEM Formal
  | Formal				lhs			.	nmL		=	[@nm]

ATTR ExprL [ | | jsExprL USE {++} {[]}: {[JS.Expr]} ]

SEM ExprL
  | Cons				lhs			.	jsExprL	=	@hd.jsExpr : @tl.jsExprL

ATTR AllFldExpr [ | | nmExprL USE {++} {[]}: {JS.NmExprL} ]

SEM FldExpr
  | Tuple				lhs			.	nmExprL	=	[(fldNm @x1, @x2.jsExpr)]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of C: Maybe, List forms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Maybe

%%[(88 codegen cmm javascript)
ATTR MbBody MbTy [ | | mbc: {Maybe GenC} ]

SEM MbBody MbTy
  | Just				lhs			.	mbc		=	Just @just.c
  | Nothing				lhs			.	mbc		=	Nothing
%%]

List

%%[(88 codegen cmm javascript)
ATTR
  ArmL Arm
  RangeL Range
  ExprL
  LValueL
  FormalL
  BodyDeclL Body
    [ | | lc USE {++} {[]}: {[GenC]} ]

SEM Arm
  | Case				lhs			.	lc		=	[gencSwitchcase @ranges.lc @body.lc]

SEM Range
  | Range1				lhs			.	lc		=	[@expr1.c]
  -- | Range2	-- we need evaluation here... TBD

SEM ExprL LValueL FormalL BodyDeclL
  | Cons				lhs			.	lc		=	@hd.c : @tl.lc

%%]

