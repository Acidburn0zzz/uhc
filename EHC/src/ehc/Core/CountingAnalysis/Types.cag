%%[(8 counting) hs module {%{EH}Core.CountingAnalysis.Types}
%%]

%%[(8 counting) hs import(Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName, hsnIsNr)})
%%]

%%[(8 counting) hs import(UHC.Util.Binary, UHC.Util.Serialize)
%%]

%%[(8 counting) hs import(Control.Monad)
%%]

%%[(8 counting) hs
type AnnVal = Set AnnPrim
type Var = Int
newtype SchemeVar = SV {unSV :: Var}
  deriving (Data, Typeable, Eq, Ord, Show, Generic)
%%]

%%[(8 counting) ag

TYPE UseAnn = Annotation
TYPE DemandAnn = Annotation
TYPE Constraints = [Constraint]
TYPE Annotations = [Annotation]
TYPE AnnotatedTypes = [AnnotatedType]
type Env = map {HsName} (Rho TyScheme)

DERIVING *
  : Data, Typeable, Eq, Ord, Show, Generic

data AnnPrim 
  | Zero 
  | One 
  | Infinity

data Annotation 
  | AnnVar v : {Var} 
  | AnnVal v : {AnnVal}

data AnnotatedType
  | TyVar v : {HsName}
  | TyData n : {HsName} as : Annotations ts : AnnotatedTypes
  | TyFunc t1 : (Rho AnnotatedType) t2 : (Eta AnnotatedType)
  | TyRow ts : AnnotatedTypes
  -- If this is ever inspected then something is wrong in the algorithm
  -- But at the moment it is needed as the AG needs a type in every expression
  -- even unused ones
  | TyError e : {String}

data Eta a 
  | Eta w : a a : UseAnn

data Rho a 
  | Rho w : (Eta a) a : DemandAnn 

data TyScheme 
  | SchemeVar n : {SchemeVar} 
  | SForAll vs : {Set HsName} cs : Constraints t : AnnotatedType

data Constraint 
  -- Annotation constraints
  | AnnC c : (CAnnotation)
  -- AnnotatedType constraints
  | TyC c : (CAnnotatedType)
  -- TyScheme constraints
  | SchemeC c : (CTyScheme)
  -- Instantiation constraint
  | InstC s : TyScheme t : AnnotatedType
  -- Generalisation constraint
  | GenC t : (Rho AnnotatedType) cs : Constraints e : Env s : (Rho TyScheme)

data CAnnotation
  | EqCA c1 : Annotation c2 : Annotation
  | PlusCA c1 : Annotation c2 : Annotation c3 : Annotation
  | UnionCA c1 : Annotation c2 : Annotation c3 : Annotation
  | TimesCA c1 : Annotation a : Annotation c3 : Annotation
  | ConCA c1 : Annotation a : Annotation c3 : Annotation

data CAnnotatedType
  | EqCT c1 : AnnotatedType c2 : AnnotatedType
  | PlusCT c1 : AnnotatedType c2 : AnnotatedType c3 : AnnotatedType
  | UnionCT c1 : AnnotatedType c2 : AnnotatedType c3 : AnnotatedType
  | TimesCT c1 : AnnotatedType a : Annotation c3 : AnnotatedType
  | ConCT c1 : AnnotatedType a : Annotation c3 : AnnotatedType

data CTyScheme
  | EqCS c1 : TyScheme c2 : TyScheme
  | PlusCS c1 : TyScheme c2 : TyScheme c3 : TyScheme
  | UnionCS c1 : TyScheme c2 : TyScheme c3 : TyScheme
  | TimesCS c1 : TyScheme a : Annotation c3 : TyScheme
  | ConCS c1 : TyScheme a : Annotation c3 : TyScheme

data C a
  | EqC c1 : a c2 : a
  | PlusC c1 : a c2 : a c3 : a
  | UnionC c1 : a c2 : a c3 : a
  | TimesC c1 : a a : Annotation c3 :a
  | ConC c1 : a a : Annotation c3 : a

%%]

%%[(8 counting) hs

annBot' = S.empty
annZero' = S.singleton Zero
annOne' = S.singleton One
annW' = S.singleton Infinity
annTop' = S.fromList [Zero, One, Infinity]

annBot = AnnVal annBot'
annZero = AnnVal annZero'
annOne = AnnVal annOne'
annW = AnnVal annW'
annTop = AnnVal annTop'

annPow :: AnnVal -> Set AnnVal
annPow = S.fromList . map (S.fromList) . annPow' . S.toList
  where annPow' [] = [[]]
        annPow' (x:xs) = p ++ map (x:) p
          where p = annPow' xs

annPowWithoutEmpty :: AnnVal -> Set AnnVal
annPowWithoutEmpty = S.delete (S.empty) . annPow

instance Functor Eta where
  fmap f (Eta x a) = Eta (f x) a

instance Functor Rho where
  fmap f (Rho x a) = Rho (fmap f x) a

annAdd :: AnnVal -> AnnVal -> AnnVal
annAdd a1 a2 = S.fromList [x .+ y | x <- S.toList a1, y <- S.toList a2] 

annUnion :: AnnVal -> AnnVal -> AnnVal
annUnion = S.union

annTimes :: AnnVal -> AnnVal -> AnnVal
annTimes a1 a2 = S.fromList [annFromInt (sum $ map annToInt y) | x <- S.toList a1, y <- f (annToInt x) $ S.toList a2]
  where f 0 _ = [[]] 
        f _ [] = []
        f n y@(x:xs) = f n xs ++ map (x:) (f (n-1) y)

annCon :: AnnVal -> AnnVal -> AnnVal
annCon a1 a2 = S.unions $ map (\x -> if x == Zero then annZero' else a2) $ S.toList a1

(.+) :: AnnPrim -> AnnPrim -> AnnPrim
x .+ y = annFromInt $ annToInt x + annToInt y

annToInt :: AnnPrim -> Int
annToInt Zero = 0
annToInt One = 1
annToInt Infinity = 2;

annFromInt :: Int -> AnnPrim
annFromInt 0 = Zero
annFromInt 1 = One
annFromInt _ = Infinity

instance Serialize AnnPrim where
instance Serialize Annotation where
instance Serialize AnnotatedType where
instance Serialize a => Serialize (Eta a) where
instance Serialize a => Serialize (Rho a) where
instance Serialize TyScheme where
instance Serialize SchemeVar where
instance Serialize Constraint where
instance Serialize a => Serialize (C a) where

class ToGC a b | a -> b where
  toGC :: b -> C a

instance ToGC Annotation CAnnotation where
  toGC (EqCA a b) = EqC a b
  toGC (PlusCA a b c) = PlusC a b c
  toGC (UnionCA a b c) = UnionC a b c
  toGC (TimesCA a b c) = TimesC a b c
  toGC (ConCA a b c) = ConC a b c

instance ToGC AnnotatedType CAnnotatedType where
  toGC (EqCT a b) = EqC a b
  toGC (PlusCT a b c) = PlusC a b c
  toGC (UnionCT a b c) = UnionC a b c
  toGC (TimesCT a b c) = TimesC a b c
  toGC (ConCT a b c) = ConC a b c

instance ToGC TyScheme CTyScheme where
  toGC (EqCS a b) = EqC a b
  toGC (PlusCS a b c) = PlusC a b c
  toGC (UnionCS a b c) = UnionC a b c
  toGC (TimesCS a b c) = TimesC a b c
  toGC (ConCS a b c) = ConC a b c


-- replaceRho :: AnnotatedType -> Rho AnnotatedType -> Rho AnnotatedType
-- replaceRho bt (Rho t d)      = Rho (replaceEta bt t) d

-- replaceEta :: AnnotatedType -> Eta AnnotatedType -> Eta AnnotatedType
-- replaceEta bt (Eta t u)      = Eta (replace bt t) u

-- replace :: AnnotatedType -> AnnotatedType -> AnnotatedType
-- replace bt tv@(TyVar v)      = if hsnIsNr v then bt else tv
-- replace bt (DataTy n ann tl) = DataTy n ann $ map (replace bt) tl
-- replace bt (TyFunc rt et)    = TyFunc (replaceRho bt rt) $ replaceEta bt et
-- replace _ x = x

-- stripRho :: Rho a -> Eta a
-- stripRho (Rho t _) = t

-- stripEta :: Eta a -> a
-- stripEta (Eta t _) = t

-- stripRhoEta :: Rho a -> a
-- stripRhoEta (Rho (Eta t _) _) = t

-- getAnnRho :: Rho a -> Annotation
-- getAnnRho (Rho _ a) = a

-- getAnnEta :: Eta a -> Annotation
-- getAnnEta (Eta _ a) = a

%%]
