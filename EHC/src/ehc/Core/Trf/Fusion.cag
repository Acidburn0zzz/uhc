%%[93 hs module {%{EH}Core.Trf.Fusion} import ({%{EH}Core.Trf.Rewrite} (rewrite, ConvMp(..), Role(..)), {%{EH}Core.Trf.Inline} (inline, FuncMp(..))) 
%%]

%%[93 hs import (qualified Data.Set as Set,Data.Maybe (fromMaybe, isJust, isNothing),Debug.Trace,{%{EH}Ty},{%{EH}Base.Common},{%{EH}LamInfo},{%{EH}Core},{%{EH}AbstractCore}, {%{EH}Core.Trf.Subst} (cexprSubst),  qualified Data.Map as Map)
%%]

%%[93 ag import ({Core/AbsSyn})

{
cmodTrfFusion :: LamMp -> CModule -> CModule
cmodTrfFusion lamMp cmod = 
     let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) 
                            (Inh_CodeAGItf {lamMp_Inh_CodeAGItf = lamMp
                                           } )
     in inlined_Syn_CodeAGItf t
}


-- Main idea: inlined should inline all fusible functions (and their non-recursive subterms)
--            rewritten should take the result and do forall x. cons (abs x) |-> x
--            fused should finish the job

{

-- | 'apply func arg' will produce the result of performing a beta reduction by
-- | applying the lamda abstraction func to the expression arg. Used to inline 
-- | functions at App nodes where func has been marked as fusible 

-- This will call an attribute grammar transformation for the attribute substd

apply :: CExpr -> CExpr -> CExpr
apply (CExpr_Lam nm body) arg = cexprSubst nm body arg
apply func                arg = trace "tried to inline a non-Lambda expression" $ acoreApp1 func arg -- this shouldn't happen, but don't want to cause a crash

}

ATTR CodeAGItf [ || applied : CModule]
ATTR AllCodeNT [ || applied : SELF]

SEM CExpr
        | App lhs.applied = @applied
        | App loc.applied = if @func.isFusible -- && @arg.isFusible
                            then apply @func.applied @arg.rewritten -- inline this function application.  
                                                                   -- We actually want the fused version of the arg, 
                                                                   -- but this hasn't been defined yet
                            else acoreApp1 @func.applied @arg.rewritten
        | Var lhs.applied = if @isFusible 
                            then fromMaybe @applied (Map.lookup (acbrefNm @ref) @lhs.fuseMp)
                            else @applied

ATTR CodeAGItf [ | | rewritten : CModule]
ATTR AllCodeNT [ | | rewritten : SELF]
 
SEM CExpr 
       | App lhs.rewritten = @rewritten
       | App loc.rewritten = rewrite @lhs.convMp @applied -- take the inlined code and attempt to remove any con . abs

ATTR CodeAGItf [ | | inlined : CModule]
ATTR AllCodeNT [ | | inlined : SELF   ]
 
SEM CExpr 
       | App lhs.inlined = inline @lhs.funcMp @loc.rewritten
         
------------------------------------------------------------------------------
-- Tests to see if a function is fusible.  A @func of an App is fusible if it 
-- is a named function found in the fuseMp, if it is a function application 
-- whose @func is fusible. 
------------------------------------------------------------------------------

ATTR CExpr [ || isFusible : Bool ]

SEM CExpr
        | Var loc.isFusible           = isJust (Map.lookup (acbrefNm @ref) @lhs.fuseMp)
        | Var lhs.isFusible           = @isFusible
        | App lhs.isFusible           = @func.isFusible
        | * - App Var lhs.isFusible   = False

-- Transformations to actually perform a beta reduction. An App node is beta reduced by calling 
-- subst nm body expr, where nm is the variable to replace, body is the body of the function, and 
-- expr is the expr to substitute in for nm that passes in the substExpr attribute.

------------------------------------------------------------------------------
-- Gather the names of conversions and their role into a Map 
------------------------------------------------------------------------------

ATTR AllCodeNT [ convMp : ConvMp | | ]

SEM CodeAGItf
        | AGItf module.convMp = Map.empty

SEM CExpr
        | Let body.convMp = @binds.gathConvMp `Map.union` @lhs.convMp

ATTR CBindL [ | | gathConvMp USE {`Map.union`} {Map.empty} : ConvMp ]

ATTR CBind  [ | | gathConvMp : ConvMp ]

SEM CBind
        | Bind loc.gathConvMp = fromMaybe Map.empty (do 
                                    { lamInfo <- Map.lookup @nm @lhs.lamMp   
                                    ; role    <- Map.lookup acbaspkeyFusionRole (laminfoBindAspMp lamInfo) 
                                    ; return (case role of
                                                 LamInfoBindAsp_FusionRole FusionRole_BuildLeft  -> Map.singleton @nm Abs 
                                                 LamInfoBindAsp_FusionRole FusionRole_BuildRight -> Map.singleton @nm Con 
                                                 _                                               -> Map.empty)
                                    })
                                        
------------------------------------------------------------------------------
-- Pass fusible function names and bodies down the expressions
------------------------------------------------------------------------------

WRAPPER CodeAGItf 

{
type FuncS  = Set.Set HsName
}

ATTR CodeAGItf AllCodeNT [lamMp  : LamMp  | | ] -- passed in, contains which functions have which fusion roles
ATTR AllCodeNT [fuseMp : FuncMp | | ] -- starts blank, this will contain the transformed code (circular dependecy) for the functions that need to be inlined for fusion 

SEM CodeAGItf
        | AGItf module.fuseMp = Map.empty


SEM CExpr
        | Let body.fuseMp  = @binds.gathFuseMp `Map.union` @lhs.fuseMp -- gather the functions from let bindings that need to be fused, and add them to the parent's fusion map, and push this down the tree


ATTR CBindL [ || gathFuseMp USE {`Map.union`} {Map.empty} : FuncMp ] -- combine all the maps for all the elements of a CBind list

ATTR CBind [ || gathFuseMp : FuncMp ]

SEM CBind 
  | Bind loc.gathFuseMp = fromMaybe Map.empty (do 
                            { lamInfo <- Map.lookup @nm @lhs.lamMp -- look up a bindings lamInfo 
                            ; role    <- Map.lookup acbaspkeyFusionRole (laminfoBindAspMp lamInfo) 
                            ; return (case role of
                                        LamInfoBindAsp_FusionRole FusionRole_Fuse -> Map.singleton @nm $ head @bindAspects.gathExpr -- add the name + expression 
                                        _                                         -> Map.empty)
                            })

ATTR CBindAspectL [ || gathExpr USE {++} {[]} : {[CExpr]} ] -- this should just be always be a singleton list, but probably not the safest way...

ATTR CBindAspect [ || gathExpr USE {++} {[]} : {[CExpr]}]

SEM CBindAspect
        | Bind lhs.gathExpr = [@expr.rewritten] -- The fuseMap holds the result of any inlining done to this code instead of the original


-------------------------------------------------------------------------------
-- Collect the names of fusible transformers (that is, functions that are used 
-- in fusible functions that aren't conversion functions)
-------------------------------------------------------------------------------

ATTR AllCodeNT [ inFusibleFunc : Bool | | ]

SEM CodeAGItf
        | AGItf module.inFusibleFunc = False
 

SEM CBind
        | Bind bindAspects.inFusibleFunc = @lhs.inFusibleFunc || isJust (Map.lookup @nm @gathFuseMp) 
                                               

ATTR AllCodeNT [ funcMp : FuncMp | | ]

ATTR CodeAGItf AllCodeNT [ | | funcS USE {`Set.union`} {Set.empty} : FuncS ]

SEM CodeAGItf
        | AGItf module.funcMp = Map.empty

SEM CExpr
        | Var lhs.funcS = if @lhs.inFusibleFunc 
                          then Set.singleton (acbrefNm @ref)
                          else Set.empty 

SEM CExpr 
        | Let body.funcMp = if @categ == acoreBindcategRec -- no recursive functions allowed, or everything blows up 
                            then @lhs.funcMp
                            else @binds.gathFuncMp `Map.union` @lhs.funcMp

ATTR CBindL [ | | gathFuncMp USE {`Map.union`} {Map.empty} : FuncMp ]
ATTR CBind  [ | | gathFuncMp : FuncMp ]

SEM CBind 
        | Bind loc.gathFuncMp = if Set.member @nm @bindAspects.funcS 
                                   && isNothing (Map.lookup @nm @lhs.convMp)
                                then Map.singleton @nm $ head @bindAspects.gathExpr
                                else Map.empty                                  

ATTR CExpr [ | | varName : {Maybe HsName} ] 

SEM CExpr
        | Var lhs.varName     = Just $ acbrefNm @ref
        | * - Var lhs.varName = Nothing
%%] 
