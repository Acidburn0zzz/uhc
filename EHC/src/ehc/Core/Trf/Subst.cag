%%[93 hs module {%{EH}Core.Trf.Subst} import ({%{EH}AbstractCore},{%{EH}Core},{%{EH}Ty},{%{EH}Base.Common}, Debug.Trace(trace)) 
%%]

%%[93 ag import ({Core/AbsSyn})

{

apply :: CExpr -> CExpr -> CExpr
apply (CExpr_Lam nm body) arg = cexprSubst nm body arg
apply func                arg = trace "tried to inline a non-Lambda expression" $ acoreApp1 func arg -- this shouldn't happen, but don't want to cause a crash

cexprSubst :: HsName -> CExpr -> CExpr -> CExpr
cexprSubst nm body arg = 
        let t = wrap_CExpr (sem_CExpr body)
                           (Inh_CExpr { substExpr_Inh_CExpr = arg
                                      , substName_Inh_CExpr = nm
                                      } )
        in substd_Syn_CExpr t

}

WRAPPER CExpr 

ATTR AllCodeNT [ substExpr : CExpr substName : {HsName} | | substd : SELF  ]

SEM CExpr
        | Var lhs.substd = if (acbrefNm @ref) == @lhs.substName 
                           then @lhs.substExpr 
                           else @substd
        | Lam lhs.substd = if @arg == @lhs.substName -- hole in the scope of substName
                           then @substd
                           else acoreLam [@arg] @body.substd
        -- TODO: Let bindings (anything else?) can also cut holes in the scope of 
        -- substName, need to check for these

         
%%]
