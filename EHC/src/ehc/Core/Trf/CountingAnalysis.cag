%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hidde's counting Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Implementation of Hidde's counting Analysis

%%[(8 counting) hs module {%{EH}Core.Trf.CountingAnalysis} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map (Map),qualified Data.Map as Map)
%%]

%%[(8 counting) hs import({%{EH}Base.Common},{%{EH}Base.HsName.Builtin},{%{EH}Gam.DataGam},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ConstraintGeneration},{%{EH}CountingAnalysis.ConstraintSolver},{%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.Substitution} as S)
%%]

%%[(8 counting) hs import(UHC.Util.Utils)
%%]

%%[(8 counting) hs import(Data.Proxy (Proxy))
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/CommonLevAlt},{Core/CommonLevLamPer1Lam},{Core/CommonCtxtPred},{Core/Trf/CommonFv},{Core/Trf/CommonStructureInfo},{Core/CommonBindNm})
WRAPPER CodeAGItf
%%]

%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs
cmodTrfAnalysis :: Bool -> DataGam -> CModule -> CModule
cmodTrfAnalysis s dataGam cmod
  =  let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) 
                            (Inh_CodeAGItf
                             { dataGam_Inh_CodeAGItf = dataGam,
                               subtyping_Inh_CodeAGItf = s
                             })
     in cTrf_Syn_CodeAGItf t
%%]

%%[(8 counting) hs export(cmodTrfAnalysisCounting)
cmodTrfAnalysisCounting :: DataGam -> CModule -> CModule
cmodTrfAnalysisCounting = cmodTrfAnalysis True
%%]

%%[(8 counting) hs export(cmodTrfAnalysisCountingUnique)
cmodTrfAnalysisCountingUnique :: DataGam -> CModule -> CModule
cmodTrfAnalysisCountingUnique = cmodTrfAnalysis False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag
ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]
ATTR AllNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]
ATTR CodeAGItf AllNT [ subtyping: Bool | | ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag
ATTR AllNT [ solvedContraints: {Solution} | freshVar: {Var} | constrs USE {++} {[]}: {Constraints}]
ATTR AllExprBase [ | env: Env | ety: {EtaAnnotatedType} fety: {EtaAnnotatedType}]
ATTR CBind CBound [ | | name: HsName]
ATTR AllExprBase [ isSeq: Bool | | ]

-- Ensure type is defined everywhere
-- SEM AllExprBase
--   | *
--     -- should be lazy but are not
--     loc.ety = Eta (TyError $ "Unsupported expression: " {-++ show @loc.cTrf-}) annBot

SEM CodeAGItf
  | AGItf
    module.freshVar = 0
    lhs.cTrf = {-traceShow ("Constraints: (", length @module.constrs,") ", @module.constrs, @loc.solvedContraints) $ -}@module.cTrf
    loc.solvedContraints = solveConstraints @module.freshVar @module.constrs
    module.solvedContraints = @loc.solvedContraints

SEM AllExprBase
  | * 
    lhs.fety = EtaAnnotatedType_Eta (AnnotatedType_TyError "Unsupported fety") annBot

SEM CModule
  | *
    expr.env = Map.empty
    expr.isSeq = False

SEM CBind
  | Bind
    lhs.name = @nm
  | * - Bind
    lhs.name = mkHNm $ "Not supported CBind alternative: " {-++ show @loc.cTrf-}
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported CBind alternative" {-++ show @loc.cTrf-}) annBot

SEM CBound
  | Bind
    loc.ety = @expr.ety
    lhs.name = case @expr.cTrf of
                CExpr_Var (ACoreBindRef n _) -> n
                _ -> panic "Code is not in ANormalForm"
  | * - Bind
    lhs.name = mkHNm $ "Not supported CBound alternative: " {-++ show @loc.cTrf-}
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported CBound alternative" {-++ show @loc.cTrf-}) annBot

SEM CExpr
  | * 
    lhs.fety := S.substSolution @loc.ety @lhs.solvedContraints
  | Var
    lhs.freshVar = @lhs.freshVar + 3
    loc.tau = AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ @lhs.freshVar + 0)
    loc.sigma = TyScheme_SchemeVar $ SV $ @lhs.freshVar + 1
    loc.nu = Annotation_AnnVar $ @lhs.freshVar + 2
    lhs.constrs = [Constraint_InstC @loc.sigma @loc.tau]
    lhs.env = Map.singleton (acbrefNm @ref) $ RhoTyScheme_Rho (EtaTyScheme_Eta @loc.sigma @loc.nu) annOne 
    loc.ety = EtaAnnotatedType_Eta @loc.tau @loc.nu
  | Lam
    loc.nu2 = Annotation_AnnVar $ @lhs.freshVar + 0
    loc.tau = AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ @lhs.freshVar + 1)
    ((loc.c2, lhs.env), loc.fv) = computeTimes @body.freshVar @loc.nu2 $ Map.delete @bind.name @body.env
    bind.freshVar = @lhs.freshVar + 2
    (loc.scheme, lhs.freshVar) = envLookup @loc.fv @body.env @bind.name
    lhs.constrs = Constraint_SchemeC (CTyScheme_EqC (stripRhoEta $ toRho @loc.scheme) (TyScheme_SForAll Set.empty Set.empty [] @loc.tau)) : @body.constrs ++ @loc.c2
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyFunc (fromRho $ fmap (const @loc.tau) $ toRho @loc.scheme) @body.ety) @loc.nu2 
  | App
    ((loc.c2a, loc.tyArg), loc.fv1) = sub @func.freshVar True @func.ety
    ((loc.c1a, loc.tyFunc), loc.fv2) = sub @loc.fv1 @lhs.subtyping @arg.ety
    func.freshVar = @lhs.freshVar + 3
    loc.delta2 = Annotation_AnnVar $ @lhs.freshVar + 0
    loc.sigma3 = EtaAnnotatedType_Eta (AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ @lhs.freshVar + 1)) $ Annotation_AnnVar $ @lhs.freshVar + 2
    ((loc.c3, lhs.env), lhs.freshVar) = computeAdd @loc.fv2 @func.env $ (Map.adjust (\(RhoTyScheme_Rho sigma4 _) -> RhoTyScheme_Rho sigma4 @loc.delta2) (@arg.name) @arg.env)
    lhs.constrs = Constraint_AnnC (CAnnotation_EqC (getAnnEta $ toEta @loc.tyFunc) annOne) : 
                    Constraint_TyC (CAnnotatedType_EqC (stripEta $ toEta @loc.tyFunc) (AnnotatedType_TyFunc (RhoAnnotatedType_Rho @loc.tyArg @loc.delta2) @loc.sigma3)) :
                    @loc.c1a ++ @func.constrs ++ @loc.c2a ++ @arg.constrs ++ @loc.c3
    loc.ety = @loc.sigma3
  | Let
    loc.isThisSeq = case @categ of
                    CBindCateg_Strict -> True
                    _ -> False
    binds.isSeq = @loc.isThisSeq
    loc.ety = @body.ety
  | Tup -- How to deal with these as tuple, data constroctor
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Tup" {-++ show @loc.cTrf-}) annBot
  | Case
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Case" {-++ show @loc.cTrf-}) annBot
  | Int
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Int" {-++ show @loc.cTrf-}) annBot
  | Char
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Char" {-++ show @loc.cTrf-}) annBot
  | String
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression String" {-++ show @loc.cTrf-}) annBot
%%[[(97 core)
  | Integer
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Integer" {-++ show @loc.cTrf-}) annBot
%%]]
  -- not supported
  | FFI
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression FFI" {-++ show @loc.cTrf-}) annBot
  | CaseAltFail
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression CaseAltFail " {-++ show @loc.cTrf-}) annBot
  | TupDel
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression TupDel" {-++ show @loc.cTrf-}) annBot
  | TupIns
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression TupIns" {-++ show @loc.cTrf-}) annBot
  | TupUpd
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression TupUpd" {-++ show @loc.cTrf-}) annBot
  | Dbg
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Dbg" {-++ show @loc.cTrf-}) annBot
  | Hole
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Hole" {-++ show @loc.cTrf-}) annBot
  | HoleLet
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression HoleLet" {-++ show @loc.cTrf-}) annBot
  | CoeArg
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression CoeArg" {-++ show @loc.cTrf-}) annBot
  | ImplsApp
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression ImplsApp" {-++ show @loc.cTrf-}) annBot
  | ImplsLam
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression ImplsLam" {-++ show @loc.cTrf-}) annBot
  | Ann
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported expression Ann" {-++ show @loc.cTrf-}) annBot

SEM CExprAnn
  | *
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported CExprAnn" {-++ show @loc.cTrf-}) annBot

SEM CAltL CBindAnnL CBindL CBoundL CPatFldL
  | Nil
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported Nil contructor" {-++ show @loc.cTrf-}) annBot

SEM CBindAnn
  | Coe
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported CBindAnn Coe" {-++ show @loc.cTrf-}) annBot

SEM CPat
  | * 
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported CPat" {-++ show @loc.cTrf-}) annBot

SEM CPatRest
  | *
    loc.ety = EtaAnnotatedType_Eta (AnnotatedType_TyError $ "Unsupported CPatRest" {-++ show @loc.cTrf-}) annBot


%%]

