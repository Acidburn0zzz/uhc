%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin's byte code gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm) hs module {%{EH}GrinCode.ToCmm}
%%]

%%[(8 codegen grin cmm) hs import(Data.Maybe, Data.List as L, UHC.Util.Pretty, UHC.Util.FastSeq as Seq, UHC.Util.Utils, qualified Data.Set as Set, qualified Data.Map as Map)
%%]

%%[(8 codegen grin cmm) hs import(Control.Monad, Control.Monad.State, Control.Applicative)
%%]

%%[(8 codegen grin cmm) hs import({%{EH}Base.Common},{%{EH}Opts},{%{EH}Base.Builtin},qualified {%{EH}Config} as Cfg)
%%]

%%[(8 codegen grin cmm) hs import({%{EH}Error})
%%]
%%[(8 codegen grin cmm) hs import({%{EH}BuiltinPrims})
%%]

%%[(8 codegen grin) hs import({%{EH}CodeGen.ValAccess} as VA, {%{EH}CodeGen.RefGenerator}, {%{EH}CodeGen.Const} as Const)
%%]
%%[(8 javascript) hs import({%{EH}CodeGen.CVar})
%%]

%%[(8 javascript) hs import({%{EH}Gam.DataGam})
%%]

%%[(88 codegen grin cmm) hs import({%{EH}GrinCode.Pretty})
%%]
%%[(8 codegen grin cmm) hs import(qualified {%{EH}Cmm} as Cmm,{%{EH}Core},{%{EH}GrinCode},{%{EH}LamInfo})
%%]

%%[(5050 codegen grin cmm) hs import({%{EH}Ty(tyRowCanonOrder)},{%{EH}HI})
%%]

%%[(8 codegen grin cmm) hs import({%{EH}Foreign.Extract})
%%]

%%[(8 codegen grin cmm) ag import({GrinCode/AbsSyn},{GrinCode/Trf/CommonFreeVar},{GrinCode/CommonForGen},{GrinCode/Trf/CommonIntroName},{GrinCode/CommonValAccess})
%%]

Debug
%%[(88 codegen grin cmm) hs import({%{EH}Base.Debug})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm).grinMod2CmmMod hs export(grinMod2CmmMod)
grinMod2CmmMod
  :: EHCOpts
     -> DataGam
%%[[50
     -> LamMp -> [HsName] -> HsName2FldMpMp -> HsName2FldMp
%%]]
     -> GrModule
     -> ( Cmm.Module
        , [Err]
        )
grinMod2CmmMod
      opts dataGam
%%[[50
      lamMp allImpNmL impNmFldMpMp expNmFldMp
%%]]
      gmod
  = ( cmmMod_Syn_GrAGItf t
    , [] -- errs_Syn_GrAGItf t
    )
  where t = wrap_GrAGItf  (sem_GrAGItf (GrAGItf_AGItf gmod))
                          (Inh_GrAGItf
                             { opts_Inh_GrAGItf = opts
                             , dataGam_Inh_GrAGItf 		  = dataGam
%%[[50
                             , expNmFldMp_Inh_GrAGItf     = expNmFldMp
                             , impNmFldMpMp_Inh_GrAGItf   = impNmFldMpMp
                             , lamMp_Inh_GrAGItf 		  = lamMp
                             , allImpNmL_Inh_GrAGItf      = allImpNmL
%%]]
                             })
%%]

%%[(5050 codegen grin cmm) -8.grinMod2CmmMod hs export(grinMod2CmmMod)
grinMod2CmmMod :: EHCOpts -> LamMp -> [HsName] -> {- [HsName] -> -} HsName2OffsetMpMp -> HsName2OffsetMp -> GrModule -> (GB.Module,[Err])
grinMod2CmmMod opts lamMp allImpNmL {- impNmL -} impNmFldMpMp expNmFldMp gmod
  =  let  t = wrap_GrAGItf  (sem_GrAGItf (GrAGItf_AGItf gmod))
                            (Inh_GrAGItf
                               { expNmFldMp_Inh_GrAGItf     = expNmFldMp
                               , impNmFldMpMp_Inh_GrAGItf   = impNmFldMpMp
                               , allImpNmL_Inh_GrAGItf      = allImpNmL
                               -- , impNmL_Inh_GrAGItf         = offMpKeysSorted impNmFldMpMp -- impNmL
                               , opts_Inh_GrAGItf           = opts
                               , lamMp_Inh_GrAGItf          = lamMp
                               })
     in   (cmmMod_Syn_GrAGItf t, errs_Syn_GrAGItf t)
%%]

%%[(8 codegen grin cmm) ag
WRAPPER GrAGItf
%%]

%%[(8 codegen grin cmm)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utility types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm) hs
type Nm = Cmm.Nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm) hs
grtag2cmmtag :: GrTag -> Cmm.Tag
grtag2cmmtag gt = case gt of
    GrTag_Con _ tg i     -> Cmm.Tag_Con tg i
    GrTag_Hole           -> Cmm.Tag_Ind
    GrTag_Rec            -> Cmm.Tag_Tup
    GrTag_App      nm    -> Cmm.Tag_App
    GrTag_Fun      nm    -> Cmm.Tag_Fun nm
    GrTag_PApp m   nm    -> Cmm.Tag_PApp m nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm)
ATTR AllBind AllGrExpr GrModule GrAGItf
  [ opts: EHCOpts
    dataGam: DataGam
%%[[50
    lamMp: LamMp
%%]]
  | |
  ]
%%]

%%[(88 codegen grin cmm)
%%]
ATTR AllNTNoMod [ modNmConstInx: Int | | ]

%%[(50 codegen grin cmm)
ATTR GrAGItf GrModule
  [ expNmFldMp: HsName2FldMp 
    allImpNmL: {[HsName]}
    -- impNmL: {AssocL HsName Int}
  | |
  ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name map to field nr in node with imported modules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen grin cmm)
ATTR GrAGItf GrModule AllBind AllGrExpr [ impNmFldMpMp: HsName2FldMpMp | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique/fresh
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm)
ATTR AllBind AllGrExpr [ | gUniq: UID | ]

SEM GrModule
  | Mod         loc			.	gUniq			=	uidStart

SEM GrExpr
  | Eval Store App Call FFI Unit
  				loc			.	lUniqRet		:	UNIQUEREF gUniq

SEM GrExpr
  | Eval Store Call FFI App Seq
  				loc			.	lUniq			:	UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm)
SEM GrExpr
  | FFI         lhs			.	constSt	    	=   @constSt2
%%]

%%[(8 codegen grin cmm)
SEM GrBind
  | Bind        loc			.	entryNmConst	=	Nothing
%%]

%%[(8 codegen grin cmm)
SEM GrBind
  | Bind        (loc.constEntryNmFld,loc.constSt2)
  												=   Const.addNm @nm @lhs.constSt
  				expr		.	constSt			=	@constSt2

SEM GrVal
  | LitStr      (loc.constStrFld,loc.constSt2) 	=   Const.addStr @str @lhs.constSt
  				lhs			.	constSt			=	@constSt2
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Entry point info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm) hs
type EntryInfo = EntryInfo' ()
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Debug info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
SEM GrExpr
  | FFI         loc         .   mbDebugStr      =   if ehcOptGenDebug @lhs.opts then Just (@impEntNm) else Nothing
  | Eval App    loc         .   mbDebugStr      =   if ehcOptGenDebug @lhs.opts then Just (show @nm) else Nothing
  | Call        loc         .   mbDebugStrNm    =   Just (if ehcOptGenDebug @lhs.opts then Just (show @nm) else Nothing, @nm)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% State
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GBState threads commonly used admin, e.g. for labels. It is sideline
admin (not main admin like in attributes) to the codegeneration, only
occasionally used, but it is required inside utilitary functions (like
gvLd). Hence this type of info is put in a record, to be less obtrusive
when more of such similar admin is required.

%%[(88 codegen grin cmm)
ATTR AllGrExpr AllBind [ | gbState: {GB.GBState} | ]

SEM GrModule
  | Mod         loc         .   gbState         =   GB.emptyGBState

SEM GrBind
  | Bind        expr        .   gbState         =   @lhs.gbState {GB.gbstMaxStkDepth = 0}

SEM GrExpr
  | Case        altL        .   gbState         =   @aftLblGBState
  | Seq         body        .   gbState         =   GB.gbstIncByStackState @aftLdGBState @seqStInc
  | FetchField FetchNode Throw UpdateUnit
                loc         .   aftLdGBState    =   @aftLblGBState
                lhs         .   gbState         =   @aftLdGBState
  | * - Catch Seq FetchField FetchNode Throw UpdateUnit
                lhs         .   gbState         =   GB.gbstIncByStackState @aftLdGBState @valStInc
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
SEM GrAlt
  | Alt         (expr.gbState,loc.altLabel)     =   GB.newLabelId @lhs.gbState

SEM GrExpr
  | Case        (loc.aftLblGBState,loc.aftCaseLabel,loc.atNrAltsLabel,loc.at1stOffLabel)
                                                =   let (s1,l1) = GB.newLabelId @lhs.gbState
                                                        (s2,l2) = GB.newLabelId s1
                                                        (s3,l3) = GB.newLabelId s2
                                                    in  (s3,l1,l2,l3)
  | * - Case Catch Seq
                (loc.aftLblGBState,loc.retLocLabel)
                                                =   mkRetLabel @lhs.returnCtxt @lhs.gbState
%%]

%%[(88 codegen grin cmm)
ATTR AllAlt [ | | gathNrOfAlts USE {+} {0}: Int ]
ATTR AllAlt [ nrOfAlts: Int | | ]

SEM GrAlt
  | Alt         loc         .   gathNrOfAlts	=   1
%%]

%%[(88 codegen grin cmm)
ATTR AllAlt [ | | altLocRefs USE {++} {[]}: {[GB.LocRef]} ]

SEM GrAlt
  | Alt         loc         .   altLocRef       =   if @lhs.nrOfAlts < 2 then GB.LocRef_Label @altLabel else GB.LocRef_CaseArm @altLabel @pat.tag
                loc         .   altLocRefs      =   [@altLocRef]

SEM GrExpr
  | Case        loc         .   aftCaseLocRef   =   GB.LocRef_EndSwitch @aftCaseLabel
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
SEM GrExpr
  | Case        loc         .   nrOfAlts        =   @altL.gathNrOfAlts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Stack state simulation: depth, GC permission, ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
ATTR AllGrExpr [ | stState: {GB.StackState} | ]

SEM GrBind
  | Bind        loc         .   stState         =   GB.emptyStackState

SEM GrExpr
  | Unit Store Call Eval App FFI FetchUpdate
                loc         .   valStState      =   @lhs.stState `GB.ststInc` @valStInc
  | FetchUpdate Case
                lhs         .   stState         =   @valStState
  | Unit Store Call Eval App FFI
                lhs         .   stState         =   @lhs.stState `GB.ststInc`@retStInc
  | Seq         loc         .   bodyStState     =   @expr.stState `GB.ststInc` @seqStInc
                body        .   stState         =   @bodyStState
  | Case        altL        .   stState         =   @lhs.stState `GB.ststInc` @scrutineeStInc
                loc         .   valStState      =   case @returnCtxt of
                                                      ReturnCtxt_CaseReturns _ st
                                                        -> st `GB.ststIncDep` GB.nrValWords
                                                      _ -> @altL.stState
%%]

%%[(88 codegen grin cmm)
SEM GrAlt
  | Alt         loc         .   fetchStState    =   GB.ststFromDep @fetchDepth
                            .   exprStState     =   @lhs.stState `GB.ststInc` @fetchStState
                expr        .   stState         =   @exprStState
                loc         .   bodyStState     =   case @lhs.returnCtxt of
                                                      ReturnCtxt_CaseFallThrough
                                                        -> @expr.stState           -- scrutinee remains on stack
                                                      _ -> @lhs.stState            -- scrutinee is replaced with value of same size
                lhs         .   stState         =   @bodyStState
%%]

%%[(88 codegen grin cmm)
SEM GrExpr
  | Unit Store Call FFI FetchUpdate Eval App Case
                loc         .   ldStState       =   @lhs.stState
  | Seq         loc         .   ldStState       =   @expr.stState
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Stack depth, derived from state
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
SEM GrExpr
  | Unit Store Call Eval App FFI FetchUpdate
                loc         .   valDepth        =   GB.ststDepth @valStState
  | Seq         loc         .   bodyStkDepth    =   GB.ststDepth @bodyStState
  | Case        loc         .   enumStkInc      =   if @altL.isAllEnum then - GB.nrValWords else 0
                            .   valDepth        =   GB.ststDepth @valStState
%%]

%%[(88 codegen grin cmm)
SEM GrAlt
  | Alt         loc         .   fetchDepth      =   case @altFetch of
                                                      GB.AltFetch_Many ns   -> (length ns - 1) * GB.nrValWords
                                                      GB.AltFetch_One  _ _  -> GB.nrValWords
                                                      GB.AltFetch_Zero      -> 0
                            .   exprStkDepth    =   GB.ststDepth @exprStState
                loc         .   bodyStkDepth    =   GB.ststDepth @bodyStState
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tail call info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm) hs
data ReturnCtxt
  = ReturnCtxt_Returns                                  -- return from function
  | ReturnCtxt_Continues                                -- don't return, further process result
%%]
  | ReturnCtxt_CaseReturns  GB.LabelId GB.StackState    -- return from case alt (return destination, return stack depth)
  | ReturnCtxt_CaseFallThrough                          -- return from case with only 1 alt, so don't clean up stack

%%[(8 codegen grin cmm)
ATTR AllGrExpr [ returnCtxt: ReturnCtxt | | ]

SEM GrBind
  | Bind        expr        .   returnCtxt      =   ReturnCtxt_Returns -- (length @argNmL)

SEM GrExpr
  | Seq         expr        .   returnCtxt      =   ReturnCtxt_Continues
%%]
  | Case        loc         .   returnCtxt      =   case @lhs.returnCtxt of
                                                      ReturnCtxt_Continues
                                                        | @nrOfAlts == 1 -> ReturnCtxt_CaseFallThrough
                                                        | otherwise      -> ReturnCtxt_CaseReturns @aftCaseLabel @lhs.stState
                                                      ReturnCtxt_CaseFallThrough
                                                        | @nrOfAlts == 1 -> @lhs.returnCtxt
                                                        | otherwise      -> ReturnCtxt_CaseReturns @aftCaseLabel @lhs.stState
                                                      _                  -> @lhs.returnCtxt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BasicAnnot of following expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
ATTR GrExpr [ patBasicAnnot: BasicAnnot | | ]

SEM GrExpr
  | Seq         expr        .   patBasicAnnot   =   nmIntroBasicAnnot @pat.nmIntro

SEM GrAlt
  | Alt         expr        .   patBasicAnnot   =   BasicAnnot_Dflt

SEM GrBind
  | Bind        expr        .   patBasicAnnot   =   BasicAnnot_Dflt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access: see for hooks CommonValAccess
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm) hs
type ValAccessG    = ValAccess    Fld Fld Fld Fld
type ValAccessGamG = ValAccessGam Fld Fld Fld Fld
%%]

%%[(8 codegen grin cmm) hs
patNmL2VAGam' :: AssocL HsName Fld -> ValAccessGamG
patNmL2VAGam' nmDepL = Map.fromList [ (n,Val_Local f (ValAccessAnnot_Annot basicAnnotWord)) | (n,f) <- nmDepL ]

patNmL2VAGam :: [HsName] -> ValAccessGamG
patNmL2VAGam = patNmL2VAGam' . patNmL2DepL id id
%%]

%%[(8 codegen grin cmm)
SEM GrBind
  | Bind        loc         .   newVaGam        =   patNmL2VAGam @argNmL

SEM GrAlt
  | Alt         loc			.   newVaGam        =   patNmL2VAGam @newAltNmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm)
SEM GrExpr
  | FetchNode FetchUpdate FetchField Throw
  				lhs			.	grvalIntro      =   GrValIntro_None
%%]

%%[(8 codegen grin cmm)
SEM GrVal
  | LitStr      lhs         .   grvalIntro      =   GrValIntro_Str   @str (Just @constStrFld)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Delayed unit gval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm) hs
data UnitIntro
  = UnitIntro   GB.GrValIntro
%%]

%%[(88 codegen grin cmm)
ATTR GrExpr [ isSeqArgCtxt: Bool | | ]

SEM GrBind
  | Bind        expr        .   isSeqArgCtxt    =   False

SEM GrAlt
  | Alt         expr        .   isSeqArgCtxt    =   False

SEM GrExpr
  | Seq         expr        .   isSeqArgCtxt    =   True
  | * - Seq     loc         .   isSeqArgCtxt    =   False
%%]

%%[(88 codegen grin cmm)
ATTR GrExpr [ | | mbUnitIntro: {Maybe UnitIntro} ]

SEM GrExpr
  | * - Unit    lhs         .   mbUnitIntro     =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm) hs
%%]
data EValIntro
  = EValIntro_TOS_One   { eviDepth :: GB.StackDepth }
  | EValIntro_TOS_Grp   { eviDepth :: GB.StackDepth, eviSize :: Int }
  | EValIntro_None


%%[(88 codegen grin cmm)
%%]
ATTR GrExpr [ | | evalIntro: EValIntro ]

SEM GrExpr
  | Unit Store Call Eval App Case FFI
                lhs         .   evalIntro       =   EValIntro_TOS_One @valDepth
  | * - Unit Store Call Eval App Case Seq FFI
                lhs         .   evalIntro       =   EValIntro_None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FFI primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Some primitives have a builtin translation.
When used, arguments require different translation, in particular for tagged values the untagging can be omitted, because the instructions translated to are aware of this convention.

Assumption: all GrPatLam's are consecutive, hence we count down along Seq's

%%[(88 codegen grin cmm)
ATTR GrPatLam [ primArgForIntl: Bool | | ]
ATTR GrExpr [ | | primNrArgForIntl: Int ]

SEM GrExpr
  | FFI         loc         .   mbGbPrim        =   lookupPrim BackendGrinByteCode @impEntNm
                            .   optimForIntlPrim=   maybe False (\p -> gbprimNrArgs p == @argL.length) @mbGbPrim
                lhs         .   primNrArgForIntl=   if @optimForIntlPrim then @argL.length else 0
  | Seq         pat         .   primArgForIntl  =   @body.primNrArgForIntl > 0
                lhs         .   primNrArgForIntl=   if @expr.primNrArgForIntl > 0 then @expr.primNrArgForIntl else @body.primNrArgForIntl - 1
  | * - FFI Seq lhs         .   primNrArgForIntl=   -1
%%]

For the result a flag is passed.

%%[(88 codegen grin cmm)
ATTR GrPatLam [ primResForIntl: Bool | | ]

SEM GrExpr
  | Seq         pat         .   primResForIntl  =   @expr.primNrArgForIntl > 0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr Value codegen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
SEM GrExpr
  | Unit        loc         .   (valIns,valStInc,retIsDone,mbUnitIntro,aftLdGBState)
                                                =   case GB.gviLd @lhs.opts (GB.defaultLoadCtxt {GB.lcxOmitTOSLd = True }) @nmEnv @ldStState @aftLblGBState @val.grvalIntro of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState) | not @lhs.isSeqArgCtxt
                                                        -> (ins,inc,False,Nothing, gbState)
                                                      _ -> (Seq.empty,GB.ststFromDep 0,True,Just (UnitIntro @val.grvalIntro), @aftLblGBState)
  | Store       loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLd @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState @val.grvalIntro of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        -> (ins, inc, False, gbState)
  | Call        loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLdFold @lhs.opts (GB.defaultLoadCtxt {GB.lcxDoLdTOS = True}) @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        -> case @lhs.returnCtxt of
                                                             ReturnCtxt_Returns nrArgsOuter
                                                               -> ( ins Seq.:++: fins Seq.:++: Seq.fromList [GB.tailcall GB.InsOp_LocB_TOS nArgMine nrArgsOuter {- retOffSurr -}]
                                                                  , GB.ststFromDep 0, True, gbState2
                                                                  )
                                                               where (fins,fdep,gbState2) = GB.nmLd GB.defaultLoadCtxt @nmEnv (@ldStState `GB.ststInc` inc) gbState @nm
                                                                     nArgMine    = length @argL.grvalIntroL
                                                             _ -> (ins', inc', False, gbState2)
                                                               where (ins',inc',gbState2) = GB.gvCall @mbDebugStrNm @nmEnv ins inc @ldStState gbState @nm
  | FFI         loc         .   (valIns,valStInc,retIsDone,aftLdGBState,constMp3)
                                                =   if @optimForIntlPrim
                                                    then case gbprimMk (fromJust @mbGbPrim) @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                           (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                             -> (ins, inc, False, gbState, @constMp2)
                                                           _ -> panic ("ToCmm.mbGbPrim:" ++ show @impEntNm)
                                                    else case GB.gviLdFold @lhs.opts (GB.defaultLoadCtxt {GB.lcxDoLdTOS = True}) @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                           (GB.GrValIntroAlt_OnTOS ins inc _ basicsz, gbState)
                                                             -> ( ins Seq.:++: fins Seq.:++:
                                                                  Seq.fromList ([GB.meta' GB.AnnIdUse (@impEntNm >#< "szargs=" >|< GB.ststDepth inc >#< "basicsz=" >|< basicszStr)] ++ call)
                                                                , GB.ststFromDepPerm (basicSizeInWords patbasicsz) (grinBasicAnnotGCPermit @lhs.patBasicAnnot), False
                                                                , gbState3 `GB.gbstIncByStackState` callStState
                                                                , constMp3
                                                                )
                                                             where (gbState2,constLbl  ) = GB.newLabelId gbState
                                                                   (gbState3,callencLbl) = GB.newLabelId gbState2
                                                                   fins = Seq.fromList [GB.ldg GB.InsOp_LocB_TOS $ GB.linkChainConst constLbl @constCFld]
                                                                   finc = GB.ststFromDepPerm 1 GCPermit_Not
                                                                   patbasicsz = grinBasicAnnotSize @lhs.patBasicAnnot
                                                                   basicszs = patbasicsz : basicsz
                                                                   (callencInx,constMp3) = Const.addFFICallEncWrapper basicszs @constMp2
                                                                   basicszStr = concatMap basicGrinSizeCharEncoding basicszs
                                                                   callStState = @ldStState `GB.ststInc` inc `GB.ststInc` finc
%%[[8
                                                                   call  = cl
%%][90
                                                                   call  = if forextractOptIsPtr @foreignEntInfo then [] else cl
%%]]
                                                                         where cl = [ GB.meta' GB.AnnStackDepth callStState
                                                                                    , GB.callc @mbDebugStr (callencLbl,callencInx,basicszs) callStState (GB.ststDepth inc)
                                                                                    ]
  | FetchUpdate loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLdFold @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState $ map GB.GrValIntro_Nm $ [@src,@dst] of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        -> (ins Seq.:++: Seq.fromList [GB.fetchupdate], GB.ststFromDep 0, False, gbState)
  | Eval        loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   let (ins,inc,gbState) = GB.nmLd (GB.defaultLoadCtxt {GB.lcxOmitTOSLd = True }) @nmEnv @ldStState @aftLblGBState @nm
                                                    in  case @lhs.returnCtxt of
                                                          ReturnCtxt_Returns nrArgsOuter
                                                            -> (ins Seq.:++: eins, GB.ststFromDep 0, True, gbState)
                                                            where eins       = Seq.fromList [GB.taileval @mbDebugStr GB.InsOp_LocB_TOS nrArgsOuter {- retOffSurr -}]
                                                          _ -> (ins Seq.:++: eins, inc, False, gbState)
                                                            where eins = Seq.fromList [GB.eval @mbDebugStr GB.InsOp_LocB_TOS]
  | App         loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLdFold @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        {-
                                                        -> ( ins Seq.:++: Seq.fromList [GB.ldc (length @argL.grvalIntroL)] Seq.:++: fins Seq.:++: Seq.fromList [GB.apply @mbDebugStr GB.InsOp_LocB_TOS]
                                                           , GB.ststFromDep GB.nrValWords, False, gbState2
                                                           )
                                                        -}
                                                        -> case @lhs.returnCtxt of
                                                             ReturnCtxt_Returns nrArgsOuter
                                                               -> ( ains1 Seq.:++: ains2, GB.ststFromDep 0, True, gbState2 )
                                                               where ains2 = Seq.fromList [GB.tailapply GB.InsOp_LocB_TOS nArgMine nrArgsOuter]
                                                                     nArgMine = nargs + 2 * GB.nrValWords
                                                             _ -> ( ains1 Seq.:++: ains2, GB.ststFromDep GB.nrValWords, False, gbState2 )
                                                               where ains2 = Seq.fromList [GB.apply @mbDebugStr GB.InsOp_LocB_TOS]
                                                        where (fins,_,gbState2) = GB.nmLd GB.defaultLoadCtxt @nmEnv (@ldStState `GB.ststInc` inc `GB.ststIncDep` GB.nrValWords) gbState @nm
                                                              ains1 = ins Seq.:++: Seq.fromList [GB.ldc nargs] Seq.:++: fins
                                                              nargs = length @argL.grvalIntroL
  | Case        loc         .   (valIns,valStInc,retIsDone,scrutineeStInc,aftLdGBState)
                                                =   case GB.gviLd @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @altL.gbState @val.grvalIntro of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        | @nrOfAlts == 1
                                                          -> ( ins Seq.:++: @altL.i, GB.ststFromDep GB.nrValWords, True, inc, gbState )
                                                        | otherwise
                                                          -> ( ins Seq.:++: insc Seq.:++: ins', GB.ststFromDep GB.nrValWords, True, inc `GB.ststIncDep` @enumStkInc, gbState2 )
                                                          where ins' = Seq.fromList [GB.casecall (GB.linkChainOffsets @atNrAltsLabel @nrOfAlts),GB.label (GB.LocRef_Label @at1stOffLabel)]
                                                                        Seq.:++: Seq.fromList {- inslblrefs -- -} [ GB.labelref l | l <- @altL.altLocRefs ]
                                                                        Seq.:++: @altL.i
                                                                        Seq.:++: Seq.fromList [GB.label @aftCaseLocRef]
                                                                insc = if @altL.isAllEnum then Seq.empty else Seq.fromList [GB.ldnt]
                                                                (inslblrefs,gbState2) = GB.labelref2 (map GB.lrefId @altL.altLocRefs) gbState
  | Seq         loc         .   (seqIns,seqStInc,newVaGam,aftLdGBState)
                                                =   let patupd (Just _) annot inc = GB.ststFromDepPerm (GB.ststDepth inc) (grinBasicAnnotGCPermit annot)
                                                        patupd _        _     inc = inc
                                                        nm ins incSt gbState nmIntro
                                                          = case nmIntro of
                                                              -- plain single name: put value on stack, introduce binding to it
                                                              (NmIntro_Single nm annot)
                                                                -> ( ins, incSt `GB.ststInc` GB.ststPatchDepPerm (grinBasicAnnotSizeInWords annot) (grinBasicAnnotGCPermit annot)
                                                                   , Map.fromList [(nm,GB.Val_Local (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Annot annot))], gbState
                                                                   )
                                                              -- name of an enum: put on stack, possibly unpack further, introduce binding
                                                              (NmIntro_GrpTag nm)
                                                                -> (ins Seq.:++: patins,incSt `GB.ststInc` patinc,Map.fromList [(nm,GB.Val_Local (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Annot BasicAnnot_Dflt))],gbState)
                                                                where (patins,patinc) = maybe (Seq.empty,GB.emptyStackState) (\(ins,_,inc) -> (ins,inc)) @pat.mbi
                                                              -- 
                                                              (NmIntro_GrpBasic nm annot)
                                                                -> (ins Seq.:++: patins,incSt {-  -}`GB.ststInc` patinc,Map.fromList [(nm,val)],gbState)
                                                                where (patins,val,patinc)
                                                                        = case (annot,@pat.mbi) of
                                                                            (BasicAnnot_Size _ _ BasicAnnotTagging_FromPtr _, Just (i,bSz,patinc))
                                                                              -> (i        ,GB.Val_Local (GB.ststDepth @ldStState + inc)        (GB.ValAccessAnnot_Basic bSz    gcPermit), patinc              )
                                                                            (BasicAnnot_Size _ _ BasicAnnotTagging_FromPtr _, _                  )
                                                                              -> (Seq.empty,GB.Val_Local (GB.ststDepth @ldStState + inc)        (GB.ValAccessAnnot_Annot BasicAnnot_Dflt), GB.emptyStackState  )
                                                                            (_                           , Just (i,bSz,patinc))
                                                                              -> (i        ,GB.Val_NodeFldLocal (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Basic bSz    gcPermit), GB.emptyStackState  )   -- does this happen?
                                                                            (_                           , _                  )
                                                                              -> (Seq.empty,GB.Val_NodeFldLocal (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Annot annot          ), GB.emptyStackState  )
                                                                        where gcPermit = grinBasicAnnotGCPermit annot
                                                              -- node fields: put node ptr on stack, then fetch fields
                                                              (NmIntro_Grp _ nmL) | not (null nmL)
                                                                -> (ins Seq.:++: fins, GB.ststFromDep (length nmL * GB.nrValWords),g,gbState)
                                                                where fins = Seq.fromList [GB.fetch GB.InsOp_LocB_TOS]
                                                                      g = patNmL2VAGam (GB.ststDepth @ldStState + inc) nmL
                                                              _ -> (ins,incSt,Map.empty,gbState)
                                                          where inc = GB.ststDepth incSt 
                                                    in  case (@expr.mbUnitIntro,@pat.nmIntro) of
                                                          (Just (UnitIntro (GB.GrValIntro_Int i)),NmIntro_Single nmp annot)
                                                            | bsz <= Cfg.sizeofGrWord
                                                              -> (Seq.empty,GB.ststFromDep 0,Map.singleton nmp (GB.Val_Int i),@expr.gbState)
                                                              where bsz = grinBasicAnnotSizeInBytes annot
                                                          (Just (UnitIntro gvi),nmi)
                                                              -> nm ins inc gbState nmi
                                                              where (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                                      = GB.gviLd @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @expr.gbState gvi
                                                          _   -> nm Seq.empty (GB.ststFromDep 0) @expr.gbState @pat.nmIntro
%%]

%%[(8 codegen grin cmm) hs
data GviLoadSt = GviLoadSt
  { {- glstUniq 	:: !UID
  , -} glstDecls	:: !CmmBodyDecls
  
  -- environment info
  , glstDataGam	:: DataGam
  }

type GviLoadStM = StateT GviLoadSt FreshUid

runGviLoad :: UID -> DataGam -> GviLoadStM a -> (a, CmmBodyDecls)
runGviLoad uniq dataGam gs = (x, glstDecls s)
  where (x,s) = evalFreshUid (runStateT gs (GviLoadSt Seq.empty dataGam)) uniq

gviAppendM :: CmmBodyDecls -> GviLoadStM ()
gviAppendM ds = modify $ \st -> st { glstDecls = glstDecls st & ds }

gviLoadM' :: (GrValIntro -> e) -> GrValIntro -> GviLoadStM e
gviLoadM' mk gvi = fmap mk $ firstMaybeM gvi [\gvi -> if gviIsInlineable gvi then return $ Just $ gvi else return Nothing, gvi2MbNonInlineM]
{-
  do
    if gviIsInlineable gvi
      then return $ mk gvi
      else do mbe <- gvi2MbNonInlineM gvi
              case mbe of
                Just e -> return $ mk e
                _      -> return $ mk $ GrValIntro_Nm hsnUnknown
-}

gviLLoadM' :: (GrValIntro -> e) -> [GrValIntro] -> GviLoadStM [e]
gviLLoadM' mk = mapM $ gviLoadM' mk
{-# INLINE gviLLoadM' #-}

gviLLoadExprM :: [GrValIntro] -> GviLoadStM [Cmm.Expr]
gviLLoadExprM = gviLLoadM' gvi2InlineableExpr
{-# INLINE gviLLoadExprM #-}

gviLoadExprM :: GrValIntro -> GviLoadStM Cmm.Expr
gviLoadExprM = gviLoadM' gvi2InlineableExpr
{-# INLINE gviLoadExprM #-}

gviLLoadExpr :: UID -> DataGam -> [GrValIntro] -> ([Cmm.Expr], CmmBodyDecls)
gviLLoadExpr uniq dataGam gviL = runGviLoad uniq dataGam $ gviLLoadExprM gviL

gviLoad' :: (GrValIntro -> e) -> UID -> DataGam -> GrValIntro -> (e, CmmBodyDecls)
gviLoad' mk uniq dataGam gvi = runGviLoad uniq dataGam $ gviLoadM' mk gvi

gviLoadExpr :: UID -> DataGam -> GrValIntro -> (Cmm.Expr, CmmBodyDecls)
gviLoadExpr = gviLoad' gvi2InlineableExpr
{-# INLINE gviLoadExpr #-}

gviLoadGvi :: UID -> DataGam -> GrValIntro -> (GrValIntro, CmmBodyDecls)
gviLoadGvi = gviLoad' id
{-# INLINE gviLoadGvi #-}

gvi2InlineableExpr :: GrValIntro -> Cmm.Expr
gvi2InlineableExpr gvi = fromMaybe (Cmm.err $ show gvi) $ gvi2MbInlineExpr gvi

gvi2FullExpr :: GrValIntro -> Cmm.Expr
gvi2FullExpr = fromMaybe Cmm.undef . gvi2MbExpr
{-# INLINE gvi2FullExpr #-}

-- | To directly inlineable usable expr
gvi2MbInlineExpr :: GrValIntro -> Maybe Cmm.Expr
gvi2MbInlineExpr gvi
  =   gviFoldInlineable (Just . Cmm.Expr_Nm, \i -> Just $ Cmm.Expr_Int (fromIntegral i) Nothing, Nothing) gvi
  <|> gvi2MbConstExpr gvi

gvi2MbExpr :: GrValIntro -> Maybe Cmm.Expr
gvi2MbExpr gvi = gvi2MbInlineExpr gvi <|> gvi2MbNonInlineExpr gvi

gvi2MbConstExpr :: GrValIntro -> Maybe Cmm.Expr
gvi2MbConstExpr gvi = case gvi of
  GrValIntro_Str _ (Just cref) -> return $ Cmm.var $ refOfFld cref
  _                            -> Nothing

gvi2MbNonInlineExpr :: GrValIntro -> Maybe Cmm.Expr
gvi2MbNonInlineExpr gvi = case gvi of
  _						-> Nothing

gvi2MbNonInlineM :: GrValIntro -> GviLoadStM (Maybe GrValIntro)
gvi2MbNonInlineM gvi = case gvi of
  GrValIntro_Grp gt	gviL -> do
    args <- gviLLoadExprM gviL
    dataGam <- gets glstDataGam
    fmap Just $ cmmBindFreshInM $ \newn -> Cmm.alloc dataGam newn (grtag2cmmtag gt) args
  GrValIntro_Box bx	gvi -> do
    arg <- gviLoadExprM gvi
    fmap Just $ cmmBindFreshInM $ \newn -> Cmm.box newn bx arg
  _ -> return Nothing

cmmBindFreshInM :: (HsName -> CmmBodyDecls) -> GviLoadStM GrValIntro
cmmBindFreshInM mk = do
    nm <- fmap (hsnUniqify HsNameUniqifier_CMMTmpVar . mkHNm) $ lift freshUID
    gviAppendM $ Cmm.declLocalRegVar Cmm.tyNd nm Nothing & mk nm
    return $ GrValIntro_Nm nm

cmmBindFreshIn :: UID -> DataGam -> (HsName -> CmmBodyDecls) -> (GrValIntro, CmmBodyDecls)
cmmBindFreshIn u dataGam mk = runGviLoad u dataGam $ cmmBindFreshInM mk
%%]

%%[(8 codegen grin cmm)
SEM GrExpr
  | Unit		loc			.	(grvalIntro, valDecls)
  												=	(@val.grvalIntro, Seq.empty)

  | Eval        loc         .   (grvalIntro, valDecls)
                                                =   case @lhs.returnCtxt of
                                                        ReturnCtxt_Returns | ehcOptGenTrampoline @lhs.opts
                                                          -> (GrValIntro_Nm @nm, Seq.empty)
                                                        _ -> cmmBindFreshIn @lUniq @lhs.dataGam $ \newn -> Cmm.call Nothing (Just newn) Cmm.CallExpr_Eval [Cmm.var @nm]
  | Call        loc         .   (grvalIntro, valDecls)
                                                =   runGviLoad @lUniq @lhs.dataGam $ do
                                                      	argExprL <- gviLLoadExprM @argL.grvalIntroL
                                                      	cmmBindFreshInM $ \newn -> Cmm.call Nothing (Just newn) (Cmm.CallExpr_Expr $ Cmm.var @nm) argExprL
  | FFI         loc         .   (grvalIntro, valDecls)
%%[[8
                                                =   runGviLoad @lUniq @lhs.dataGam $ do
                                                      	argExprL <- gviLLoadExprM @argL.grvalIntroL
                                                      	cmmBindFreshInM $ \newn -> Cmm.call (Just Cmm.Conv_Platform) (Just newn) (Cmm.CallExpr_Expr $ Cmm.ffivar @nm) argExprL
%%][90
                                                =   (GrValIntro_None, Seq.empty)
%%]]
  | Store       loc         .   (grvalIntro, valDecls)
                                                =   gviLoadGvi @lUniq @lhs.dataGam @val.grvalIntro

  | Seq			loc			.	((grvalIntro, newVaGam), seqDecls)
  												=	runGviLoad @lUniq @lhs.dataGam $ do
  														e <- gviLoadExprM @expr.grvalIntro
  														case @pat.nmIntro of
  														  NmIntro_Single nmp annot -> do
  														    gviAppendM $ Cmm.declLocalConst Cmm.Const_SSA Cmm.tyNd nmp e
  														    return $ (GrValIntro_Nm nmp, patNmL2VAGam [nmp])
  														  NmIntro_Box nmp bx -> do
  														    gviAppendM $ Cmm.unbox nmp bx e
  														    return $ (GrValIntro_Nm nmp, patNmL2VAGam [nmp])

  | App			loc			.	(grvalIntro, valDecls)
                                                =   case @lhs.returnCtxt of
                                                        -- ReturnCtxt_Returns | ehcOptGenTrampoline @lhs.opts
                                                        --   -> (GrValIntro_Nm @nm, Seq.empty)
                                                        _ -> runGviLoad @lUniq @lhs.dataGam $ do
                                                               argExprL <- gviLLoadExprM @argL.grvalIntroL
                                                               cmmBindFreshInM $ \newn -> Cmm.call Nothing (Just newn) Cmm.CallExpr_Apply (Cmm.var @nm : argExprL)
%%]

%%[(88 codegen grin cmm) hs
mkRetLabel :: ReturnCtxt -> GB.GBState -> (GB.GBState,GB.LabelId)
mkRetLabel returnCtxt st
  = case returnCtxt of
      ReturnCtxt_CaseReturns _ _
        -> GB.newLabelId st
      _ -> (st,GB.gbstLbl st)
%%]

%%[(8 codegen grin cmm) hs
mkRet :: ReturnCtxt -> (Cmm.Expr, CmmBodyDecls) -> CmmBodyDecls
mkRet returnCtxt (e, decls)
  = case returnCtxt of
      ReturnCtxt_Returns
        -> decls & Cmm.ret (Just e)
      {-
      ReturnCtxt_CaseReturns labelId st
        -> ( Seq.fromList
               [ GB.meta' GB.AnnStackDepth stState
               , GB.retcase GB.nrValWords (stkDepth + inc - dep) (GB.linkChainOffset retLocLbl labelId)
               , GB.meta' GB.AnnStackDepth (dep + incret)
               ]
           , GB.ststFromDep incret
           )
        where incret = GB.nrValWords
              dep = GB.ststDepth st
      ReturnCtxt_CaseFallThrough
        -> (Seq.empty,dfltState)
      -}
      _ -> Seq.empty
  {-
  where dfltState = GB.ststFromDep inc
        stkDepth  = GB.ststDepth stState
        inc       = GB.ststDepth incSt
  -}
%%]

%%[(8 codegen grin cmm)
SEM GrExpr
  | Eval App Store Unit Call FFI
                loc			.	retDecls       	=   mkRet @lhs.returnCtxt (gviLoadExpr @lUniqRet @lhs.dataGam @grvalIntro)
  | * - Unit Store Call Eval App FFI
                loc         .   retDecls        =   Seq.empty
%%]

%%[(88 codegen grin cmm)
SEM GrExpr
  | Unit Store Call Eval App FFI
                (loc.retIns,loc.retStInc)       =   if @retIsDone
                                                    then (Seq.empty,@valStInc)
                                                    else mkRet @lhs.returnCtxt @retLocLabel @lhs.stState @valStInc
  | * - Unit Store Call Eval App FFI
                loc         .   retIns          =   Seq.empty
                            .   retFixOffs      =   Seq.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global entry points
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
ATTR AllBind [ | | entryNms USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq GB.EntryInfo} ]

SEM GrBind
  | Bind        lhs         .   entryNms        =   Seq.singleton (GB.EntryInfo @nm 0 (null @argNmL) (Just $ GB.StringConst $ show @nm))
                loc         .   entryInx        =   GB.vaEntryInx $ panicJust "GrBind.Bind.entryInx" $ GB.nmEnvLookup @nm @nmEnv
%%]

%%[(88 codegen grin cmm).entryNmMp
SEM GrModule
  | Mod         loc         .   (entryNmMp,entryL,isCafL)
                                                =   let entryL = zipWith (\i e -> e {GB.eiEntryNr = i}) [0..] $ Seq.toList @bindL.entryNms
                                                        mpMod = Map.fromList [ (GB.eiNm e, e) | e <- entryL ]
                                                    in  ( mpMod, entryL
                                                        , map GB.eiIsCAF entryL
                                                        )
%%]

%%[(88 codegen grin cmm)
SEM GrModule
  | Mod         loc         .   mainEntry       =   maybe 0 GB.vaEntryInx $ GB.nmEnvLookup hsnMain @nmEnv
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional C include files (we now assume C will be generated)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(90 codegen grin)
ATTR AllBind AllGrExpr [ | | includeS USE {`Set.union`} {Set.empty} : {Set.Set String} ]

SEM GrExpr
  | FFI         lhs         .   includeS        =   Set.fromList $ forextractIncludes @foreignEntInfo
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin cmm)
ATTR GrAGItf GrModule [ | | cmmMod: {Cmm.Module} ]
%%]

%%[(8 codegen grin cmm)
SEM GrModule
  | Mod         lhs         .   cmmMod       	=   Cmm.Module_Mod @moduleNm -- @moduleNmAlpha
%%[[5050
                                                      [ (n,hsnShowAlphanumeric n) | n <- @lhs.allImpNmL ]
                                                      (offMpKeysSorted @lhs.impNmFldMpMp)
                                                      [ m | (n,_) <- sortOn snd $ Map.toList @lhs.expNmFldMp
                                                          , let m = panicJust ("ToCmm.GrModule.Mod: " ++ show n) (Map.lookup n @entryNmMp)
                                                      ]
%%]]
                                                      (Seq.toList
                                                       $ (let mk f (Const_String {constString=s}) = Cmm.declGlobalConst Cmm.Const_CompileTime Cmm.tyStr8 (refOfFld f) (Cmm.str8 s)
                                                              mk f  _                             = Seq.empty
                                                          in  Seq.unions [ mk f c | (c,f) <- Map.toList $ conststMp @bindL.constSt ]
                                                         )
                                                       & @bindL.cmmTopDecls
                                                      )
%%[[9090
                                                      (Set.toList @bindL.includeS)
%%]]
                                                      @bindL.constSt
%%]

%%[(8 codegen grin cmm) hs
type CmmTopDecls = Seq.Seq Cmm.TopLevel
type CmmBodyDecls = Seq.Seq Cmm.BodyDecl

infixr 1 &
(&) = Seq.union
{-# INLINE (&) #-}
%%]

%%[(8 codegen grin cmm)
ATTR AllBind [ | | cmmTopDecls USE {&} {Seq.empty}: CmmTopDecls ]

SEM GrBind
  | Bind        lhs         .   cmmTopDecls   	=   Seq.singleton $ Cmm.TopLevel_Proc $
  														Cmm.Proc_Proc Nothing @nm [ Cmm.Formal_Formal Nothing False Cmm.tyNd a | a <- @argNmL ] $
  															Cmm.Body_Body (Seq.toList @expr.cmmBodyDecls)
%%]

%%[(8 codegen grin cmm)
ATTR AllGrExpr [ | | cmmBodyDecls USE {&} {Seq.empty}: CmmBodyDecls ]

SEM GrExpr
  | Eval App Store Unit
                lhs         .   cmmBodyDecls    =   @valDecls & @retDecls
  | Call Case FFI FetchUpdate
                lhs         .   cmmBodyDecls    =   Seq.empty
  | Seq			lhs			.	cmmBodyDecls	= 	@expr.cmmBodyDecls & @seqDecls & @body.cmmBodyDecls
%%]

SEM GrExpr
  | Unit Store Call Eval App Case FFI FetchUpdate
                lhs         .   i               =   @valIns Seq.:++: @retIns
  | Seq         lhs         .   i               =   @expr.i Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @ldStState]
                                                            Seq.:++: @seqIns Seq.:++: @body.i
                                                            Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @bodyStState]
                                                            Seq.:++: @retIns

{-
DATA GrExpr
  | Seq         expr            : GrExpr
                pat             : GrPatLam
                body            : GrExpr
  | Unit        val             : GrVal
                type			: GrType
  | UpdateUnit  nm              : {HsName}
                val             : GrVal
  | Case        val             : GrVal
                altL            : GrAltL
  | FetchNode   nm              : {HsName}
  | FetchUpdate src             : {HsName}
                dst             : {HsName}
  | FetchField  nm              : {HsName}
                offset          : {Int}
                mbTag           : {Maybe GrTag}
  | Store       val             : GrVal
  | Call        nm              : {HsName}
                argL            : GrValL
  | FFI
 %%[[8
                nm              : {String}
 %%][90
                callconv        : {FFIWay}
                impEnt          : {ForeignEnt}
 %%]]
 %%[[99
                ffiAnnot        : {GrFFIAnnot}
 %%]]
                argL            : GrValL
  | Eval        nm              : {HsName}
  | App         nm              : {HsName}
                argL            : GrValL
  | Throw       nm              : {HsName}
  | Catch       body            : GrExpr
                arg             : {HsName}
                handler         : GrExpr
-}

{-
DATA GrVal
  | Empty
  | VarNode     fldL            : GrValL
  | BasicNode   tag             : GrTag
                nm              : {HsName}
  | EnumNode    nm              : {HsName}
  | PtrNode     nm              : {HsName}
  | LitStr      str             : {String}
  | Tag         tag             : GrTag
  | Node        tag             : GrTag
                fldL            : GrValL
  | OpaqueNode  nm              : {HsName}

DATA Expr
  | Int				val				: Integer
  					mbTy			: MbTy
  | Lit				val				: Lit
  | Round			val				: Round
  | Rat				nom				: Integer
  					denom			: Integer
  					mbTy			: MbTy
  | Float			val				: Double
  					mbTy			: MbTy
  | Char			val				: Char
  					mbTy			: MbTy
  | Nm				nm				: Nm
  | Typed			ty				: Ty
  					expr			: Expr
  					mbAssert		: MbAssert
  | Op				op				: Op
  					exprs			: ExprL
-}


%%[(88 codegen grin cmm)
ATTR AllBind AllGrExpr GrPatLam [ | | i USE {Seq.:++:} {Seq.empty}: {GB.InsSeq} ]

SEM GrModule
  | Mod         loc         .   i               =   Seq.fromList
                                                       [ GB.halt	-- dummy, so linkChain won't start at 0, which is used to indicate a linkChain Nil.
                                                       ]
                                                    Seq.:++: @bindL.i


SEM GrBind
  | Bind        lhs         .   i               =   Seq.fromList
                                                       [ GB.funstart (GB.FunctionInfo (show @nm) @nm (GB.gbstMaxStkDepth @expr.gbState)
%%[[8
                                                                                      []
%%][50
                                                                                      (maybe [] (\i -> if laminfo1stArgIsStackTrace i then [GB.FunctionInfoFlag_1stArgIsStackTrace] else [])
                                                                                       $ Map.lookup @nm @lhs.lamMp)
%%]]
                                                                                      )
                                                       , GB.label (GB.LocRef_CodeEntry @entryInx)
                                                       , GB.meta' GB.AnnFunStart @nm
                                                       ]
                                                    Seq.:++: @expr.i

SEM GrExpr
  | Unit Store Call Eval App Case FFI FetchUpdate
                lhs         .   i               =   @valIns Seq.:++: @retIns
  | Seq         lhs         .   i               =   @expr.i Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @ldStState]
                                                            Seq.:++: @seqIns Seq.:++: @body.i
                                                            Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @bodyStState]
                                                            Seq.:++: @retIns

SEM GrAlt
  | Alt         lhs         .   i               =   let fetch = case @altFetch of
                                                                  GB.AltFetch_Many _  -> Seq.fromList [GB.fetch GB.InsOp_LocB_TOS]
                                                                  GB.AltFetch_One _ o -> Seq.fromList [GB.l2ts (o + GB.nrNodeHdrWords)]
                                                                  GB.AltFetch_Zero    -> Seq.empty
                                                    in  Seq.fromList [GB.meta' GB.AnnStackDepth @lhs.stState,GB.label @altLocRef]
                                                        Seq.:++: fetch
                                                        Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @exprStState]
                                                        Seq.:++: @expr.i
                                                        Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @bodyStState]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation, additional for a variable intro for a FFI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
ATTR GrPatLam [ | | mbi: {Maybe (GB.InsSeq,BasicSize,GB.StackState)} ]

SEM GrPatLam
  | BasicNode   lhs         .   mbi             =   let basicSize = grinBasicAnnotSize @annot
                                                    in  case @annot of
                                                          BasicAnnot_Size bsz _ BasicAnnotTagging_FromPtr sgn
                                                            | not @lhs.primArgForIntl
                                                              -> Just (Seq.fromList [GB.untag2 sgn {-(basicSizeIsSigned bsz)-}],basicSize,GB.ststPatchTOSGCNot)
                                                          _   -> Nothing
  | EnumNode    lhs         .   mbi             =   if @lhs.primArgForIntl
                                                    then Nothing
                                                    else Just ( Seq.fromList [GB.untag2 False]
                                                              , grinBasicAnnotSize BasicAnnot_Dflt
                                                              , GB.ststPatchTOSGCNot
                                                              )
  | * - BasicNode EnumNode
                lhs         .   mbi             =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(88 codegen grin cmm)
ATTR GrTag [ | | self: SELF ]
%%]

