%%[(8 counting) hs module {%{EH}CountingAnalysis.ConstraintSolverPhase2} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map,qualified Data.Map as Map)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName, mkHNm)})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ConstraintGeneration},{%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.Substitution} as S)
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.ExtractVar} as E)
%%]

%%[(8 counting) hs import(UHC.Util.Utils (panic))
%%]

%%[(8 counting) hs import(Data.Proxy (Proxy))
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting) hs import (Data.Dequeue (BankersDequeue), qualified Data.Dequeue as Q, qualified Data.Foldable as F)
%%]

%%[(8 counting) hs import (Control.Arrow (second))
%%]

%%[(8 counting) hs import (Data.Monoid ((<>)))
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn})
WRAPPER Root
%%]

%%[(8 counting) hs

solveConstraintsPhase2 :: Var -> Constraints -> Solution
solveConstraintsPhase2 v cs 
  = let t = solveConstraints' v cs
    in Solution
      { annSol = annSol_Syn_Root t
      , tySol = tySol_Syn_Root t
      , schemeSol = schemeSol_Syn_Root t
      }


%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% general
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag



%%]

%%[(8 counting) hs


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% phase 2: substitute solution, remove solved constraints, find new usefull constraints to solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR All [ | | useFullConstraints USE {(++)} {[]}: Constraints notUseFullConstraints USE {(++)} {[]}: Constraints ]
ATTR All [ changedAnnVars: {Set Var} changedTyVars: {Set HsName} changedSchemeVars: {Set SchemeVar} | | ]



%%]