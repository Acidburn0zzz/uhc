%%[(8 counting) hs module {%{EH}CountingAnalysis.Substitution} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map (Map),qualified Data.Map as Map, qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName)}, {%{EH}Gam.DataGam}, {%{EH}Core}, {%{EH}CodeGen.Tag (CTag)})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

%%[(8 counting) hs import({%{EH}Base.Common(CLbl)})
%%]

%%[(8 counting) hs import(UHC.Util.VarLookup(MetaLev))]
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn}, {CountingAnalysis/AbsSynExpr})
WRAPPER *
%%]

%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% access functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs export (Subst(..))
class Subst a where
  substAnn :: a -> AnnSol -> a
  substAnn a m = subst a m Map.empty Map.empty
  substTy :: a -> TySol -> a
  substTy a m =  subst a Map.empty m Map.empty
  substScheme :: a -> SchemeSol -> a
  substScheme a m = subst a Map.empty Map.empty m
  substSolution :: a -> Solution -> a
  substSolution a (Solution as ts ss) = subst a as ts ss

  subst :: a -> AnnSol -> TySol -> SchemeSol -> a

instance Subst Expr where
  subst a am tm sm = subst_Syn_Expr $ wrap_Expr (sem_Expr a) 
    (Inh_Expr am sm tm)

instance Subst Annotation where
  subst a am tm sm = subst_Syn_Annotation $ wrap_Annotation (sem_Annotation a) 
    (Inh_Annotation am sm tm)

instance Subst Type where
  subst a am tm sm = subst_Syn_Type $ wrap_Type (sem_Type a) 
    (Inh_Type am sm tm)

instance Subst Constraint where
  subst a am tm sm = subst_Syn_Constraint $ wrap_Constraint (sem_Constraint a) 
    (Inh_Constraint am sm tm)

instance Subst Constraints where
  subst a am tm sm = subst_Syn_Constraints $ wrap_Constraints (sem_Constraints a) 
    (Inh_Constraints am sm tm)

instance Subst Field where
  subst a am tm sm = subst_Syn_Field $ wrap_Field (sem_Field a) 
    (Inh_Field am sm tm)

instance Subst EtaType where
  subst a am tm sm = subst_Syn_EtaType $ wrap_EtaType (sem_EtaType a) 
    (Inh_EtaType am sm tm)

instance Subst RhoType where
  subst a am tm sm = subst_Syn_RhoType $ wrap_RhoType (sem_RhoType a) 
    (Inh_RhoType am sm tm)

instance Subst RhoScheme where
  subst a am tm sm = subst_Syn_RhoScheme $ wrap_RhoScheme (sem_RhoScheme a) 
    (Inh_RhoScheme am sm tm)

instance Subst Env where
  subst a am tm sm = subst_Syn_Env $ wrap_Env (sem_Env a) 
    (Inh_Env am sm tm)

instance Subst Scheme where
  subst a am tm sm = subst_Syn_Scheme $ wrap_Scheme (sem_Scheme a) 
    (Inh_Scheme am sm tm)
    
instance Subst [Annotation] where
  subst xs am tm sm = map (\x -> subst x am tm sm) xs

instance Subst [Type] where
  subst xs am tm sm = map (\x -> subst x am tm sm) xs

instance Subst Fields where
  subst xs am tm sm = map (\x -> subst x am tm sm) xs
 
instance Subst [Fields] where
  subst xss am tm sm = map (\xs -> subst xs am tm sm) xss

instance Subst [RhoType] where
  subst xs am tm sm = map (\x -> subst x am tm sm) xs

instance Subst [[RhoType]] where
  subst xss am tm sm = map (\xs -> subst xs am tm sm) xss

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% substitition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR * [ substAnnMap: AnnSol substTyMap: TySol substSchemeMap: SchemeSol | | subst: SELF ]

SEM Annotation
  | Var
    lhs.subst = maybe @loc.subst (\x -> subst x @lhs.substAnnMap @lhs.substTyMap @lhs.substSchemeMap) $ Map.lookup @v @lhs.substAnnMap

SEM Type
  | Var
    lhs.subst = maybe @loc.subst (\x -> subst x @lhs.substAnnMap @lhs.substTyMap @lhs.substSchemeMap) $ Map.lookup @v @lhs.substTyMap

SEM Scheme
  | Var
    lhs.subst = maybe @loc.subst (\x -> subst x @lhs.substAnnMap @lhs.substTyMap @lhs.substSchemeMap) $ Map.lookup @v @lhs.substSchemeMap

%%]