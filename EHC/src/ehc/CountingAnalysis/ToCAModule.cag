%%[(8 counting) hs module {%{EH}CountingAnalysis.ToCAModule} import(Data.Maybe,Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M, qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}LamInfo},{%{EH}Base.Common},{%{EH}Base.HsName.Builtin},{%{EH}Gam.DataGam},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import(UHC.Util.Utils)
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting).WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]


%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs export(toCAModule)
toCAModule :: CModule -> CAModule
toCAModule cmod
  =  let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) 
                            (Inh_CodeAGItf
                             { 
                             })
     in trf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs
getVarName :: CAExpr -> HsName
getVarName (CAExpr_Var v) = v
getVarName e = panic $ "extracting var failed from: " ++ show e

%%]

%%[(8 counting) ag

ATTR CodeAGItf [ | | trf: {CAModule} ]
ATTR CModule [ | | trf: {CAModule} ]
ATTR CExpr [ | | trf: {CAExpr} ]
ATTR CPat [ | | trf: {CAPat} ]
ATTR CBind [ | | trf: {CABinding} ]
ATTR CBound [ | | trf: {CAExpr} ]
ATTR CAlt [ | | trf: {CAAlt} ]
ATTR CBindL [ | | trf: {CABindings} ]
ATTR CBoundL [ | | trf: {[CAExpr]} ]
ATTR CAltL [ | | trf: {CAAlts} ]
ATTR CPatRest [ | | isEmpty: {Bool} ]
ATTR CPatFldL [ | | trf: {[HsName]} ]
ATTR CPatFld [ | | trf: {HsName} ]

SEM CModule 
  | Mod
   lhs.trf = CAModule_Module @expr.trf

SEM CExpr
  | Var
    lhs.trf = CAExpr_Var $ acbrefNm @ref
  | Int
    lhs.trf = CAExpr_Int @int
  | Char
    lhs.trf = CAExpr_Char @char
  | String 
    lhs.trf = CAExpr_String @str
%%[[(97 core)
  | Integer
    lhs.trf = CAExpr_Integer @integer
%%]] 
  | Let
    lhs.trf = (if @loc.isStrict then 
                CAExpr_LetBang (if length @binds.trf == 1 then 
                  head @binds.trf else panic "multiple bindings in let!") 
               else CAExpr_Let @binds.trf) @body.trf
    loc.isStrict = case @categ of
                    CBindCateg_Strict -> True
                    _ -> False
  | Tup
    lhs.trf = if @loc.isRec then CAExpr_Rec [] else CAExpr_Con (ctagTyNm @tag) (ctagNm @tag) []
    loc.isRec = ctagIsRec @tag
  | Lam
    lhs.trf = CAExpr_Lam @loc.arg @body.trf
    loc.arg = case @bind.trf of CABinding_Bind n _ -> n
    -- totally ignore dflt
  | Case
    lhs.trf = CAExpr_Case @expr.trf @alts.trf
  | App
    lhs.trf = case @func.trf of
                CAExpr_Con tn cn flds -> CAExpr_Con tn cn $ flds ++ [CAConVar_Var $ getVarName @arg.trf]
                CAExpr_Rec flds -> CAExpr_Rec $ flds ++ [CAConVar_Var $ getVarName @arg.trf]
                _ -> CAExpr_App @func.trf $ getVarName @arg.trf
  | FFI
    -- TODO
    lhs.trf = CAExpr_FFI @callconv 
                @safety         
%%[[8
                @impEnt
%%][90
                @impEnt
%%]]
                @ty

SEM CPat
  | Con
    lhs.trf = if @rest.isEmpty then
                if @loc.isRec then CAPat_RecPat @binds.trf else CAPat_Pat (ctagTyNm @tag) (ctagNm @tag) @binds.trf
              else panic "CPatRest not empty"
    loc.isRec = ctagIsRec @tag
  | * - Con
    lhs.trf = panic "Unsupported CPat alternative"

SEM CPatRest
  | Var
    lhs.isEmpty = False
  | Empty
    lhs.isEmpty = True

SEM CPatFld
  | Fld
    lhs.trf = case @bind.trf of CABinding_Bind n _ -> n

SEM CBind
  | Bind
    lhs.trf = CABinding_Bind @nm $ if length @bindAspects.trf == 1 then 
                head @bindAspects.trf else panic "Multiple bounds for single bind"

SEM CBound
  | Bind 
    lhs.trf = @expr.trf
  | Meta
    lhs.trf = panic "Unsupported CBound Alternative Meta" 
%%[[(8 codegenanalysis)
  | RelevTy
    lhs.trf = panic "Unsupported CBound Alternative RelevTy" 
%%]]
  | Val
    lhs.trf = panic "Unsupported CBound Alternative Val" 
  | Ty
    lhs.trf = panic "Unsupported CBound Alternative Ty" 
 
SEM CAlt
  | Alt
    lhs.trf = CAAlt_Alt @pat.trf @expr.trf

SEM CBindL CBoundL CAltL CPatFldL
  | Cons
    lhs.trf = @hd.trf : @tl.trf
  | Nil
    lhs.trf = []


-- not supported
SEM CExpr
  | CaseAltFail
    lhs.trf = panic "Unsupported expression CaseAltFail"-- CAExpr_Var $ mkHNm "Unsupported expression CaseAltFail"
  | TupDel
    lhs.trf = panic "Unsupported expression TupDel"-- CAExpr_Var $ mkHNm "Unsupported expression TupDel"
  | TupIns
    lhs.trf = panic "Unsupported expression TupIns"-- CAExpr_Var $ mkHNm "Unsupported expression TupIns"
  | TupUpd
    lhs.trf = panic "Unsupported expression TupUpd"-- CAExpr_Var $ mkHNm "Unsupported expression TupUpd"
  | Dbg
    lhs.trf = panic "Unsupported expression Dbg"-- CAExpr_Var $ mkHNm "Unsupported expression Dbg"
  | Hole
    lhs.trf = panic "Unsupported expression Hole"-- CAExpr_Var $ mkHNm "Unsupported expression Hole"
  | HoleLet
    lhs.trf = panic "Unsupported expression HoleLet"-- CAExpr_Var $ mkHNm "Unsupported expression HoleLet"
  | CoeArg
    lhs.trf = panic "Unsupported expression CoeArg"-- CAExpr_Var $ mkHNm "Unsupported expression CoeArg"
  | ImplsApp
    lhs.trf = panic "Unsupported expression ImplsApp"-- CAExpr_Var $ mkHNm "Unsupported expression ImplsApp"
  | ImplsLam
    lhs.trf = panic "Unsupported expression ImplsLam"-- CAExpr_Var $ mkHNm "Unsupported expression ImplsLam"

%%]

