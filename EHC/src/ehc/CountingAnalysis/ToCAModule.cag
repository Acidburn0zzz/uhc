%%[(8 counting) hs module {%{EH}CountingAnalysis.ToCAModule} import(Data.Maybe,Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M, qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}LamInfo},{%{EH}Base.Common},{%{EH}Base.HsName.Builtin},{%{EH}Gam.DataGam},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis} as CA)
%%]

%%[(8 counting) hs import(UHC.Util.Utils)
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting).WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]


%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs export(toCAModule)
toCAModule :: Map HsName CA.Scheme -> CModule -> CA.Module
toCAModule lamMap cmod
  =  let t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) 
                            (Inh_CodeAGItf
                             { lamMp_Inh_CodeAGItf = lamMap
                             })
     in trf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs

getConVar :: CA.Expr -> CA.ConVar
getConVar (CA.Expr_VarLocal v) = CA.ConVar_VarLocal v
getConVar (CA.Expr_VarImport v) = CA.ConVar_VarImport v
getConVar (CA.Expr_Const c) = CA.ConVar_Const c
getConVar e = panic $ "getting app bound failed from: " ++ show e

%%]

%%[(8 counting) ag

ATTR * [lamMp: {Map HsName CA.Scheme} | | ]

ATTR CodeAGItf [ | | trf: {CA.Module} ]
ATTR CModule [ | | trf: {CA.Module} ]
ATTR CExpr [ | | trf: {CA.Expr} ]
ATTR CPat [ | | trf: {Either (Either Int Char) (Either (HsName, HsName, [HsName]) [HsName])} ]
ATTR CBind [ | | trf: {Either CA.Binding HsName} ]
ATTR CBound [ | | trf: {CA.Expr} ]
ATTR CAlt [ | | trf: {Either (Either CA.AltCon ([HsName], CA.Expr)) CA.AltConst} ]
ATTR CBindL [ | | trf: {CA.Bindings} ]
ATTR CBoundL [ | | trf: {[CA.Expr]} ]
ATTR CAltL [ | | trf: {Either (Either CA.AltCons ([HsName], CA.Expr)) (Either CA.AltConsts ())} ]
ATTR CPatRest [ | | isEmpty: {Bool} ]
ATTR CPatFldL [ | | trf: {[HsName]} ]
ATTR CPatFld [ | | trf: {HsName} ]

SEM CModule 
  | Mod
   lhs.trf = CA.Module_Module @expr.trf

SEM CExpr
  | Var
    lhs.trf = (if @loc.isImported then CA.Expr_VarImport else CA.Expr_VarLocal) $ acbrefNm @ref
    loc.isImported = acbrefNm @ref `M.member` @lhs.lamMp
  | Int
    lhs.trf = CA.Expr_Const $ CA.Const_Int @int
  | Char
    lhs.trf = CA.Expr_Const $ CA.Const_Char @char
  | String 
    lhs.trf = CA.Expr_Const $ CA.Const_String @str
%%[[(97 core)
  | Integer
    lhs.trf = CA.Expr_Const $ CA.Const_Integer @integer
%%]] 
  | Let
    lhs.trf = (if @loc.isStrict then 
                case @binds.trf of
                  [CA.Binding_Bind n e] -> CA.Expr_LetBang n e
                  _ -> panic "multiple bindings in let!"
               else CA.Expr_Let @binds.trf) @body.trf
    loc.isStrict = case @categ of
                    CBindCateg_Strict -> True
                    _ -> False
  | Tup
    lhs.trf = if @loc.isRec then CA.Expr_Tup [] else CA.Expr_Con (ctagTyNm @tag) (ctagNm @tag) []
    loc.isRec = ctagIsRec @tag
  | Lam
    lhs.trf = CA.Expr_Abs @loc.arg @body.trf
    loc.arg = case @bind.trf of 
                Right n -> n
                Left (CA.Binding_Bind n _) -> n
    -- totally ignore dflt
  | Case
    lhs.trf = case @alts.trf of
                Left (Left cs) -> CA.Expr_CaseCon @expr.trf cs
                Left (Right (xs, e)) -> CA.Expr_CaseTup @expr.trf xs e
                Right (Left cs) -> CA.Expr_CaseConst @expr.trf cs

  | App
    lhs.trf = case @func.trf of
                CA.Expr_Con tn cn flds -> CA.Expr_Con tn cn $ flds ++ [getConVar @arg.trf]
                CA.Expr_Tup flds -> CA.Expr_Tup $ flds ++ [getConVar @arg.trf]
                _ -> case getConVar @arg.trf of
                  CA.ConVar_VarLocal v -> CA.Expr_AppLocal @func.trf v
                  CA.ConVar_VarImport v -> CA.Expr_AppImport @func.trf v
                  CA.ConVar_Const c -> CA.Expr_AppConst @func.trf c

  | FFI
    lhs.trf = CA.Expr_FFI @ty

SEM CPat
  | Con
    lhs.trf = if @rest.isEmpty then
                if @loc.isRec then Right $ Right @binds.trf else Right $ Left (ctagTyNm @tag, ctagNm @tag, @binds.trf)
              else panic "CPatRest not empty"
    loc.isRec = ctagIsRec @tag
  | Var
    lhs.trf = panic "Unsupported CPat alternative Var"
  | Int
    lhs.trf = Left $ Left @int
  | Char
    lhs.trf = Left $ Right @char
%%[[(97 core)
  | BoolExpr
    lhs.trf = panic "Unsupported CPat alternative BoolExpr"
%%]]

SEM CPatRest
  | Var
    lhs.isEmpty = False
  | Empty
    lhs.isEmpty = True

SEM CPatFld
  | Fld
    lhs.trf = case @bind.trf of 
                Right n -> n
                Left b -> panic $ "No var in CPatFld: " ++ show b

SEM CBind
  | Bind
    lhs.trf = case length @bindAspects.trf of
                0 -> Right @nm
                1 -> Left $ CA.Binding_Bind @nm $ head @bindAspects.trf 
                _ -> traceShow (@bindAspects.trf) $ panic $ "Multiple bounds for single bind: " ++ show @nm

SEM CBound
  | Bind Val
    lhs.trf = @expr.trf
%%[[(8 codegenanalysis)
  | RelevTy
    lhs.trf = panic "Unsupported CBound Alternative RelevTy" 
%%]]
  | Ty
    lhs.trf = CA.Expr_Error "Unsupported CBound Alternative Ty" 
%%[[90
  | FFE
    lhs.trf = panic "Unsupported CBound Alternative FFE" 
%%]]

SEM CAlt
  | Alt
    lhs.trf = case @pat.trf of
                Left (Left n) -> Right $ CA.AltConst_Int n @expr.trf
                Left (Right c) -> Right $ CA.AltConst_Char c @expr.trf
                Right (Left (d,c,xs)) -> Left $ Left $ CA.AltCon_Alt d c xs @expr.trf
                Right (Right xs) -> Left $ Right (xs, @expr.trf)

SEM CBindL
  | Cons
    lhs.trf = @loc.bind : @tl.trf
    loc.bind = case @hd.trf of
                Left b -> b
                Right n -> panic "Empty BoundL in BindL" 
  | Nil
    lhs.trf = []

SEM CBoundL CPatFldL
  | Cons
    lhs.trf = @hd.trf : @tl.trf
  | Nil
    lhs.trf = []

SEM CAltL
  | Cons
    lhs.trf = case (@hd.trf, @tl.trf) of
                (Left (Left x), Left (Left xs)) -> Left $ Left $ x:xs
                (Left (Left x), Right (Right ())) -> Left $ Left [x]
                (Right x, Right (Left xs)) -> Right $ Left $ x:xs
                (Right x, Right (Right ())) -> Right $ Left [x]
                (Left (Right x), Right (Right ())) -> Left $ Right x
                _ -> panic "Mismatched cases"
  | Nil
    lhs.trf = Right $ Right ()

-- not supported
SEM CExpr
  | CaseAltFail
    lhs.trf = panic "Unsupported expression CaseAltFail"-- CAExpr_Var $ mkHNm "Unsupported expression CaseAltFail"
  | TupDel
    lhs.trf = panic "Unsupported expression TupDel"-- CAExpr_Var $ mkHNm "Unsupported expression TupDel"
  | TupIns
    lhs.trf = panic "Unsupported expression TupIns"-- CAExpr_Var $ mkHNm "Unsupported expression TupIns"
  | TupUpd
    lhs.trf = panic "Unsupported expression TupUpd"-- CAExpr_Var $ mkHNm "Unsupported expression TupUpd"
  | Dbg
    lhs.trf = panic "Unsupported expression Dbg"-- CAExpr_Var $ mkHNm "Unsupported expression Dbg"
  | Hole
    lhs.trf = panic "Unsupported expression Hole"-- CAExpr_Var $ mkHNm "Unsupported expression Hole"
  | HoleLet
    lhs.trf = panic "Unsupported expression HoleLet"-- CAExpr_Var $ mkHNm "Unsupported expression HoleLet"
  | CoeArg
    lhs.trf = panic "Unsupported expression CoeArg"-- CAExpr_Var $ mkHNm "Unsupported expression CoeArg"
  | ImplsApp
    lhs.trf = panic "Unsupported expression ImplsApp"-- CAExpr_Var $ mkHNm "Unsupported expression ImplsApp"
  | ImplsLam
    lhs.trf = panic "Unsupported expression ImplsLam"-- CAExpr_Var $ mkHNm "Unsupported expression ImplsLam"

%%]

