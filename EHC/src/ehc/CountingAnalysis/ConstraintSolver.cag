%%[(8 counting) hs module {%{EH}CountingAnalysis.ConstraintSolver} import(Data.Maybe,Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M, qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName, mkHNm)})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ConstraintGeneration},{%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.Substitution} as S)
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.ExtractVar} as E)
%%]

%%[(8 counting) hs import(UHC.Util.Utils (panic))
%%]

%%[(8 counting) hs import(Data.Proxy (Proxy))
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting) hs import (Data.Dequeue (BankersDequeue), qualified Data.Dequeue as Q, qualified Data.Foldable as F)
%%]

%%[(8 counting) hs import (Control.Arrow (second))
%%]

%%[(8 counting) hs import (Data.Monoid ((<>)))
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn})
WRAPPER Root Phase2Root
%%]

%%[(8 counting) hs export(solveConstraints)

solveConstraints :: Var -> Constraints -> Solution
solveConstraints v cs = {-traceShow ("constrs: ", cs) $ -} {-traceShow "start solving" $ -}rootSynSolution $ solveConstraints' v cs

rootSynSolution :: Syn_Root -> Solution
rootSynSolution t = 
  Solution
    { annSol = annSol_Syn_Root t
    , tySol = tySol_Syn_Root t
    , schemeSol = schemeSol_Syn_Root t
    }

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% fix point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs

solveConstraints' :: Var -> Constraints -> Syn_Root
solveConstraints' v cs = solveConstraintsFix $ Syn_Root
  { annPartSol_Syn_Root = M.empty
  , annSol_Syn_Root = M.empty
  , freshVar_Syn_Root = v
  , notUseFullConstraints_Syn_Root = mempty
  , schemeSol_Syn_Root = M.empty
  , tySol_Syn_Root = M.empty
  , useFullConstraints_Syn_Root = fromConstraints cs
  }

solveConstraintsFix :: Syn_Root -> Syn_Root
solveConstraintsFix syn = if finished then finalSyn else solveConstraintsFix finalSyn
  where (nc', sc', ic') = splitConstraints $ toConstraints $ useFullConstraints_Syn_Root syn
        (nc, sc, ic) = (fromConstraints nc', fromConstraints sc', fromConstraints ic')
        (bc, tc) | nc /= mempty = (nc, sc <> ic)
                 | sc /= mempty = (sc, ic)
                 | otherwise = (ic, mempty)
        syn' = syn {useFullConstraints_Syn_Root = bc}
        resSyn = singleSolveRun syn'
        phase2Syn = getUseFullConstraints syn $ resSyn {notUseFullConstraints_Syn_Root = notUseFullConstraints_Syn_Root syn}
        useFull = useFullConstraints_Syn_Root resSyn <> useFullConstraints_Syn_Phase2Root phase2Syn <> tc
        notUseFull = notUseFullConstraints_Syn_Root syn <> notUseFullConstraints_Syn_Phase2Root phase2Syn
        finalSyn = resSyn { useFullConstraints_Syn_Root = useFull, notUseFullConstraints_Syn_Root = notUseFull}
        finished = useFull == mempty || rootSynSolution syn == rootSynSolution finalSyn

-- old syn, new syn
getUseFullConstraints :: Syn_Root -> Syn_Root -> Syn_Phase2Root
getUseFullConstraints old syn = wrap_Phase2Root (sem_Phase2Root (Phase2Root_Phase2Root $ toConstraints $ notUseFullConstraints_Syn_Root syn)) 
  (Inh_Phase2Root 
    { changedSchemeVars_Inh_Phase2Root = M.keysSet (schemeSol_Syn_Root syn) S.\\ M.keysSet (schemeSol_Syn_Root old)
    , changedTyVars_Inh_Phase2Root = M.keysSet (tySol_Syn_Root syn) S.\\ M.keysSet (tySol_Syn_Root old)
    , changedAnnVars_Inh_Phase2Root = S.union annSolChanges annPartSolChanges
    , finalAnnPartSol_Inh_Phase2Root = annPartSol_Syn_Root syn
    , finalAnnSol_Inh_Phase2Root = annSol_Syn_Root syn
    , finalSchemeSol_Inh_Phase2Root = schemeSol_Syn_Root syn
    , finalTySol_Inh_Phase2Root = tySol_Syn_Root syn
    })
  where annSolChanges = M.keysSet (annSol_Syn_Root syn) S.\\ M.keysSet (annSol_Syn_Root old)
        annPartSolChanges = M.keysSet $ M.filterWithKey (\k v -> Just v /= M.lookup k (annSol_Syn_Root old)) (annSol_Syn_Root syn)
    

-- (normal constraints, scheme constraints, instantiation constraints
splitConstraints :: Constraints -> (Constraints, Constraints, Constraints)
splitConstraints [] = mempty
splitConstraints (c:cs) = case c of
  Constraint_SchemeC (CTyScheme_EqC{}) -> (c:nc, sc, ic)
  Constraint_SchemeC _ -> (nc, c:sc, ic)
  Constraint_InstC{} -> (nc, sc, c:ic)
  _ -> (c:nc,sc,ic)
  where (nc, sc, ic) = splitConstraints cs

singleSolveRun :: Syn_Root -> Syn_Root
singleSolveRun syn = traceShow "solve single" $ traceShowId $ wrap_Root (sem_Root (Root_Root $ toConstraints $ useFullConstraints_Syn_Root syn)) 
  (Inh_Root 
    { freshVar_Inh_Root = freshVar_Syn_Root syn 
    , annPartSol_Inh_Root = annPartSol_Syn_Root syn
    , annSol_Inh_Root = annSol_Syn_Root syn
    , tySol_Inh_Root = tySol_Syn_Root syn
    , schemeSol_Inh_Root = schemeSol_Syn_Root syn
    })

deriving instance Show Syn_Root

%%]

%%[(8 counting) ag

SEM Root
  | Root
    lhs.useFullConstraints = @cs.useFullConstraints <> @cs.newConststraints

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% general
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR ALLTYPES Root [ | freshVar: Var | ]
ATTR ALLTYPES [ | | copy: SELF]

%%]

%%[(8 counting) hs

getRhoEtaVars :: Rho a -> Set Var
getRhoEtaVars (Rho a b) = S.union (getEtaVar a) $ case b of
  Annotation_AnnVar v -> S.singleton v
  _ -> S.empty

getEtaVar :: Eta a -> Set Var
getEtaVar (Eta _ (Annotation_AnnVar v)) = S.singleton v
getEtaVar _ = S.empty

filterMap :: Ord a => Map a b -> Set a -> Map a b
filterMap m s = M.filterWithKey (\k _ -> k `S.member` s) m

lookupPartSol :: AnnPartSol -> Set Var -> AnnPartSol
lookupPartSol m s = filterMap (M.union m $ M.fromList $ map (,topAnn) $ S.toList s) s

checkConstr :: (Eq a, Compute a) => C a -> Bool
checkConstr (EqC a b) = a == b
checkConstr (PlusC a b c) = {-traceShow "check plus" $ -}simpleCompute computeAdd a b == Just c
checkConstr (UnionC a b c) = {-traceShow "check union" $ -}simpleCompute computeUnion a b == Just c
checkConstr (TimesC a b c) = {-traceShow "check times" $ -}simpleCompute computeTimes b a == Just c
checkConstr (ConC a b c) = {-traceShow "check con" $ -}simpleCompute computeCon b a == Just c

topAnn :: Set AnnVal
topAnn = annPowWithoutEmpty annTop'

solveTyConstr :: Var -> CAnnotatedType -> (Var, GatherConstraints, TySol, Bool)
solveTyConstr fresh c = traceShow "solve Ty" $ case c of
  CAnnotatedType_EqC (AnnotatedType_TyVar a) v@(AnnotatedType_TyVar _) -> (fresh, mempty, M.singleton a v, True)
  CAnnotatedType_EqC (AnnotatedType_TyVar a) f@(AnnotatedType_TyFunc{}) -> (fresh, mempty, M.singleton a f, True)
  CAnnotatedType_EqC (AnnotatedType_TyVar a) d@(AnnotatedType_TyData{}) -> (fresh, mempty, M.singleton a d, True)
  CAnnotatedType_EqC a v@(AnnotatedType_TyVar _) -> solveTyConstr fresh $ CAnnotatedType_EqC v a
  CAnnotatedType_PlusC (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) -> (fresh, mempty, M.empty, False) -- unsolvable
  CAnnotatedType_PlusC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) f@(AnnotatedType_TyFunc{}) -> (fresh, mempty, M.fromList [(a, f), (b, f)], True)
  CAnnotatedType_PlusC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = fromConstraints $ map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_PlusC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.fromList [(a, AnnotatedType_TyData dn av1 ts), (b, AnnotatedType_TyData dn av2 ts)], True)
  CAnnotatedType_PlusC v1@(AnnotatedType_TyVar _) a v2@(AnnotatedType_TyVar _) -> solveTyConstr fresh $ CAnnotatedType_PlusC v1 v2 a
  CAnnotatedType_UnionC (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) -> (fresh, mempty, M.empty, False) -- unsolvable
  CAnnotatedType_UnionC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) f@(AnnotatedType_TyFunc{}) -> (fresh, mempty, M.fromList [(a, f), (b, f)], True)
  CAnnotatedType_UnionC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = fromConstraints $  map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_UnionC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.fromList [(a, AnnotatedType_TyData dn av1 ts), (b, AnnotatedType_TyData dn av2 ts)], True)
  CAnnotatedType_UnionC v1@(AnnotatedType_TyVar _) a v2@(AnnotatedType_TyVar _) -> solveTyConstr fresh $ CAnnotatedType_UnionC v1 v2 a
  CAnnotatedType_TimesC (AnnotatedType_TyVar _) an (AnnotatedType_TyVar _) -> (fresh, mempty, M.empty, False) -- unsolvable
  CAnnotatedType_TimesC (AnnotatedType_TyVar a) an f@(AnnotatedType_TyFunc{}) -> (fresh, mempty, M.singleton a f, True)
  CAnnotatedType_TimesC (AnnotatedType_TyVar a) an (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = fromConstraints $  map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_TimesC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.singleton a (AnnotatedType_TyData dn av1 ts), True)
  CAnnotatedType_ConC (AnnotatedType_TyVar _) an (AnnotatedType_TyVar _) -> (fresh, mempty, M.empty, False) -- unsolvable
  CAnnotatedType_ConC (AnnotatedType_TyVar a) an f@(AnnotatedType_TyFunc{}) -> (fresh, mempty, M.singleton a f, True)
  CAnnotatedType_ConC (AnnotatedType_TyVar a) an (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = fromConstraints $  map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_ConC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.singleton a (AnnotatedType_TyData dn av1 ts), True)
  _ -> (fresh, mempty, M.empty, False) -- unsolvable panic $ "solveTyConstr: " ++ show c

equalVars :: [[(Var, AnnVal)]] -> Map Var (Set Var)
equalVars [] = M.empty
equalVars (xs:xss) = {-traceShow "equalvars" $ traceShow (xs,xss) $ traceShowId $ -}M.unionWith S.intersection toM $ equalVars xss
  where 
    toM :: Map Var (Set Var)
    toM = toM2 $ map snd $ M.toList $ revMap $ M.fromList xs
    toM2 :: [Set Var] -> Map Var (Set Var)
    toM2 [] = M.empty
    toM2 (y:ys) = M.union (toM2 ys) $ M.fromList $ map (\v -> (v,y)) $ S.toList y

toSol :: Set Var -> [(Var, Set Var)] -> Map Var Annotation
toSol _ [] = M.empty
toSol s ((v,sv):xs) 
  | v `S.member` s = toSol s xs
  | otherwise = M.union (f $ S.toList sv) $ toSol (S.union s sv) xs
  where f :: [Var] -> Map Var Annotation
        f [] = M.empty
        f (y:ys) = M.insert y (Annotation_AnnVar v) $ f ys

revMap :: (Ord a, Ord b) => Map a b -> Map b (Set a)
revMap = revMap' . M.toList
  where revMap' [] = M.empty
        revMap' ((k,v):xs) = M.insertWith (S.union) v (S.singleton k) $ revMap' xs

isEmptyScheme :: TyScheme -> Bool
isEmptyScheme (TyScheme_SForAll ts as cs _) = S.null ts && S.null as && null cs
isEmptyScheme _ = False

solveTySchemeConstraint :: Var -> CTyScheme -> (Var, GatherConstraints, SchemeSol)
solveTySchemeConstraint fresh constr ={- traceShow "solve scheme" $ -}case constr of
  -- Monomorphic solving
  CTyScheme_EqC s1@(TyScheme_SForAll _ _ _ t1) s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s1 && isEmptyScheme s2
      -> traceShow "solve eq simple" $ (fresh, singleton $ Constraint_TyC $ CAnnotatedType_EqC t1 t2, M.empty)
  CTyScheme_PlusC s@(TyScheme_SForAll _ _ _ t) s1@(TyScheme_SForAll _ _ _ t1) s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s1 && isEmptyScheme s2
      -> traceShow "solve plus simple" $ (fresh, singleton $ Constraint_TyC $ CAnnotatedType_PlusC t t1 t2, M.empty)
  CTyScheme_UnionC s@(TyScheme_SForAll _ _ _ t) s1@(TyScheme_SForAll _ _ _ t1) s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s1 && isEmptyScheme s2
      -> traceShow "solve union simple" $ (fresh, singleton $ Constraint_TyC $ CAnnotatedType_UnionC t t1 t2, M.empty)
  CTyScheme_TimesC s@(TyScheme_SForAll _ _ _ t) a s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s2
      -> traceShow "solve times simple" $ (fresh, singleton $ Constraint_TyC $ CAnnotatedType_TimesC t a t2, M.empty)
  CTyScheme_ConC s@(TyScheme_SForAll _ _ _ t) a s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s2
      -> traceShow "solve con simple" $ (fresh, singleton $ Constraint_TyC $ CAnnotatedType_ConC t a t2, M.empty)
  -- polymorphic solving
  CTyScheme_EqC s (TyScheme_SchemeVar v)
    -> traceShow "solve eq 2: " (fresh, mempty, M.singleton v s)
  CTyScheme_EqC (TyScheme_SchemeVar v) s
    -> traceShow "solve eq 1" $ (fresh, mempty, M.singleton v s)
  CTyScheme_PlusC s@(TyScheme_SForAll ts as c1 t) (TyScheme_SchemeVar v1) (TyScheme_SchemeVar v2)
    -> traceShow "solve plus" $ let 
      fresh' = fresh + 2
      t1 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ fresh + 1)
      c2 = [Constraint_TyC $ CAnnotatedType_PlusC t t1 t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = toConstraints $ notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v1a', v1t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t1) nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v1 (TyScheme_SForAll (S.union ts $ v1t' S.\\ vt) (S.union as $ v1a' S.\\ va) c $ S.substSolution t1 nsol) 
        $ M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', mempty, sol)
  CTyScheme_UnionC s@(TyScheme_SForAll ts as c1 t) (TyScheme_SchemeVar v1) (TyScheme_SchemeVar v2)
    -> traceShow "solve union" $ let 
      fresh' = fresh + 2
      t1 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ fresh + 1)
      c2 = [Constraint_TyC $ CAnnotatedType_UnionC t t1 t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = toConstraints $ notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v1a', v1t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t1) nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v1 (TyScheme_SForAll (S.union ts $ v1t' S.\\ vt) (S.union as $ v1a' S.\\ va) c $ S.substSolution t1 nsol) 
        $ M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', mempty, sol)
  CTyScheme_TimesC s@(TyScheme_SForAll ts as c1 t) a (TyScheme_SchemeVar v2)
    -> traceShow "solve times" $ let 
      fresh' = fresh + 1
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      c2 = [Constraint_TyC $ CAnnotatedType_TimesC t a t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = toConstraints $ notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', mempty, sol)
  CTyScheme_ConC s@(TyScheme_SForAll ts as c1 t) a (TyScheme_SchemeVar v2)
    -> traceShow "solve con" $ let 
      fresh' = fresh + 1
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      c2 = [Constraint_TyC $ CAnnotatedType_ConC t a t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = toConstraints $ notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', mempty, sol)
  -- Error
  _ -> panic $ " unsolvable TyScheme constraint: " ++ show constr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% phase 1: solving single iteration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR ALLTYPES Root [ | annPartSol: {AnnPartSol} annSol: {AnnSol} tySol: {TySol} schemeSol: {SchemeSol} | ]
ATTR ALLTYPES [ | newConststraints: {GatherConstraints} | ]

SEM Root
  | Root
    cs.newConststraints = mempty

SEM CAnnotation
  | *
    loc.copy2 = S.substAnn @loc.copy @lhs.annSol
  | * - EqC
    loc.lav = {-traceShow "loc.lav" $-} lookupPartSol @lhs.annPartSol $ E.extractAnnVars @loc.copy2
    loc.fc = {-traceShow "loc.fc" $-} map (\(v,sa) -> map (\x -> (v,x)) $ S.toList sa) $ M.toList @loc.lav
    loc.tl = {-traceShow "loc.tl" $-} sequence @loc.fc
    loc.ch = {-traceShow "loc.ch" $-} M.fromListWith S.union $ map (second S.singleton) $ concat @loc.ch2
    loc.ch2 = {-traceShow "loc.ch2" $-} filter (\xs-> checkConstr $ toGC $ S.substAnn @loc.copy2 (M.map Annotation_AnnVal $ M.fromList xs)) $ @loc.tl
    loc.eqvMap = {-traceShow "loc.eqvMap" $-} toSol S.empty $ M.toList $ equalVars @loc.ch2
    (loc.newSol, loc.newPartSol) = {-traceShow "loc.newSol, loc.newPartSol" $-} M.partition (\x -> S.size x == 1) @loc.ch
    loc.newSol2 = {-traceShow "loc.newSol2" $-} M.union @loc.eqvMap $ M.map (Annotation_AnnVal . S.findMin) @loc.newSol
    lhs.annPartSol = {-traceShow "lhs.annPartSol" $-} M.difference (M.union @loc.newPartSol @lhs.annPartSol) @loc.newSol2
    lhs.annSol = {-traceShow "lhs.annSol" $-} M.union @loc.newSol2 @lhs.annSol
  | EqC
    loc.sol = {-traceShow "loc.sol" $-} case @loc.copy2 of
                CAnnotation_EqC (Annotation_AnnVar v) b -> M.singleton v b
                CAnnotation_EqC b (Annotation_AnnVar v)-> M.singleton v b
                _ -> M.empty
    lhs.annSol = {-traceShow "lhs.annSol" $-} M.union @loc.sol @lhs.annSol


SEM CAnnotatedType
  | *
    loc.subst = {-traceShow "loc.subst" $-} S.substTy @loc.copy @lhs.tySol
    (lhs.freshVar, loc.newCs, loc.tySol, loc.solved) = {-traceShow "lhs.freshVar, loc.newCs,loc.tySol,loc.solved" $-} solveTyConstr @lhs.freshVar @loc.subst 
    lhs.tySol = {-traceShow "lhs.tySol" $-} M.union @lhs.tySol @loc.tySol
    lhs.newConststraints = {-traceShow "lhs.newConststraints" $-} @loc.newCs <> @lhs.newConststraints

SEM CTyScheme
  | *
    loc.canSolve = {-traceShow "loc.canSolve" $-} @lhs.newConststraints == mempty
    (lhs.freshVar, loc.newCs, loc.newSol) = {-traceShow "lhs.freshVar, loc.newCs,loc.newSol" $-} solveTySchemeConstraint @lhs.freshVar @loc.copy
    lhs.newConststraints = {-traceShow "lhs.newConststraints" $-} @loc.newCs <> @lhs.newConststraints
    lhs.schemeSol = {-traceShow ("compute sol", @loc.newSol) $ traceShowId $-} M.union @loc.newSol @lhs.schemeSol

SEM Constraint
  | GenC
    loc.s1 = {-traceShow "solve Gen inner" $ -}solveConstraints' @lhs.freshVar @cs.copy
    loc.sol = {-traceShow "loc.sol" $ -}rootSynSolution @loc.s1
    loc.c2 = {-traceShow "loc.c2" $ -}toConstraints $ notUseFullConstraints_Syn_Root @loc.s1
    lhs.freshVar = {-traceShow "lhs.freshVar" $ -}freshVar_Syn_Root @loc.s1
    loc.s2 = {-traceShow "loc.s2" $-} S.substSolution @s.copy @loc.sol
    loc.e2 = {-traceShow "loc.e2" $-} S.substSolution @e.copy @loc.sol
    loc.t2 = {-traceShow "loc.t2" $-} S.substSolution @t.copy @loc.sol
    (loc.favc2, loc.ftvc2, _) = {-traceShow "loc.favc2,loc.ftvc2" $-} E.extractVars @loc.c2
    (loc.favt2, loc.ftvt2, _) = {-traceShow "loc.fave2,loc.ftvt2" $-} E.extractVars @loc.t2
    (loc.fave2, loc.ftve2, _) = {-traceShow "loc.fave2,loc.ftve2" $-} E.extractVars @loc.e2
    -- extract the single variable from the set
    loc.sv = {-traceShow "loc.sv" $-} S.findMin $ E.extractSchemeVars @loc.s2
    loc.tv = {-traceShow "loc.tv" $-} (S.union @loc.ftvc2 @loc.ftvt2) S.\\ @loc.ftve2
    loc.av = {-traceShow "loc.av" $-} (S.union @loc.favc2 @loc.favt2) S.\\ (S.unions [@loc.fave2, getRhoEtaVars $ toRho @loc.t2, getRhoEtaVars $ toRho @loc.s2])
    lhs.schemeSol = {-traceShow "lhs.schemeSol" $-} M.insert @loc.sv (TyScheme_SForAll @loc.tv @loc.av @loc.c2 $ stripRhoEta $ toRho @loc.t2) @lhs.schemeSol
  | InstC
    loc.s1 = {-traceShow "loc.s1" $-} S.subst @s.copy @lhs.annSol @lhs.tySol @lhs.schemeSol
    loc.t1 = {-traceShow "loc.t1" $-} S.subst @t.copy @lhs.annSol @lhs.tySol @lhs.schemeSol
    (loc.v1t, loc.v1a, loc.genCs, loc.genT) = {-traceShow "loc.v1t,loc.v1a,loc.genCs,loc.genT" $-} case @loc.s1 of 
                                                TyScheme_SForAll ts as cs t -> (ts,as,cs,t)
                                                TyScheme_SchemeVar v -> panic $ "InstC on var: " ++ show v
    loc.sv1t = {-traceShow "loc.sv1t" $-} S.size @loc.v1t
    loc.sv1a = {-traceShow "loc.sv1a" $-} S.size @loc.v1a
    loc.v2t = {-traceShow "loc.v2t" $-} map (\x -> AnnotatedType_TyVar $ mkHNm $ "CA" ++ show x) [@lhs.freshVar .. @lhs.freshVar + @loc.sv1t - 1]
    loc.v2a = {-traceShow "loc.v2a" $-} map Annotation_AnnVar [@lhs.freshVar + @loc.sv1t .. @lhs.freshVar + @loc.sv1t + @loc.sv1a - 1]
    lhs.freshVar = {-traceShow "lhs.freshVar" $-} @lhs.freshVar + @loc.sv1t + @loc.sv1t
    loc.subt = {-traceShow "loc.subt" $-} M.fromList $ zip (S.toList @loc.v1t) @loc.v2t
    loc.suba = {-traceShow "loc.suba" $-} M.fromList $ zip (S.toList @loc.v1a) @loc.v2a
    loc.newCs = {-traceShow "loc.newCs" $-} fromConstraints $ S.subst @loc.genCs @loc.suba @loc.subt M.empty
    loc.newt = {-traceShow "loc.newt" $-} S.subst @loc.genT @loc.suba @loc.subt M.empty
    lhs.newConststraints = {-traceShow "instC" $-} @loc.newCs <> @lhs.newConststraints
    -- extract the single variable from the set
    loc.tv = {-traceShow "loc.tv" $-} S.findMin $ E.extractTyVars @loc.t1
    lhs.tySol = {-traceShow "lhs.tySol" $-} M.insert @loc.tv @loc.newt @lhs.tySol

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% phase 2: substitute solution, remove solved constraints, find new usefull constraints to solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR ALLTYPES Root Phase2Root [ | | useFullConstraints USE {(<>)} {mempty}: {GatherConstraints} notUseFullConstraints USE {(<>)} {mempty}: {GatherConstraints} ]
ATTR ALLTYPES Phase2Root [ changedAnnVars: {Set Var} changedTyVars: {Set HsName} changedSchemeVars: {Set SchemeVar} | | ]
ATTR ALLTYPES Phase2Root [ finalAnnSol: {AnnSol} finalAnnPartSol: {AnnPartSol}  finalTySol: {TySol} finalSchemeSol: {SchemeSol} | | ]
ATTR ALLTYPES [ solving: Bool | | ]

SEM Root
  | Root
    loc.annSolChanges = {-traceShow "loc.annSolChanges" $-} M.keysSet @cs.annSol S.\\ M.keysSet @lhs.annSol
    loc.annPartSolChanges = {-traceShow "loc.annPartSolChanges" $-} M.keysSet $ M.filterWithKey (\k v -> Just v /= M.lookup k @lhs.annSol) @cs.annSol
     cs.changedAnnVars = {-traceShow "cs.changedAnnVars" $-} S.union @loc.annSolChanges @loc.annPartSolChanges
     cs.changedTyVars = {-traceShow "cs.changedTyVars" $-} M.keysSet @cs.tySol S.\\ M.keysSet @lhs.tySol
     cs.changedSchemeVars = {-traceShow "cs.changedSchemeVars" $-} M.keysSet @cs.schemeSol S.\\ M.keysSet @lhs.schemeSol
     cs.finalAnnSol = {-traceShow "cs.finalAnnSol" $-} @cs.annSol
     cs.finalAnnPartSol = {-traceShow "cs.finalAnnPartSol" $-} @cs.annPartSol
     cs.finalTySol = {-traceShow "cs.finalTySol" $-} @cs.tySol
     cs.finalSchemeSol = {-traceShow "cs.finalSchemeSol" $-} @cs.schemeSol
     cs.solving = True

SEM Phase2Root
  | Phase2Root
    cs.annPartSol = M.empty
    cs.annSol = M.empty
    cs.freshVar = -1
    cs.newConststraints = mempty
    cs.schemeSol = M.empty
    cs.solving = False
    cs.tySol = M.empty

SEM ALLTYPES
  | *
    loc.finalSubst = {-traceShow "loc.finalSubst" $-}  S.subst @loc.copy @lhs.finalAnnSol @lhs.finalTySol @lhs.finalSchemeSol

SEM CAnnotation
  | * - EqC
    loc.fav = {-traceShow "loc.fav" $-} E.extractAnnVars @loc.finalSubst
    loc.sfav = {-traceShow "loc.sfav" $-} S.size @loc.fav
    loc.solved = {-traceShow "loc.solved" $-} @loc.sfav == 0 || (@loc.sfav == 1 && @loc.isTopAnn)
    loc.isTopAnn = {-traceShow "loc.isTopAnn" $-} topAnn == (snd $ M.findMin $ lookupPartSol @lhs.finalAnnPartSol @loc.fav)
    (lhs.useFullConstraints, lhs.notUseFullConstraints) = {-traceShow "lhs.useFullConstraints, lhs.notUseFullConstraints" $-} 
                                                            if @loc.solved then (mempty,mempty) else
                                                              if S.null (S.intersection @loc.fav @lhs.changedAnnVars) then
                                                              (mempty, singleton $ Constraint_AnnC @loc.finalSubst) else (singleton $ Constraint_AnnC @loc.finalSubst,mempty)

SEM CAnnotatedType
  | *
    loc.ftv = {-traceShow "loc.ftv" $-} E.extractTyVars @loc.finalSubst
    (lhs.useFullConstraints, lhs.notUseFullConstraints) = {-traceShow "lhs.useFullConstraints, lhs.notUseFullConstraints" $-} 
                                                            if (@lhs.solving && @loc.solved) then (mempty,mempty) else
                                                              if S.null (S.intersection @loc.ftv @lhs.changedTyVars) then
                                                              (mempty, singleton $ Constraint_TyC @loc.finalSubst) else (singleton $ Constraint_TyC @loc.finalSubst, mempty)

SEM CTyScheme
  | *
    loc.fsv = {-traceShow "loc.fsv" $-} E.extractSchemeVars @loc.finalSubst
    lhs.useFullConstraints = {-traceShow "lhs.useFullConstraints" $-} if @loc.canSolve then mempty else singleton $ Constraint_SchemeC @loc.finalSubst
%%]