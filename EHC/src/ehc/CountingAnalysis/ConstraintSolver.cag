%%[(8 counting) hs module {%{EH}CountingAnalysis.ConstraintSolver} import(Data.Maybe,Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M, qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName, mkHNm)})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ConstraintGeneration},{%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.Substitution} as S)
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.ExtractVar} as E)
%%]

%%[(8 counting) hs import(UHC.Util.Utils (panic))
%%]

%%[(8 counting) hs import(Data.Proxy (Proxy))
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting) hs import (Data.Dequeue (BankersDequeue), qualified Data.Dequeue as Q, qualified Data.Foldable as F)
%%]

%%[(8 counting) hs import (Control.Arrow (second))
%%]

%%[(8 counting) hs import (Data.Monoid ((<>)))
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn})
WRAPPER Root Phase2Root
%%]

%%[(8 counting) hs export(solveConstraints)

solveConstraints :: Var -> Constraints -> Solution
solveConstraints v = rootSynSolution . solveConstraints' v

rootSynSolution :: Syn_Root -> Solution
rootSynSolution t = 
  Solution
    { annSol = annSol_Syn_Root t
    , tySol = tySol_Syn_Root t
    , schemeSol = schemeSol_Syn_Root t
    }

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% fix point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs

solveConstraints' :: Var -> Constraints -> Syn_Root
solveConstraints' v cs = solveConstraintsFix $ Syn_Root
  { annPartSol_Syn_Root = M.empty
  , annSol_Syn_Root = M.empty
  , freshVar_Syn_Root = v
  , notUseFullConstraints_Syn_Root = []
  , schemeSol_Syn_Root = M.empty
  , tySol_Syn_Root = M.empty
  , useFullConstraints_Syn_Root = cs
  }

solveConstraintsFix :: Syn_Root -> Syn_Root
solveConstraintsFix syn = if finished then finalSyn else solveConstraintsFix finalSyn
  where (nc, sc, ic) = splitConstraints $ useFullConstraints_Syn_Root syn
        (bc, tc) | nc /= [] = (nc, sc ++ ic)
                 | sc /= [] = (sc, ic)
                 | otherwise = (ic, [])
        syn' = syn {useFullConstraints_Syn_Root = bc}
        resSyn = singleSolveRun syn'
        phase2Syn = getUseFullConstraints syn $ resSyn {notUseFullConstraints_Syn_Root = notUseFullConstraints_Syn_Root syn}
        useFull = useFullConstraints_Syn_Root resSyn ++ useFullConstraints_Syn_Phase2Root phase2Syn ++ tc
        notUseFull = notUseFullConstraints_Syn_Root syn ++ notUseFullConstraints_Syn_Phase2Root phase2Syn
        finalSyn = resSyn { useFullConstraints_Syn_Root = useFull, notUseFullConstraints_Syn_Root = notUseFull}
        finished = useFull == [] || rootSynSolution syn == rootSynSolution finalSyn

-- old syn, new syn
getUseFullConstraints :: Syn_Root -> Syn_Root -> Syn_Phase2Root
getUseFullConstraints old syn = wrap_Phase2Root (sem_Phase2Root (Phase2Root_Phase2Root $ notUseFullConstraints_Syn_Root syn)) 
  (Inh_Phase2Root 
    { changedSchemeVars_Inh_Phase2Root = M.keysSet (schemeSol_Syn_Root syn) S.\\ M.keysSet (schemeSol_Syn_Root old)
    , changedTyVars_Inh_Phase2Root = M.keysSet (tySol_Syn_Root syn) S.\\ M.keysSet (tySol_Syn_Root old)
    , changedAnnVars_Inh_Phase2Root = S.union annSolChanges annPartSolChanges
    , finalAnnPartSol_Inh_Phase2Root = annPartSol_Syn_Root syn
    , finalAnnSol_Inh_Phase2Root = annSol_Syn_Root syn
    , finalSchemeSol_Inh_Phase2Root = schemeSol_Syn_Root syn
    , finalTySol_Inh_Phase2Root = tySol_Syn_Root syn
    })
  where annSolChanges = M.keysSet (annSol_Syn_Root syn) S.\\ M.keysSet (annSol_Syn_Root old)
        annPartSolChanges = M.keysSet $ M.filterWithKey (\k v -> Just v /= M.lookup k (annSol_Syn_Root old)) (annSol_Syn_Root syn)
    

-- (normal constraints, scheme constraints, instantiation constraints
splitConstraints :: Constraints -> (Constraints, Constraints, Constraints)
splitConstraints [] = mempty
splitConstraints (c:cs) = case c of
  Constraint_SchemeC _ -> (nc, c:sc, ic)
  Constraint_InstC{} -> (nc, sc, c:ic)
  _ -> (c:nc,sc,ic)
  where (nc, sc, ic) = splitConstraints cs

singleSolveRun :: Syn_Root -> Syn_Root
singleSolveRun syn = wrap_Root (sem_Root (Root_Root $ useFullConstraints_Syn_Root syn)) 
  (Inh_Root 
    { freshVar_Inh_Root = freshVar_Syn_Root syn 
    , annPartSol_Inh_Root = annPartSol_Syn_Root syn
    , annSol_Inh_Root = annSol_Syn_Root syn
    , tySol_Inh_Root = tySol_Syn_Root syn
    , schemeSol_Inh_Root = schemeSol_Syn_Root syn
    })

%%]

%%[(8 counting) ag

SEM Root
  | Root
    lhs.useFullConstraints = @cs.useFullConstraints ++ @cs.newConststraints

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% general
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR ALLTYPES Root [ | freshVar: Var | ]
ATTR ALLTYPES [ | | copy: SELF]

%%]

%%[(8 counting) hs

getRhoEtaVars :: Rho a -> Set Var
getRhoEtaVars (Rho a b) = S.union (getEtaVar a) $ case b of
  Annotation_AnnVar v -> S.singleton v
  _ -> S.empty

getEtaVar :: Eta a -> Set Var
getEtaVar (Eta _ (Annotation_AnnVar v)) = S.singleton v
getEtaVar _ = S.empty

filterMap :: Ord a => Map a b -> Set a -> Map a b
filterMap m s = M.filterWithKey (\k _ -> k `S.member` s) m

lookupPartSol :: AnnPartSol -> Set Var -> AnnPartSol
lookupPartSol m s = filterMap (M.union m $ M.fromList $ map (,topAnn) $ S.toList s) s

checkConstr :: (Eq a, Compute a) => C a -> Bool
checkConstr (EqC a b) = a == b
checkConstr (PlusC a b c) = simpleCompute computeAdd a b == Just c
checkConstr (UnionC a b c) = simpleCompute computeUnion a b == Just c
checkConstr (TimesC a b c) = simpleCompute computeTimes b a == Just c
checkConstr (ConC a b c) = simpleCompute computeCon b a == Just c

topAnn :: Set AnnVal
topAnn = annPowWithoutEmpty annTop'

solveTyConstr :: Var -> CAnnotatedType -> (Var, Constraints, TySol, Bool)
solveTyConstr fresh c = case c of
  CAnnotatedType_EqC (AnnotatedType_TyVar a) v@(AnnotatedType_TyVar _) -> (fresh, [], M.singleton a v, True)
  CAnnotatedType_EqC (AnnotatedType_TyVar a) f@(AnnotatedType_TyFunc{}) -> (fresh, [], M.singleton a f, True)
  CAnnotatedType_EqC (AnnotatedType_TyVar a) d@(AnnotatedType_TyData{}) -> (fresh, [], M.singleton a d, True)
  CAnnotatedType_EqC a v@(AnnotatedType_TyVar _) -> solveTyConstr fresh $ CAnnotatedType_EqC v a
  CAnnotatedType_PlusC (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) -> (fresh, [], M.empty, False) -- unsolvable
  CAnnotatedType_PlusC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) f@(AnnotatedType_TyFunc{}) -> (fresh, [], M.fromList [(a, f), (b, f)], True)
  CAnnotatedType_PlusC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_PlusC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.fromList [(a, AnnotatedType_TyData dn av1 ts), (b, AnnotatedType_TyData dn av2 ts)], True)
  CAnnotatedType_PlusC v1@(AnnotatedType_TyVar _) a v2@(AnnotatedType_TyVar _) -> solveTyConstr fresh $ CAnnotatedType_PlusC v1 v2 a
  CAnnotatedType_UnionC (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) (AnnotatedType_TyVar _) -> (fresh, [], M.empty, False) -- unsolvable
  CAnnotatedType_UnionC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) f@(AnnotatedType_TyFunc{}) -> (fresh, [], M.fromList [(a, f), (b, f)], True)
  CAnnotatedType_UnionC (AnnotatedType_TyVar a) (AnnotatedType_TyVar b) (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_UnionC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.fromList [(a, AnnotatedType_TyData dn av1 ts), (b, AnnotatedType_TyData dn av2 ts)], True)
  CAnnotatedType_UnionC v1@(AnnotatedType_TyVar _) a v2@(AnnotatedType_TyVar _) -> solveTyConstr fresh $ CAnnotatedType_UnionC v1 v2 a
  CAnnotatedType_TimesC (AnnotatedType_TyVar _) an (AnnotatedType_TyVar _) -> (fresh, [], M.empty, False) -- unsolvable
  CAnnotatedType_TimesC (AnnotatedType_TyVar a) an f@(AnnotatedType_TyFunc{}) -> (fresh, [], M.singleton a f, True)
  CAnnotatedType_TimesC (AnnotatedType_TyVar a) an (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_TimesC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.singleton a (AnnotatedType_TyData dn av1 ts), True)
  CAnnotatedType_ConC (AnnotatedType_TyVar _) an (AnnotatedType_TyVar _) -> (fresh, [], M.empty, False) -- unsolvable
  CAnnotatedType_ConC (AnnotatedType_TyVar a) an f@(AnnotatedType_TyFunc{}) -> (fresh, [], M.singleton a f, True)
  CAnnotatedType_ConC (AnnotatedType_TyVar a) an (AnnotatedType_TyData dn as ts) -> let
    n = length as
    av = [fresh .. fresh + n - 1]
    av1 = map Annotation_AnnVar av
    av2 = map (Annotation_AnnVar  . (+n)) av
    cs = map (\(x,y,z) -> Constraint_AnnC $ CAnnotation_ConC x y z) $ zip3 av1 av2 as
    in (fresh + 2*n, cs, M.singleton a (AnnotatedType_TyData dn av1 ts), True)
  _ -> (fresh, [], M.empty, False) -- unsolvable panic $ "solveTyConstr: " ++ show c

equalVars :: [[(Var, AnnVal)]] -> Map Var (Set Var)
equalVars [] = M.empty
equalVars (xs:xss) = M.unionWith S.intersection toM $ equalVars xss
  where 
    toM :: Map Var (Set Var)
    toM = toM2 $ map snd $ M.toList $ revMap $ M.fromList xs
    toM2 :: [Set Var] -> Map Var (Set Var)
    toM2 [] = M.empty
    toM2 (y:ys) = M.union (toM2 ys) $ M.fromList $ map (\v -> (v,y)) $ S.toList y

toSol :: Set Var -> [(Var, Set Var)] -> Map Var Annotation
toSol _ [] = M.empty
toSol s ((v,sv):xs) 
  | v `S.member` s = toSol s xs
  | otherwise = M.union (f $ S.toList sv) $ toSol (S.union s sv) xs
  where f :: [Var] -> Map Var Annotation
        f [] = M.empty
        f (y:ys) = M.insert y (Annotation_AnnVar v) $ f ys

revMap :: (Ord a, Ord b) => Map a b -> Map b (Set a)
revMap = revMap' . M.toList
  where revMap' [] = M.empty
        revMap' ((k,v):xs) = M.insertWith (S.union) v (S.singleton k) $ revMap' xs

isEmptyScheme :: TyScheme -> Bool
isEmptyScheme (TyScheme_SForAll ts as cs _) = S.null ts && S.null as && null cs
isEmptyScheme _ = False

solveTySchemeConstraint :: Var -> CTyScheme -> (Var, Constraints, SchemeSol)
solveTySchemeConstraint fresh constr = case constr of
  -- Monomorphic solving
  CTyScheme_EqC s1@(TyScheme_SForAll _ _ _ t1) s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s1 && isEmptyScheme s2
      -> (fresh, [Constraint_TyC $ CAnnotatedType_EqC t1 t2], M.empty)
  CTyScheme_PlusC s@(TyScheme_SForAll _ _ _ t) s1@(TyScheme_SForAll _ _ _ t1) s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s1 && isEmptyScheme s2
      -> (fresh, [Constraint_TyC $ CAnnotatedType_PlusC t t1 t2], M.empty)
  CTyScheme_UnionC s@(TyScheme_SForAll _ _ _ t) s1@(TyScheme_SForAll _ _ _ t1) s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s1 && isEmptyScheme s2
      -> (fresh, [Constraint_TyC $ CAnnotatedType_UnionC t t1 t2], M.empty)
  CTyScheme_TimesC s@(TyScheme_SForAll _ _ _ t) a s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s2
      -> (fresh, [Constraint_TyC $ CAnnotatedType_TimesC t a t2], M.empty)
  CTyScheme_ConC s@(TyScheme_SForAll _ _ _ t) a s2@(TyScheme_SForAll _ _ _ t2) 
    | isEmptyScheme s && isEmptyScheme s2
      -> (fresh, [Constraint_TyC $ CAnnotatedType_ConC t a t2], M.empty)
  -- polymorphic solving
  CTyScheme_EqC s (TyScheme_SchemeVar v)
    -> (fresh, [], M.singleton v s)
  CTyScheme_PlusC s@(TyScheme_SForAll ts as c1 t) (TyScheme_SchemeVar v1) (TyScheme_SchemeVar v2)
    -> let 
      fresh' = fresh + 2
      t1 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ fresh + 1)
      c2 = [Constraint_TyC $ CAnnotatedType_PlusC t t1 t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v1a', v1t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t1) nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v1 (TyScheme_SForAll (S.union ts $ v1t' S.\\ vt) (S.union as $ v1a' S.\\ va) c $ S.substSolution t1 nsol) 
        $ M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', [], sol)
  CTyScheme_UnionC s@(TyScheme_SForAll ts as c1 t) (TyScheme_SchemeVar v1) (TyScheme_SchemeVar v2)
    -> let 
      fresh' = fresh + 2
      t1 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ (show $ fresh + 1)
      c2 = [Constraint_TyC $ CAnnotatedType_UnionC t t1 t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v1a', v1t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t1) nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v1 (TyScheme_SForAll (S.union ts $ v1t' S.\\ vt) (S.union as $ v1a' S.\\ va) c $ S.substSolution t1 nsol) 
        $ M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', [], sol)
  CTyScheme_TimesC s@(TyScheme_SForAll ts as c1 t) a (TyScheme_SchemeVar v2)
    -> let 
      fresh' = fresh + 1
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      c2 = [Constraint_TyC $ CAnnotatedType_TimesC t a t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', [], sol)
  CTyScheme_ConC s@(TyScheme_SForAll ts as c1 t) a (TyScheme_SchemeVar v2)
    -> let 
      fresh' = fresh + 1
      t2 = AnnotatedType_TyVar $ mkHNm $ "CA" ++ show fresh
      c2 = [Constraint_TyC $ CAnnotatedType_ConC t a t2]
      rootSyn = solveConstraints' fresh' $ c1 ++ c2
      nsol = rootSynSolution rootSyn
      ssol = schemeSol_Syn_Root rootSyn
      c = notUseFullConstraints_Syn_Root rootSyn
      fresh'' = freshVar_Syn_Root rootSyn
      (va, vt, _) = E.extractVars $ S.substSolution s nsol 
      (v2a', v2t', _) = E.extractVars $ S.substSolution (TyScheme_SForAll ts as c t2) nsol 
      sol = M.insert v2 (TyScheme_SForAll (S.union ts $ v2t' S.\\ vt) (S.union as $ v2a' S.\\ va) c $ S.substSolution t2 nsol) ssol
      in (fresh'', [], sol)
  -- Error
  _ -> panic $ " unsolvable TyScheme constraint: " ++ show constr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% phase 1: solving single iteration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR ALLTYPES Root [ | annPartSol: {AnnPartSol} annSol: {AnnSol} tySol: {TySol} schemeSol: {SchemeSol} | ]
ATTR ALLTYPES [ | newConststraints: Constraints | ]

SEM Root
  | Root
    cs.newConststraints = []

SEM CAnnotation
  | *
    loc.copy2 = S.substAnn @loc.copy @lhs.annSol
  | * - EqC
    loc.lav = lookupPartSol @lhs.annPartSol $ E.extractAnnVars @loc.copy2
    loc.fc = map (\(v,sa) -> map (\x -> (v,x)) $ S.toList sa) $ M.toList @loc.lav
    loc.tl = sequence @loc.fc
    loc.ch = M.fromListWith S.union $ map (second S.singleton) $ concat @loc.ch2
    loc.ch2 = filter (\xs-> checkConstr $ toGC $ S.substAnn @loc.copy2 (M.map Annotation_AnnVal $ M.fromList xs)) $ @loc.tl
    loc.eqvMap = toSol S.empty $ M.toList $ equalVars @loc.ch2
    (loc.newSol, loc.newPartSol) = M.partition (\x -> S.size x == 1) @loc.ch
    loc.newSol2 = M.union @loc.eqvMap $ M.map (Annotation_AnnVal . S.findMin) @loc.newSol
    lhs.annPartSol = M.difference (M.union @loc.newPartSol @lhs.annPartSol) @loc.newSol2
    lhs.annSol = M.union @loc.newSol2 @lhs.annSol
  | EqC
    loc.sol = case @loc.copy2 of
                CAnnotation_EqC (Annotation_AnnVar v) b -> M.singleton v b
                CAnnotation_EqC b (Annotation_AnnVar v)-> M.singleton v b
                _ -> M.empty
    lhs.annSol = M.union @loc.sol @lhs.annSol


SEM CAnnotatedType
  | *
    loc.subst = S.substTy @loc.copy @lhs.tySol
    (lhs.freshVar, loc.newCs, loc.tySol, loc.solved) = solveTyConstr @lhs.freshVar @loc.subst 
    lhs.tySol = M.union @lhs.tySol @loc.tySol
    lhs.newConststraints = @loc.newCs ++ @lhs.newConststraints

SEM CTyScheme
  | *
    loc.canSolve = @lhs.newConststraints == []
    (lhs.freshVar, loc.newCs, loc.newSol) = solveTySchemeConstraint @lhs.freshVar @loc.copy
    lhs.newConststraints = @loc.newCs ++ @lhs.newConststraints
    lhs.schemeSol = M.union @loc.newSol @lhs.schemeSol

SEM Constraint
  | GenC
    loc.s1 = solveConstraints' @lhs.freshVar @cs.copy
    loc.sol = rootSynSolution @loc.s1
    loc.c2 = notUseFullConstraints_Syn_Root @loc.s1
    lhs.freshVar = freshVar_Syn_Root @loc.s1
    loc.s2 = S.substSolution @s.copy @loc.sol
    loc.e2 = S.substSolution @e.copy @loc.sol
    loc.t2 = S.substSolution @t.copy @loc.sol
    (loc.favc2, loc.ftvc2, _) = E.extractVars @loc.c2
    (loc.favt2, loc.ftvt2, _) = E.extractVars @loc.t2
    (loc.fave2, loc.ftve2, _) = E.extractVars @loc.e2
    -- extract the single variable from the set
    loc.sv = S.findMin $ E.extractSchemeVars @loc.s2
    loc.tv = (S.union @loc.ftvc2 @loc.ftvt2) S.\\ @loc.ftve2
    loc.av = (S.union @loc.favc2 @loc.favt2) S.\\ (S.unions [@loc.fave2, getRhoEtaVars $ toRho @loc.t2, getRhoEtaVars $ toRho @loc.s2])
    lhs.schemeSol = M.insert @loc.sv (TyScheme_SForAll @loc.tv @loc.av @loc.c2 $ stripRhoEta $ toRho @loc.t2) @lhs.schemeSol
  | InstC
    loc.s1 = S.subst @s.copy @lhs.annSol @lhs.tySol @lhs.schemeSol
    loc.t1 = S.subst @t.copy @lhs.annSol @lhs.tySol @lhs.schemeSol
    (loc.v1t, loc.v1a, loc.genCs, loc.genT) = 
      let TyScheme_SForAll ts as cs t = @loc.s1 in (ts,as,cs,t)
    loc.sv1t = S.size @loc.v1t
    loc.sv1a = S.size @loc.v1a
    loc.v2t = map (\x -> AnnotatedType_TyVar $ mkHNm $ "CA" ++ show x) [@lhs.freshVar .. @lhs.freshVar + @loc.sv1t - 1]
    loc.v2a = map Annotation_AnnVar [@lhs.freshVar + @loc.sv1t .. @lhs.freshVar + @loc.sv1t + @loc.sv1a - 1]
    lhs.freshVar = @lhs.freshVar + @loc.sv1t + @loc.sv1t
    loc.subt = M.fromList $ zip (S.toList @loc.v1t) @loc.v2t
    loc.suba = M.fromList $ zip (S.toList @loc.v1a) @loc.v2a
    loc.newCs = S.subst @loc.genCs @loc.suba @loc.subt M.empty
    loc.newt = S.subst @loc.genT @loc.suba @loc.subt M.empty
    lhs.newConststraints = @loc.newCs ++ @lhs.newConststraints
    -- extract the single variable from the set
    loc.tv = S.findMin $ E.extractTyVars @loc.t1
    lhs.tySol = M.insert @loc.tv @loc.newt @lhs.tySol

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% phase 2: substitute solution, remove solved constraints, find new usefull constraints to solve
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR ALLTYPES Root Phase2Root [ | | useFullConstraints USE {(++)} {[]}: Constraints notUseFullConstraints USE {(++)} {[]}: Constraints ]
ATTR ALLTYPES Phase2Root [ changedAnnVars: {Set Var} changedTyVars: {Set HsName} changedSchemeVars: {Set SchemeVar} | | ]
ATTR ALLTYPES Phase2Root [ finalAnnSol: {AnnSol} finalAnnPartSol: {AnnPartSol}  finalTySol: {TySol} finalSchemeSol: {SchemeSol} | | ]
ATTR ALLTYPES [ solving: Bool | | ]

SEM Root
  | Root
    loc.annSolChanges = M.keysSet @cs.annSol S.\\ M.keysSet @lhs.annSol
    loc.annPartSolChanges = M.keysSet $ M.filterWithKey (\k v -> Just v /= M.lookup k @lhs.annSol) @cs.annSol
     cs.changedAnnVars = S.union @loc.annSolChanges @loc.annPartSolChanges
     cs.changedTyVars = M.keysSet @cs.tySol S.\\ M.keysSet @lhs.tySol
     cs.changedSchemeVars = M.keysSet @cs.schemeSol S.\\ M.keysSet @lhs.schemeSol
     cs.finalAnnSol = @cs.annSol
     cs.finalAnnPartSol = @cs.annPartSol
     cs.finalTySol = @cs.tySol
     cs.finalSchemeSol = @cs.schemeSol
     cs.solving = True

SEM Phase2Root
  | Phase2Root
    cs.annPartSol = M.empty
    cs.annSol = M.empty
    cs.freshVar = -1
    cs.newConststraints = []
    cs.schemeSol = M.empty
    cs.solving = False
    cs.tySol = M.empty

SEM ALLTYPES
  | *
    loc.finalSubst = S.subst @loc.copy @lhs.finalAnnSol @lhs.finalTySol @lhs.finalSchemeSol

SEM CAnnotation
  | * - EqC
    loc.fav = E.extractAnnVars @loc.finalSubst
    loc.sfav = S.size @loc.fav
    loc.solved = @loc.sfav == 0 || (@loc.sfav == 1 && @loc.isTopAnn)
    loc.isTopAnn = topAnn == (snd $ M.findMin $ lookupPartSol @lhs.finalAnnPartSol @loc.fav)
    (lhs.useFullConstraints, lhs.notUseFullConstraints) = 
      if @loc.solved then ([],[]) else
        if S.null (S.intersection @loc.fav @lhs.changedAnnVars) then
        ([],[Constraint_AnnC @loc.finalSubst]) else ([Constraint_AnnC @loc.finalSubst],[])

SEM CAnnotatedType
  | *
    loc.ftv = E.extractTyVars @loc.finalSubst
    (lhs.useFullConstraints, lhs.notUseFullConstraints) = 
      if (@lhs.solving && @loc.solved) then ([],[]) else
        if S.null (S.intersection @loc.ftv @lhs.changedTyVars) then
        ([],[Constraint_TyC @loc.finalSubst]) else ([Constraint_TyC @loc.finalSubst],[])

SEM CTyScheme
  | *
    loc.fsv = E.extractSchemeVars @loc.finalSubst
    lhs.useFullConstraints = if @loc.canSolve then [] else [Constraint_SchemeC @loc.finalSubst]
%%]