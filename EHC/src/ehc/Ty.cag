%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs module {%{EH}Ty} import(EH.Util.Utils,{%{EH}Base.Common}) export(TyAGItf(..), Ty(..), TyL, tyInt, tyChar, mkTyCon)
%%]

%%[1 hs export(tyLHdAndTl, tyArrowArgRes, tyArrowArgsRes, tyArrowArgs, tyArrowRes, tyAppFunArgs, tyProdArgs, tyAppArgs,BndgIdList)
%%]

%%[2 hs import(Data.Map(Map), qualified Data.Map as Map, Data.List(intersect, partition, nub), Data.Maybe, Debug.Trace)
%%]

%%[2 hs export(TyVarId, TyVarIdL, mkTyVar, mkNewTyVar, mkNewUIDTyVarL, mkNewTyVarL, mkTyFreshProd, mkTyFreshProdFrom, tyEnsureNonAny, mkBndgArr, tyExtractBndgs, tyAnnotate, tyOutermostAnn, tyToCoercions, tyGathSums, Constr(..), tyInst, mergeBndgs, singletonBndgs, emptyBndgs, Bndgs, tyVarId, mkBndgAnnArr, bndgIdInst, worklistFix, SolveConstr(..), flatten, solve, tyAnns, mkSacsMap)
%%]

%%[3 hs export(mkTyQu, TyVarCateg(..))
%%]

%%[3 hs import(Data.Maybe) export(tyVar) 
%%]

%%[4 hs export(TyQu(..), tyquExists, tyquIsExists, tyquIsForall, showTyQu)
%%]

%%[4 hs export(tyConNm) 
%%]

%%[4 hs export(tvCatIsFixed) 
%%]

%%[4 hs import(qualified Data.Map as Map) export(TvCatMp)
%%]

%%[4_2 hs export(tyMbQu,tyIsQu,tyIsVar,tyMbVar,tyIsAlts)
%%]

%%[4_2 hs export(TyPlus(..),TyPlusL,tyPlusTy)
%%]

%%[4_2 hs export(TyHardness(..))
%%]

%%[4_2 hs export(TyNeed(..))
%%]

%%[5 hs export(tyString)
%%]

%%[6 hs export(kiStar)
%%]

%%[6_4 hs export(tvIsEx)
%%]

%%[7 hs import(Data.List) export(rowExtCmp,rowLabCmp,tyRowCanonOrder,kiRow,tyRowEmpty,tyRecEmpty,tySumEmpty,tyRowExtr,tyRecExtr,mkTyRow,mkTyRec,mkTySum,mkTyRecExt,tyRowExts)
%%]

%%[7 hs export(tyAppFunArg) 
%%]

%%[8 hs export(tyFloat)
%%]

%%[8 hs export(tyAppFunConNm) 
%%]

%%[8 hs export(tyRecOffset) 
%%]

%%[9 hs export(Pred(..),predNm,predTy,tyPredNm,tyPredMatchNm,predMatchNm,tyPred,tyLImplsPreds,tyArrowImplsRes,tyArrowImplsArgRes,mkTyImpls,mkTyPr,tyPrArrowArgsRes)
%%]

%%[9 hs export(tyRecExts,tyRecRow,tyArrowArity,tyQuant)
%%]

%%[9 hs export(tyImpls,Impls(..),ImplsVarId,mkImplsVar,implsPredsTail,implsPrIds,implsPredsMbTail,tyIsImplsTail,tyImplsPreds)
%%]

%%[9 hs export(TyCtxt(..))
%%]

%%[9 hs export(tyEnsureNonAnyImpl)
%%]

%%[9_1 hs export(TyPlusId)
%%]

%%[9 hs export(PredOcc(..),poId)
%%]

%%[10 hs export(tyExtsOffset)
%%]

%%[99 hs export(tyInteger,tyDouble)
%%]

%%[1 import({Ty/AbsSyn})
DERIVING *     : Show, Eq, Ord
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Misc types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.TyL hs
type TyL        = [Ty]
%%]

%%[2.TyVarId.Base hs
type TyVarId    = UID
%%]

%%[2.TyVarId.Rest hs
type TyVarIdL   = [TyVarId]
%%]

%%[4_2 -1.TyL
%%]

%%[9 hs
type ImplsVarId    = UID
%%]

%%[9_1 hs
type TyPlusId      = UID
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tyvar category
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
tvCatIsFixed :: TyVarCateg -> Bool
tvCatIsFixed TyVarCateg_Plain  = False
tvCatIsFixed _                 = True
%%]

%%[4 hs
type TvCatMp = Map.Map TyVarId TyVarCateg
%%]

%%[6_4 hs
tvIsEx :: TvCatMp -> TyVarId -> Bool
tvIsEx fvM tv = maybe False (== TyVarCateg_Exist) (Map.lookup tv fvM)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Offered or required
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs
data TyNeed
  = TyRequired | TyOffered | TyNoNeed
  deriving (Eq,Ord)

instance Show TyNeed where
  show TyRequired    = "R"
  show TyOffered     = "O"
  show TyNoNeed      = "-"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hardness of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs
data TyHardness
  = TyHard | TySoft TyVarId
  deriving (Eq,Ord)

instance Show TyHardness where
  show TyHard          = "H"
  show (TySoft     i)  = "S" -- "S:" ++ show i
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred occurrence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
data PredOcc
  =  PredOcc
       { poPr               :: Pred
       , poPoi              :: PredOccId
       }
  deriving (Show,Eq)

poId :: PredOcc -> UID
poId = poiId . poPoi
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties of quantifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
tyquIsExists, tyquIsForall :: TyQu -> Bool
%%]

%%[4.tyQuProps hs
tyquIsForall TyQu_Forall              = True
tyquIsForall _                        = False

tyquIsExists TyQu_Exists              = True
tyquIsExists _                        = False
%%]

%%[6.tyQuProps -4.tyQuProps hs
tyquIsForall TyQu_Forall              = True
tyquIsForall TyQu_KiForall            = True
tyquIsForall _                        = False

tyquIsExists TyQu_Exists              = True
tyquIsExists TyQu_KiExists            = True
tyquIsExists _                        = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type quantifier utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
tyquExists, tyquForall :: TyQu -> TyQu
%%]

%%[4.tyquMisc hs
tyquForall   TyQu_Exists              = TyQu_Forall
tyquForall   q                        = q

tyquExists   TyQu_Forall              = TyQu_Exists
tyquExists   q                        = q
%%]

%%[6.tyquMisc -4.tyquMisc hs
tyquForall   TyQu_Exists              = TyQu_Forall
tyquForall   TyQu_KiExists            = TyQu_KiForall
tyquForall   q                        = q

tyquExists   TyQu_Forall              = TyQu_Exists
tyquExists   TyQu_KiForall            = TyQu_KiExists
tyquExists   q                        = q
%%]

%%[showTyQu.4
showTyQu  TyQu_Forall     =  "forall"
showTyQu  TyQu_Exists     =  "exists"
%%]

%%[4.showTyQu hs
%%@showTyQu.4
%%]

%%[6.showTyQu -4.showTyQu hs
%%@showTyQu.4
showTyQu  TyQu_KiForall   =  "Forall"
showTyQu  TyQu_KiExists   =  "Exists"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs
tyIsVar :: Ty -> Bool
tyIsVar = isJust . tyMbVar

tyIsAlts :: Ty -> Bool
tyIsAlts t = case t of {Ty_Alts _ _ -> True; _ -> False}

tyMbQu :: Ty -> Maybe TyQu
tyMbQu t = case t of {Ty_Quant q _ _ -> Just q; _ -> Nothing}

tyIsQu :: Ty -> Bool
tyIsQu = isJust . tyMbQu
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.SemApp hs
instance SemApp Ty where
  semApp         = Ty_App
  semAppTop      = id
  semCon         = (\nm -> Ty_Con nm (error "Need bndgs: tysigs not allowed for uniqueness inference.")) . mkHNm
  semParens      = id
  mkRngCon _     = (\nm -> Ty_Con nm (error "Need bndgs: tysigs not allowed for uniqueness inference.")) . mkHNm
%%]
%%[1.mkRngVar hs
  mkRngVar       = mkRngCon
%%]
%%[3 -1.mkRngVar hs
  mkRngVar _     = panic "Ty:mkRngVar"
%%]
%%[7 hs
  mkProdApp tyL  = mkTyRec (zip positionalFldNames tyL)
%%]

%%[1.mkTyCon hs
mkTyCon :: String -> Ty
mkTyCon n = semCon (HNm n)
%%]

%%[2 hs
mkBndgArr :: TyVarId -> Ty -> Ty -> Ty
mkBndgArr u a r = Ty_App (Ty_App (Ty_Con hsnArrow [mkTyVar u]) a) r

mkBndgAnnArr :: UID -> TyVarId -> Ty -> Ty -> Ty
mkBndgAnnArr u1 u2 a r = Ty_App (Ty_App (Ty_Ann u1 (Ty_Con hsnArrow [mkTyVar u2])) a) r
%%]

%%[2.mkTyVar hs
mkTyVar :: TyVarId -> Ty
mkTyVar tv = Ty_Var tv
%%]

%%[3.mkTyVar -2.mkTyVar hs
mkTyVar :: TyVarId -> Ty
mkTyVar tv = Ty_Var tv TyVarCateg_Plain
%%]

%%[2.NewTyVar hs
mkNewTyVar :: UID -> Ty
mkNewTyVar u = let  (_,v) = mkNewUID u in mkTyVar v
%%]

%%[2.NewTyVarL hs
mkNewUIDTyVarL :: Int -> UID -> ([UID],TyL)
mkNewUIDTyVarL sz u = let vs = mkNewUIDL sz u in (vs,map mkTyVar vs)

mkNewTyVarL :: Int -> UID -> TyL
mkNewTyVarL sz u = snd (mkNewUIDTyVarL sz u)
%%]

%%[2.tyEnsureNonAny hs
tyEnsureNonAny :: UID -> Ty -> Ty
tyEnsureNonAny u t = if t /= Ty_Any then t else mkNewTyVar u
%%]

%%[9.tyEnsureNonAnyImpl hs
tyEnsureNonAnyImpl :: UID -> Ty -> Ty
tyEnsureNonAnyImpl u t
  = if t /= Ty_Any then  t
                   else  let  [i,r] = mkNewUIDL 2 u
                         in   [mkImplsVar i] `mkArrow` mkTyVar r
%%]

%%[3.mkTyQu hs
mkTyQu :: TyVarIdL -> Ty -> Ty
mkTyQu tvL t = foldr (\tv t -> Ty_Quant tv t) t tvL
%%]

%%[4.mkTyQu -3.mkTyQu hs
mkTyQu :: TyQu -> TyVarIdL -> Ty -> Ty
mkTyQu q tvL t = foldr (\tv t -> Ty_Quant q tv t) t tvL
%%]

%%[2.mkTyFreshProd hs
mkTyFreshProdFrom :: UID -> Int -> Ty
mkTyFreshProdFrom uid arity =  mkProdApp . map mkTyVar . mkNewUIDL arity $ uid

mkTyFreshProd :: Int -> Ty
mkTyFreshProd = mkTyFreshProdFrom uidStart
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of implicitly parameterized (or predicated) type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkImplsVar :: ImplsVarId -> Ty
mkImplsVar v = Ty_Impls (Impls_Tail v)
%%]

%%[9 hs
mkTyImpls :: [Pred] -> Ty -> Ty
mkTyImpls prL t = map Ty_Pred prL `mkArrow` t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of pred type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkTyPr :: Pred -> Ty
mkTyPr p
  =  case p of
       Pred_Pred t  -> t
       _            -> Ty_Pred p
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.tyInt hs
tyInt   = Ty_Con hsnInt []
%%]

%%[1.tyChar hs
tyChar  = Ty_Con hsnChar []
%%]

%%[5.tyString hs
tyString :: Ty
tyString  = mkConApp hsnList [tyChar]
%%]

%%[11.tyString -5.tyString hs
tyString :: Ty
tyString  = semCon hsnString
%%]

%%[6 hs
kiStar  = Ty_Con hsnStar
%%]

%%[7 hs
kiRow       = Ty_Con hsnRow
tyRowEmpty  = Ty_Con hsnRowEmpty
tyRecEmpty  = mkTyRec []
tySumEmpty  = mkTySum []
%%]

%%[8 hs
tyFloat     = Ty_Con hsnFloat
%%]

%%[99 hs
tyInteger   = Ty_Con hsnInteger
tyDouble    = Ty_Con hsnDouble
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.unMkTy.sigs.tyArrow hs
tyArrowArgRes   :: Ty -> (Ty,Ty)
%%]

%%[1.unMkTy.sigs.Rest hs
tyArrowArgsRes  :: Ty -> (TyL,Ty)
tyAppFunArgs    :: Ty -> (Ty,TyL)
tyAppArgs       :: Ty -> TyL
tyArrowArgs     :: Ty -> TyL
tyArrowRes      :: Ty -> Ty
tyProdArgs      :: Ty -> TyL
tyLHdAndTl      :: [Ty] -> (Ty,TyL)
%%]

%%[1.unMkTy.tyArrowArgRes hs
tyArrowArgRes t
  =  case t of
       Ty_App (Ty_App (Ty_Con nm _) a) r
         | hsnIsArrow nm  -> (a,r)
       _                  -> (Ty_Any,t)
%%]

%%[1.unMkTy.tyArrowArgsRes hs
tyArrowArgsRes t
  =  case t of
       Ty_App (Ty_App (Ty_Con nm _) a) r
         | hsnIsArrow nm  -> let (as,r') = tyArrowArgsRes r in (a:as,r')
       _                  -> ([],t)
%%]

%%[2 hs
tyExtractBndgs :: Ty -> [TyVarId]
tyExtractBndgs ty
  = case ty of
      Ty_App f _ -> tyExtractBndgs f
      Ty_Var _   -> []
      Ty_Con _  bndgs -> [b | Ty_Var b <- bndgs]

tyVarId :: Ty -> TyVarId
tyVarId (Ty_Var v) = v
tyVarId _  = error "tyVarId: no Ty_Var"
%%]

%%[8.unMkTy.tyArrowArgsRes -1.unMkTy.tyArrowArgsRes hs
tyArrowArgsRes t
  =  case t of
       Ty_Quant _ _ t     -> tyArrowArgsRes t
       Ty_App (Ty_App (Ty_Con nm _) a) r
         | hsnIsArrow nm  -> let (as,r') = tyArrowArgsRes r in (a:as,r')
       _                  -> ([],t)
%%]

%%[1.unMkTy.tyAppFunArgs hs
tyAppFunArgs
  =  extr []
  where  extr as t
           =  case t of
                Ty_App f a  -> extr (a:as) f
                _           -> (t,as)
%%]

%%[6.unMkTy.tyAppFunArgs -1.unMkTy.tyAppFunArgs hs
tyAppFunArgs
  =  extr []
  where  extr as t
           =  case t of
                Ty_Quant _ _ t  -> tyAppFunArgs t
                Ty_App f a      -> extr (a:as) f
                _               -> (t,as)
%%]

%%[1.unMkTy.funs hs
tyArrowArgs  = fst . tyArrowArgsRes
tyArrowRes   = snd . tyArrowArgsRes
tyAppArgs    = snd . tyAppFunArgs
%%]

%%[1.unMkTy.tyProdArgs hs
tyProdArgs   = tyAppArgs
%%]

%%[1.unMkTy.tyLHdAndTl hs
tyLHdAndTl   = hdAndTl' Ty_Any
%%]

%%[4.unMkTy.tyConNm hs
tyConNm :: Ty -> HsName
tyConNm  (Ty_Con nm)  = nm
tyConNm  _            = hsnUnknown
%%]

%%[3.unMkTy.tyMbVar hs
tyMbVar :: Ty -> Maybe TyVarId
tyMbVar t = case t of {Ty_Var v _ -> Just v ; _ -> Nothing}
%%]

%%[3.unMkTy.tyVar hs
tyVar :: Ty -> TyVarId
tyVar = maybe uidStart id . tyMbVar
%%]

%%[4_2.tyPlusTy hs
tyPlusTy :: TyPlus -> Ty
tyPlusTy (TyPlus_Ty t _ _) = t
%%]

%%[9_1.tyPlusTy -4_1.tyPlusTy hs
tyPlusTy :: TyPlus -> Ty
tyPlusTy (TyPlus_Ty t _) = t
%%]

%%[7.unMkTy.tyProdArgs -1.unMkTy.tyProdArgs hs
tyProdArgs ty = let (t,al) = tyRecExts ty in map snd al
%%]

%%[7 hs
tyAppFunArg :: Ty -> (Ty,Ty)
tyAppFunArg t =  case t of {Ty_App f a -> (f,a); _ -> (Ty_Any,Ty_Any)}
%%]

%%[8 hs
tyAppFunConNm :: Ty -> HsName
tyAppFunConNm = tyConNm . fst . tyAppFunArgs
%%]

%%[9 hs
tyQuant :: Ty -> Ty
tyQuant t
  =  case t of
       Ty_Quant _ _ t'  -> tyQuant t'
       _                -> t

tyArrowArity :: Ty -> Int
tyArrowArity = length . tyArrowArgs
%%]

%%[9 hs
tyArrowImplsRes  :: Ty -> (TyL,Ty)
tyArrowImplsRes t
  =  case t of
       (Ty_App (Ty_App (Ty_Con nm) a) r)
         | hsnIsArrow nm && isImpls a
           -> let (as,r') = tyArrowImplsRes r in (a:as,r')
         where  isImpls (Ty_Pred  _)  = True
                isImpls (Ty_Impls _)  = True
                isImpls _             = False
       _                  -> ([],t)

tyArrowImplsArgRes  :: Ty -> (TyL,Ty,Ty)
tyArrowImplsArgRes t
  =  let  (i,t')  = tyArrowImplsRes  t
          (a,r)   = tyArrowArgRes    t'
     in   (i,a,r)

tyLImplsPreds :: TyL -> ([Pred],Impls)
tyLImplsPreds = foldr (\t (ps,i) -> case t of {Ty_Pred p -> (p:ps,i); Ty_Impls i -> (ps,i)}) ([],Impls_Nil)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction for records/variants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7 hs
mkTyRow :: Ty -> AssocL HsName Ty -> Ty
mkTyRow r = foldl (\t (n,e) -> Ty_Ext t n e) r

mkTyRec :: AssocL HsName Ty -> Ty
mkTyRec al = hsnRec `mkConApp` [tyRowEmpty `mkTyRow` al]

mkTyRecExt :: Ty -> AssocL HsName Ty -> Ty
mkTyRecExt rec al
  =  let  (row,exts) = tyRowExts (tyRecRow rec)
     in   hsnRec `mkConApp` [row `mkTyRow` (exts ++ al)]

mkTySum :: AssocL HsName Ty -> Ty
mkTySum al = hsnSum `mkConApp` [tyRowEmpty `mkTyRow` al]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for records
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7 hs
tyRecRow :: Ty -> Ty
tyRecRow t
  =  case tyAppFunArgs t of
       (Ty_Con n,[row]) | hsnIsRec n || hsnIsSum n -> row
       _                                           -> Ty_Any

tyRowExts :: Ty -> (Ty,AssocL HsName Ty)
tyRowExts
  =  extr []
  where  extr as t
           =  case t of
                (Ty_Ext r l e) -> extr ((l,e):as) r
                _              -> (t,as)

tyRecExts :: Ty -> (Ty,AssocL HsName Ty)
tyRecExts t
  =  case tyRecRow t of
       Ty_Any  -> (Ty_Any,[])
       row     -> tyRowExts row

tyRowExtr :: HsName -> Ty -> Maybe (Ty,Ty)
tyRowExtr lbl t
  =  case t of
       (Ty_Ext r l e)   | lbl == l   -> Just (r,e)
                        | otherwise  -> maybe Nothing (\(r',e') -> Just (Ty_Ext r' l e,e')) (tyRowExtr lbl r)
       _                             -> Nothing

tyRecExtr :: HsName -> Ty -> Maybe (Ty,Ty)
tyRecExtr lbl t
  =  case tyRowExtr lbl (tyRecRow t) of
       Nothing    -> Nothing
       Just (r,e) -> Just (hsnRec `mkConApp` [r],e)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Canonical ordering of fields of record
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7 hs
rowLabCmp :: HsName -> HsName -> Ordering
rowLabCmp = compare

rowExtCmp :: (HsName,a) -> (HsName,a) -> Ordering
rowExtCmp (n1,_) (n2,_) = n1 `rowLabCmp` n2

tyRowCanonOrder :: AssocL HsName a -> AssocL HsName a
tyRowCanonOrder = sortBy rowExtCmp
%%]

%%[8 hs
tyExtsOffset :: HsName -> AssocL HsName a -> Int
tyExtsOffset lbl exts
  = find 0 lbl exts
  where find o l (e:es) = case (l,undefined) `rowExtCmp` e of
                            GT -> find (o+1) l es
                            _  -> o
        find o _ []     = o

tyRecOffset :: HsName -> Ty -> Int
tyRecOffset lbl t
  =  let (_,exts) = tyRecExts t
      in tyExtsOffset lbl . tyRowCanonOrder $ exts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
tyPred :: Ty -> Pred
tyPred t
  =  case t of
       Ty_Pred pt  -> pt
       _           -> Pred_Pred t

predNm :: Pred -> HsName
predNm = tyAppFunConNm . predTy

tyPredNm :: Ty -> HsName
tyPredNm = predNm . tyPred

tyPrArrowArgsRes :: Ty -> ([Pred],Pred)
tyPrArrowArgsRes tp = let (tl,t) = tyArrowArgsRes tp in (map tyPred tl, tyPred t)
%%]

%%[9 hs
tyPredMatchNm :: Ty -> HsName
tyPredMatchNm = predMatchNm . tyPred

predMatchNm :: Pred -> HsName
predMatchNm p
  =  case p of
       Pred_Class t    -> tyAppFunConNm t
       Pred_Pred  t    -> predMatchNm . snd . tyPrArrowArgsRes $ t
%%]
%%[10 hs
       Pred_Lacks _ l  -> hsnPrefix "_Lab_" l
%%]

%%[9 hs
predTy :: Pred -> Ty
predTy p
  =  case p of
       Pred_Class t    -> t
       Pred_Pred  t    -> t
%%]
%%[10 hs
       Pred_Lacks t _  -> t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for implicits
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
tyImpls :: Ty -> Impls
tyImpls (Ty_Impls i) = i

implsPredsTail :: Impls -> ([PredOcc],Impls)
implsPredsTail (Impls_Cons v p pv t)  =  let  (p',mi) = implsPredsTail t
                                         in   (PredOcc p pv : p',mi)
implsPredsTail t                      =  ([],t)

implsPredsMbTail :: Impls -> ([PredOcc],Maybe ImplsVarId)
implsPredsMbTail i =  case implsPredsTail i of
                        (i',Impls_Tail v  ) -> (i',Just v)
                        (i',Impls_Nil     ) -> (i',Nothing)

tyImplsPreds :: Ty -> [PredOcc]
tyImplsPreds = fst . implsPredsTail . tyImpls

tyIsImplsTail :: Ty -> Bool
tyIsImplsTail (Ty_Impls (Impls_Tail _))  = True
tyIsImplsTail _                          = False

implsPrIds :: Impls -> [PredOccId]
implsPrIds = map poPoi . fst . implsPredsTail
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
data TyCtxt = TyCtxt_Ty | TyCtxt_Pred | TyCtxt_Class deriving (Show,Eq)
%%]


%%[2 hs
mergeBndgs :: Bndgs -> Bndgs -> Bndgs
mergeBndgs = Map.unionWith (\(a,b) (c,d) -> (a++c,b++d))

singletonBndgs :: UID -> [Ty] -> [Constr] -> Bndgs
singletonBndgs u tps cs = Map.singleton u (tps, cs)

emptyBndgs :: Bndgs
emptyBndgs = Map.empty

tyAnnotate :: Ty -> UID -> (Ty, UID)
tyAnnotate t u
  = case t of
      Ty_App f a -> let (f1, u1) = tyAnnotate f u
                        (a1, u2) = tyAnnotate a u1
                     in (Ty_App f1 a1, u2)
      t1@(Ty_Var _) -> let (u2, u1) = mkNewUID u
                        in (Ty_Ann u1 t1, u2)
      t1@(Ty_Con _ _) -> let (u2, u1) = mkNewUID u
                          in (Ty_Ann u1 t1, u2)

tyOutermostAnn :: Ty -> UID
tyOutermostAnn t
  = case t of
      Ty_App f _ -> tyOutermostAnn f
      Ty_Ann u _ -> u
      _          -> error "tyOutermostAnn: no such outermost ann"

tyAnns :: Ty -> [UID]
tyAnns t
  = case t of
      Ty_App f a -> tyAnns f ++ tyAnns a
      Ty_Ann u _ -> [u]

tyToCoercions :: Ty -> Ty -> [Constr]
tyToCoercions (Ty_App (Ty_App (Ty_Ann u1 (Ty_Con nm1 _)) a1) b1) (Ty_App (Ty_App (Ty_Ann u2 (Ty_Con nm2 _)) a2) b2)
  | nm1 == hsnArrow
      =  [ u1 :=>=: u2 ]
      ++ tyToCoercions a2 a1
      ++ tyToCoercions b1 b2
tyToCoercions (Ty_App f1 a1) (Ty_App f2 a2)
  =  tyToCoercions f1 f2
  ++ tyToCoercions a1 a2
tyToCoercions (Ty_Ann u1 _) (Ty_Ann u2 _)
  = [ u1 :=>=: u2 ]

tyGathSums :: [(HsName, Ty)] -> [(HsName, Ty)] -> ([Constr], [(HsName, Ty)])
tyGathSums pats gats
  = ( [ [tyOutermostAnn t | (n,t) <- gats, n == nm] :<=: tyOutermostAnn ty | (nm, ty) <- pats ]
    , filter (not . (`elem` (map fst pats)) . fst) gats
    )

tyInst :: [(UID,UID)] -> UID -> Ty -> Ty -> Constr
tyInst pairs bndgId tyA tyB
  = Inst pairs bndgId tyA tyB

eqs' tyL ty = concatMap (\t -> eqs t ty) tyL
eqs (Ty_App f1 a1) (Ty_App f2 a2)
  = eqs f1 f2 ++ eqs a1 a2
eqs (Ty_Ann u1 _) (Ty_Ann u2 _)
  = [(u1,u2)] --[(u1,u2),(u2,u1)]
eqs _ _
  = error "tyInst: tycon encountered: type not annotated?"

bndgIdInst :: UID -> Ty -> (Ty, [(Ty, Ty)])
bndgIdInst uid ty
  = let (t, pairs, _) = rec uid ty in (t, pairs)
  where
    rec uid ty
      = case ty of
          Ty_App f a -> let (f1, fp, uid1) = rec uid f
                            (a1, ap, uid2) = rec uid1 a
                         in (f1 `Ty_App` a1, fp ++ ap, uid2)
          Ty_Ann u t -> let (t', p, uid') = rec uid t
                         in (Ty_Ann u t', p, uid')
          Ty_Con nm bndgIds -> let (uid1, uid2) = mkNewLevUID uid
                                   uidL         = mkInfNewUIDL uid2
                                   bndgIds'     = map (Ty_Var) (take (length bndgIds) uidL)
                                   p            = zip bndgIds bndgIds'
                                in (Ty_Con nm bndgIds', p, uid1)
          t@(Ty_Var _) -> (t, [], uid)

%%]

%%[2 hs
data Constr
  = UID :=>=: UID
  | [UID] :<=: UID
  | Inst [(UID, UID)] UID Ty Ty
  deriving (Eq, Ord, Show)

data SolveConstr a
  = a   ::=>=:: a
  | [a] ::<=:: a
  deriving (Eq, Ord, Show)

type Bndgs = Map UID ([Ty], [Constr])

worklistFix :: Eq a => (SolveConstr a -> SolveConstr a) -> a -> [SolveConstr UID] -> Map UID a -> Map UID a
worklistFix solveF bot cs initial
  = iter cs initial
  where
    deps = [ (c, [d | d <- cs, c `shareVar` d, c /= d]) | c <- cs ]

    shareVar p q = shareVarAux2 (shareVarAux1 p) (shareVarAux1 q)
    shareVarAux1 (a ::=>=:: b) = [a, b]
    shareVarAux1 (al ::<=:: b) = b: al
    shareVarAux2 p q = not (null (intersect p q))

    iter [] subst = subst
    iter (c : cs) subst
      =  let  c1      = subst `apply` c
              c2      = solveF c1
              subst'  = (c, c2) `update` subst
         in   if subst' == subst
              then  iter cs subst'
              else  iter ((c `lookup'` deps) ++ cs) subst'

    apply s (a ::=>=:: b)
      = applyAux s a ::=>=:: applyAux s b
    apply s (al ::<=:: b)
      = map (applyAux s) al ::<=:: applyAux s b
    applyAux
      = flip (Map.findWithDefault bot)

    update (ua ::=>=:: ub, a ::=>=:: b) s
      = updateAux ub b (updateAux ua a s)
    update (ual ::<=:: ub, al ::<=:: b) s
      = foldr (uncurry updateAux) (updateAux ub b s) (zip ual al)
    updateAux
      = Map.insert

    lookup' k h = maybe [] id (lookup k h)

upperSolveF (a ::=>=:: b)
  =  a ::=>=:: ((a `max` b) `min` 2)
upperSolveF (l ::<=:: b)
  =  let  z = sum l
     in   l ::<=:: ((b `max` z) `min` 2)

flatten :: Bndgs -> UID -> Map UID [UID] -> [SolveConstr UID]
flatten bndgs outermostId sacreds
  = fst $ construct outermostId [] (uidChild outermostId)
  where
    construct bndgId idMap uid
      = let -- cs = Map.findWithDefault (error ("cannot find cs: " ++ show bndgId ++ " | " ++ show bndgs)) bndgId bndgs
            (mCanonTy, cs)  = Map.findWithDefault ( trace ("no cs info for: " ++ show bndgId) ([], [])) bndgId bndgs
            cs' = rename cs idMap
            (csI, csN) = partition isInst cs'
            csN' = map toSolveConstr csN
            csN'' = foldr (uncurry (instantiate bndgId)) csN' (zip (mkInfNewUIDL uid) csI)
         in (csN'', mCanonTy)

    toSolveConstr (a :=>=: b) = a ::=>=:: b
    toSolveConstr (a :<=: b) = a ::<=:: b

    rename cs idMap
      = map ren cs
      where
        ren (Inst mp bndgId fromTy toTy) = Inst [(renAux a, renAux b) | (a,b) <- mp ] (renAux bndgId) fromTy toTy
        ren c                            = c
        renAux a = maybe a id (a `lookup` idMap)

    insts cs = [c | c <- cs, isInst c]
    isInst (Inst _ _ _ _) = True
    isInst _              = False

    instantiate uid to (Inst idMap from fromTy toTy) dst
      = trace ("inst " ++ show from ++ " ~> " ++ show to ++ " | " ++ show idMap)
      $ let (gUID, lUID) = mkNewLevUID uid
            (src, mCanonTy) = construct from idMap gUID
            src' = fresh (sacred to ++ sacred from) (eqs' (fromTy : mCanonTy) toTy) src lUID
         in dst ++ src'

    -- sacred bndgId = Map.findWithDefault (error ("no sacred anns for binding group: " ++ show bndgId ++ " | " ++ show sacreds)) bndgId sacreds
    sacred bndgId = Map.findWithDefault [] bndgId sacreds

{-
    fresh _ tups src
      = concatMap eqs tups ++ src
      where
        eqs (a, b) = [a ::=>=:: b, b ::=>=:: a]
-}
    fresh sacs tups src uid
      = let uidL  = mkInfNewUIDL uid
            anns (a ::=>=:: b) = [a, b]
            anns (l ::<=:: a)  = a : l
            allAnns = nub (concatMap anns src)
            fsubst = zipWith (\a u -> (a, repl a u)) allAnns uidL
            tups' = map (\(f, t) -> (repl2 f f, repl2 t t)) tups
            src' = map fr src

            fr (a ::=>=:: b) = (repl2 a a) ::=>=:: (repl2 b b)
            fr (l ::<=:: a) = (zipWith repl2 l l) ::<=:: (repl2 a a)

            repl v u
              | v `elem` sacs = v
              | otherwise     = u
            repl2 v u
              | isJust m  = fromJust m
              | otherwise = u
              where
                m = v `lookup` fsubst

            eqs (a, b) = [a ::=>=:: b, b ::=>=:: a]
         in concatMap eqs tups' ++ src'

solve :: Bndgs -> Map UID [UID] -> UID -> UID -> Map UID Int
solve bndgs sacred outerUID startUID
  = let cs = flatten bndgs outerUID sacred
        cs' = seq (length (show cs)) ( trace "flattening complete" cs)
     in  -- error (show sacred)
         worklistFix  upperSolveF 0 cs' $ Map.singleton startUID 1

mkSacsMap :: [(UID, [UID])] -> Map UID [UID]
mkSacsMap = foldr (uncurry (Map.insertWith (++))) Map.empty

%%]

