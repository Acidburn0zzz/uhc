%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let expressions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules, was 1.Let
%%[5.Let
SEM Expr
  | Let         decls       .   patValGam           =   gamPushGam @decls.gathTySigGam @lhs.valGam
                loc         .   (valGam_l_,valGam_g_)
                                                    =   gamPop @decls.patValGam
                decls       .   valGam              =   @decls.patValGam
                body        .   valGam              =   @decls.patValGam
%%]

-- generated from ruler rules into EHRulerRules, was 2.Let
%%[5.Let
SEM Expr
  | Let         decls       .   patTyCnstr          =   @lhs.tyCnstr
                            .   tyCnstr             =   @decls.patTyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 3.Let
%%[5.Let
SEM Expr
  | Let         loc         .   lSubsValGam_        =   @decls.tyCnstr |=> @valGam_l_
                            .   gSubsValGam_        =   @decls.tyCnstr |=> @valGam_g_
                            .   gTyTvL              =   ftv @gSubsValGam_
                            .   quValGam_           =   valGamQuantify @gTyTvL @lSubsValGam
                body        .   valGam              :=  gamPushGam @quValGam_ @gSubsValGam_
%%]

-- generated from ruler rules into EHRulerRules, was 4.Let
%%[5.Let
SEM Expr
  | Let         decls       .   patValGam           :=  gamPushGam  (valGamInst1Exists @lUniq @decls.gathTySigGam)
                                                                    @lhs.valGam
                loc         .   quValGam_ex_        :=  valGamInst1Exists @lUniq2 . valGamQuantify @gTyTvL $ @lSubsValGam_
                            .   quValGam_           :=  emptyGam
                body        .   valGam              :=  gamPushGam @quValGam_ex_ @gSubsValGam_
%%]

%%[4_2 hs
valElimExprAlts :: FIOpts -> FIEnv -> TyVarIdL -> UID -> Cnstr -> ValGam -> (ValGam,Cnstr,ErrGam)
valElimExprAlts fio fe globTvL u c g
  = (g',c'',eg)
  where  (g',c',eg) = valGamElimAlts fio fe globTvL u c g
         c'' = cnstrDelAlphaRename c'
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.Let
%%[90.Let
SEM Expr
  | Let         decls       .   tySigTyCnstr        =   emptyCnstr
                loc         .   (_,lExSigTyCnstr)   =   valGamInst1ExistsWithCnstr @decls.tySigTyCnstr @lUniq @decls.gathTySigGam
                            .   lExplTyCnstr        =   @lExSigTyCnstr |=> @decls.tySigTyCnstr
                decls       .   patValGam           :=  gamPushGam @decls.gathTySigGam @lhs.valGam
                            .   patTyCnstr          :=  @lExplTyCnstr
                            .   imprTyCnstr         =   @decls.patTyCnstr |=> @lhs.imprTyCnstr
                loc         .   (_,imprTyCnstr_elim_,_)
                                                    =   valElimExprAlts joinFIOpts @fe (ftv @valGam_g_) @lUniq4 @decls.imprTyCnstr @valGam_l_
                decls       .   tyCnstr             :=  @imprTyCnstr_elim_ |=> @decls.patTyCnstr |=> @lhs.tyCnstr
                loc         .   (quValGam_ex_,lQuTyCnstr)
                                                    :=  let  (g1,c1) = valGamQuantifyWithCnstr @decls.tyCnstr @gTyTvL @valGam_l_
                                                             (g2,c2) = valGamInst1ExistsWithCnstr (c1 |=> @decls.tyCnstr) @lUniq2 g1
                                                        in   (g2,c2 |=> c1)
                body        .   imprTyCnstr         =   @imprTyCnstr_elim_ |=> @decls.imprTyCnstr
                            .   tyCnstr             :=  @lQuTyCnstr |=> @decls.tyCnstr
                            .   valGam              :=  @decls.patValGam
%%]

%%[9
SEM Expr
  | Let         loc         .   (quValGam_ex_,tqoGam)
                                                    :=  let  (vg,tqog) = valGamQuantify @gTyTvL @prfArgPrOccL @lSubsValGam_
                                                        in   (valGamInst1Exists @lUniq2 vg,tqog)
                            .   tqoTyCnstr          =   foldr (\tqo c -> tqoImplsCnstr tqo |=> c) emptyCnstr (gamElts @tqoGam)
%%]

%%[50
%%]
SEM Expr
  | Let         loc         .   lElimEqualValGam    =   valGamElimEqual (@decls.tyCnstr |=> @valGam_l_)
                            .   lSubsValGam_        :=  @lElimEqualValGam

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known type and instantiation required
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules, was 1.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         loc         .   knTy                =   @ty_sig_
%%]

-- generated from ruler rules into EHRulerRules, was 2.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         expr        .   knTy                =   if @hasTySig then @knTy else @patExpr.ty
%%]

-- generated from ruler rules into EHRulerRules, was 3.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         loc         .   knTy                :=  tyInstKnown @lUniq @ty_sig_
%%]

-- generated from ruler rules into EHRulerRules, was 4.tyInstKnown
%%[5.tyInstKnown
SEM Decl
  | Val         loc         .   knTy                :=  @ty_sig_
%%]

%%[9.tyInstKnown
%%]

SEM Decl
  | Val         expr        .   knTy                :=  if @hasTySig  then @knTy
                                                                      else [mkImplsVar @lUniq2] `mkArrow` @patExpr.ty

%%[10.tyInstKnown
SEM Decl
  | DynVal      loc         .   knTy                =   Ty_Any
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Final type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[2.finValGam
ATTR AllDecl [ finValGam: ValGam | | ]
ATTR AllNT [ finTyCnstr: Cnstr | | ]

SEM Expr
  | Let         loc         .   finValGamDecls      =   @lhs.finTyCnstr |=> (gamTop @decls.patValGam)
                decls       .   finValGam           =   @finValGamDecls

SEM Decl
  | TySig       loc         .   finalTy             =   vgiTy . fromJust
                                                        . valGamLookup @nm $ @lhs.finValGam

SEM AGItf
  | AGItf       expr        .   finTyCnstr          =   @expr.tyCnstr
%%]

%%[3.finValGam
SEM Expr
  | Let         loc         .   finValGamDecls      :=  @lhs.finTyCnstr |=> @quValGam_
%%]

%%[4.finValGam
SEM Expr
  | Let         loc         .   finValGamDecls      :=  @lhs.finTyCnstr |=> @quValGam_ex_
%%]

%%[9
SEM Expr
  | Let         loc         .   finTyCnstr          =   @tqoTyCnstr |=> @lhs.finTyCnstr
%%]

%%[10
SEM Decl
  | DynTySig    loc         .   finalTy             =   vgiTy . fromJust
                                                        . valGamLookup @nm $ @lhs.finValGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known kind
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6
SEM Decl
  | Data        loc         .   knKi                =   @sigKi
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type inferencing, decls, top level, abstraction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.valGam
ATTR AllDecl AllExpr [ valGam: ValGam | | ]
%%]

%%[1.initValGam
SEM AGItf
  | AGItf       expr        .   valGam              =   gamFromAssocL [(HNm "plus", ValGamInfo { vgiTy = @loc.plusTy})]
%%]

%%[12 -1.initValGam
ATTR AGItf [ valGam: ValGam | | ]
%%]

%%[1.patValGam
ATTR AllDecl [ | patValGam: ValGam | ]
%%]

%%[2
ATTR AllDecl AllExpr [ bndgGam: ValGam ||]
ATTR AllDecl AllExpr [ annGam:  ValGam ||]
ATTR AllDecl AllPatExpr [|| annGamCol USE {`gamAddGam`} {emptyGam}: ValGam ]

SEM AGItf
  | AGItf  expr.bndgGam = trace ("initial: " ++ show @loc.initialBndgId)
                           $ gamFromAssocL [(HNm "plus", ValGamInfo { vgiTy = Ty_Var @loc.initialBndgId })]
           expr.annGam  = gamFromAssocL [(HNm "plus", ValGamInfo { vgiTy = @loc.plusAnnTy })]
           loc.plusTy   = Ty_App (Ty_App (Ty_Con hsnArrow [Ty_Var @loc.beta1]) (Ty_Con hsnInt [])) @loc.plusAux
           loc.plusAux  = Ty_App (Ty_App (Ty_Con hsnArrow [Ty_Var @loc.beta2]) (Ty_Con hsnInt [])) (Ty_Con hsnInt [])
           loc.plusAnnTy   = Ty_App (Ty_App (Ty_Ann @loc.delta1 (Ty_Con hsnArrow [Ty_Var @loc.beta1])) (Ty_Ann @loc.delta2 (Ty_Con hsnInt []))) @loc.plusAnnAux
           loc.plusAnnAux  = Ty_App (Ty_App (Ty_Ann @loc.delta3 (Ty_Con hsnArrow [Ty_Var @loc.beta2])) (Ty_Ann @loc.delta4 (Ty_Con hsnInt []))) (Ty_Ann @loc.delta5 (Ty_Con hsnInt []))


ATTR AllDecl [|| bndgGamCol USE {`gamAddGam`} {emptyGam}: ValGam ]

ATTR AllPatExpr [| valGam2 : ValGam |]
SEM Expr
  | Lam  arg.valGam2 = emptyGam
SEM PatExpr
  | Var  lhs.valGam2 = gamAdd @nm undefined @lhs.valGam2
SEM Decl
  | Val patExpr.valGam2 = emptyGam


ATTR AllDecl AllExpr [|| bndgs USE {`mergeBndgs`} {emptyBndgs}: Bndgs uses USE {++} {[]}: {[(HsName,Ty)]} cs USE {++} {[]}: {[Constr]} ]
ATTR AllPatExpr AllDecl  [|| defs USE {++} {[]}: {[(HsName,Ty)]} ]
ATTR AllExpr [|| annTy : Ty ]

ATTR AllPatExpr [ annTyIn : Ty ||]
SEM PatExpr
  | App  (func.annTyIn, arg.annTyIn) = let (Ty_App f a) = @lhs.annTyIn
                                       in (f, a)
  | Var  lhs.defs = [(@nm, @lhs.annTyIn)]
         lhs.annGamCol = gamUnit @nm (ValGamInfo { vgiTy = @lhs.annTyIn })
SEM Expr
  | Lam  arg.annTyIn = @loc.ty_p_in_
         (loc.sumCs, lhs.uses) = tyGathSums @arg.defs @body.uses
         loc.annGam = @arg.annGamCol `gamAddGam` @lhs.annGam
  | Let  (loc.sumCs, loc.declUses) = tyGathSums @decls.defs (@decls.uses ++ @body.uses)
         loc.annGam = @decls.annGamCol `gamAddGam` @lhs.annGam
         lhs.uses = @body.uses ++ @loc.declUses
  | Con  lhs.uses = [(@nm, @loc.annTy_)]
  | Var  lhs.uses = [(@nm, @loc.annTy_)]
SEM Decl
  | Val  patExpr.annTyIn = @loc.annTy_fresh_

SEM Expr
  | Var  loc.defBndgTyId = maybe undefined vgiTy (@nm `gamLookup` @lhs.bndgGam )
         loc.defBndgId   = tyVarId (@lhs.finTyCnstr |=> @loc.defBndgTyId)
         loc.defAnnTy    = maybe undefined vgiTy (@nm `gamLookup` @lhs.annGam)
         loc.pairs       = [ let (Ty_Var a) = @lhs.finTyCnstr |=> ta
                                 (Ty_Var b) = @lhs.finTyCnstr |=> tb
                              in (a, b)
                           | (ta,tb) <- @loc.pairs_ ]
         loc.cs = [tyInst @loc.pairs @loc.defBndgId @loc.defAnnTy @loc.annTy_]
  | Con  loc.cs = []
  | App  (loc.annTy, loc.paramTy, loc.finBndgId, loc.spineAnn) = let (Ty_App (Ty_App (Ty_Ann a (Ty_Con _ [Ty_Var b])) p) r) = @func.annTy in (r, p, b, a)
         loc.csParamArg = tyToCoercions @loc.paramTy @arg.annTy
         loc.csFunSpine = [tyOutermostAnn @loc.annTy :=>=: @loc.spineAnn]
         loc.argInst    = [tyInst [] @loc.finBndgId @arg.annTy @paramTy]
         loc.argBndg    = singletonBndgs @loc.finBndgId [@arg.annTy] @arg.cs
         loc.cs         = @loc.csParamArg ++ @loc.csFunSpine ++ @loc.argInst ++ @func.cs
         loc.bndgs      = @loc.argBndg `mergeBndgs` @func.bndgs `mergeBndgs` @arg.bndgs
  | Lam  loc.cs         = @loc.sumCs ++ @arg.cs ++ @body.cs
  | Let  loc.cs         = @loc.sumCs ++ @decls.cs ++ @body.cs

SEM Decl
  | Val  loc.resCs = tyToCoercions @loc.annTy_fresh_ @expr.annTy
         loc.valCs = @loc.resCs ++ @expr.cs
         loc.bndg  = singletonBndgs @loc.bndgId_ [] @loc.valCs
         lhs.bndgs = @loc.bndg `mergeBndgs` @expr.bndgs
         lhs.cs    = @patExpr.cs

ATTR AllExpr AllPatExpr AllDecl [ enclosingAnn : UID ||]
ATTR AllPatExpr [|| cs USE {++} {[]} : {[Constr]} ]

SEM AGItf
  | AGItf  expr.enclosingAnn = error "Enclosing ann of root of the AST used"

SEM Expr
  | Let    loc.enclosingAnn  = tyOutermostAnn @body.annTy
  | Lam    loc.enclosingAnn  = tyOutermostAnn @loc.annTy

SEM PatExpr
  | Con    loc.cs = [@lhs.enclosingAnn :=>=: tyOutermostAnn @lhs.annTyIn]

SEM AGItf
  | AGItf  (loc.lUniq2, loc.initialBndgId, loc.rootBndgId, loc.deltaRoot) = mkNewLevUID3 @loc.lUniq
           loc.cs   = [[@loc.deltaRoot] :<=: tyOutermostAnn @expr.annTy] ++ @expr.cs
           loc.initialCs = [@loc.delta5 :=>=: @loc.delta3, @loc.delta5 :=>=: @loc.delta4]
           loc.bndg = singletonBndgs @loc.rootBndgId [] @loc.cs `mergeBndgs` singletonBndgs @loc.initialBndgId [] @loc.initialCs
           loc.bndgs = @loc.bndg `mergeBndgs` @expr.bndgs

           (loc.lUniq3, loc.delta1, loc.delta2, loc.delta3, loc.delta4) = mkNewLevUID4 @loc.lUniq2
           (loc.lUniq4, loc.delta5, loc.beta1, loc.beta2) = mkNewLevUID3 @loc.lUniq3

ATTR AllDecl AllExpr AllPatExpr [|| sacredAnns USE {++} {[]} : {[(HsName, UID)]} ]
SEM Expr
  | Lam  lhs.sacredAnns = filter (\(n,_) -> not (n `elem` (map fst @arg.sacredAnns))) @body.sacredAnns
  | Var  lhs.sacredAnns = map (\x -> (@nm, x)) (tyAnns @loc.annTy)
  | Con  lhs.sacredAnns = map (\x -> (@nm, x)) (tyAnns @loc.annTy)
  | Let  lhs.sacredAnns = filter (\(n,_) -> not (n `elem` (map fst @decls.sacredAnns))) @body.sacredAnns
SEM PatExpr
  | Var  lhs.sacredAnns = map (\x -> (@nm, x)) (tyAnns @lhs.annTyIn)

ATTR AllDecl AllExpr [ sacredAnnsIn : {[UID]} ||]
SEM AGItf
  | AGItf  expr.sacredAnnsIn = map snd @expr.sacredAnns
SEM Expr
  | Lam  body.sacredAnnsIn = @lhs.sacredAnnsIn ++ map snd @arg.sacredAnns
  | Let  loc.sacredAnnsIn  = @lhs.sacredAnnsIn ++ map snd @decls.sacredAnns

ATTR AllDecl AllExpr [|| sacredAnnsOut USE {++} {[]} : {[(UID,[UID])]}]
SEM Expr
  | App   lhs.sacredAnnsOut = [(@loc.finBndgId, @lhs.sacredAnnsIn)] ++ @func.sacredAnnsOut ++ @arg.sacredAnnsOut
SEM Decl
  | Val   lhs.sacredAnnsOut = [(@loc.bndgId_, @lhs.sacredAnnsIn)] ++ @expr.sacredAnnsOut

SEM AGItf
  | AGItf  loc.sacsForSolver = trace ("initial bndg id: " ++ show @loc.initialBndgId ++", root bndg id: " ++ show @loc.rootBndgId ++ "\n" ++ show @loc.bndgs)
                               $ mkSacsMap ([(@loc.initialBndgId, []), (@loc.rootBndgId, map snd @expr.sacredAnns)]++ @expr.sacredAnnsOut)
           loc.res = solve @loc.bndgs @loc.sacsForSolver @loc.rootBndgId @loc.deltaRoot

%%]

-- generated from ruler rules into EHRulerRules, was 1.patValGam.Val
%%[5.patValGam.Val
SEM Decl
  | Val         patExpr     .   valGam              =   @lhs.patValGam
                lhs         .   patValGam           =   @patExpr.valGam
                expr        .   valGam              =   @lhs.valGam
%%]

%%[2.tyCnstr
ATTR AllDecl [ | tyCnstr: Cnstr  patTyCnstr: Cnstr | ]

SEM AGItf
  | AGItf       expr        .   tyCnstr             =   emptyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 2.tyCnstr.Val
%%[5.tyCnstr.Val
SEM Decl
  | Val         patExpr     .   tyCnstr             =   @lhs.patTyCnstr
                lhs         .   patTyCnstr          =   @patExpr.tyCnstr
                expr        .   tyCnstr             =   @lhs.tyCnstr
%%]

%%[4_2
ATTR AllDecl AllExpr [ | imprTyCnstr: Cnstr | ]

SEM AGItf
  | AGItf       expr        .   imprTyCnstr         =   emptyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.Val
%%[90.Val
SEM Decl
  | Val         loc         .   imprFO              =   fitsIn impredFIOpts @fe uidStart (@expr.imprTyCnstr |=> @patExpr.ty) @expr.imprTy
                lhs         .   imprTyCnstr         =   foCnstr @imprFO |=> @expr.imprTyCnstr
%%]
SEM AGItf
  | AGItf       expr        .   tyCnstr             :=  emptyCnstr

SEM AGItf
  | AGItf       loc         .   (exprTyCnstr1,ambTvS)
                                                    =   cnstrElimForgetAlts @expr.imprTyCnstr
                            .   exprTyCnstr         =   let (eC,(vC,_))
                                                              =  cnstrMapThrTy  (\v t (c,u) ->  let  (u',u1) = mkNewLevUID u
                                                                                                     (t',c') = tyFreshVar (`Set.member` @ambTvS) u1 c t
                                                                                                in   (t',(c',u'))
                                                                                )
                                                                                (emptyCnstr,@lUniq)
                                                                 @exprTyCnstr1
                                                        in  eC
                expr        .   tyCnstr             :=  emptyCnstr

SEM AGItf
  | AGItf       loc         .   (exprTyCnstr1,ambTvS)
                                                    =   cnstrElimForgetAlts @expr.imprTyCnstr
                            .   exprTyCnstr         =   let (eC,(vC,_))
                                                              =  cnstrMapThrTy  (\v t (c,u) ->  let  (u',u1) = mkNewLevUID u
                                                                                                     (t',c') = tyFreshVar (`Set.member` @ambTvS) u1 c t
                                                                                                in   (t',(c',u'))
                                                                                )
                                                                                (emptyCnstr,@lUniq)
                                                                 @exprTyCnstr1
                                                        in  eC
                expr        .   tyCnstr             :=  @exprTyCnstr1

                            .   exprTyCnstr         =   fst
                                                        .  cnstrMapThrTy (\v t u -> let (u',u1) = mkNewLevUID u in (tyFreshVar (const True) u1 t,u')) @lUniq
                                                        $  @exprTyCnstr1

%%[5
ATTR AllCase [ | tyCnstr: Cnstr | ]
ATTR AllDataConstr AllCase [ valGam: ValGam | | ]
%%]

%%[5_2
ATTR AllCase [ | imprTyCnstr: Cnstr | ]
%%]

%%[50
SEM Decl
  | Val         loc         .   (_,elimEqCnstr)     =   tyElimEqual @expr.ty
                lhs         .   tyCnstr             =   @elimEqCnstr |=> @expr.tyCnstr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind inferencing, decls, top level, abstraction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.tyGam
ATTR AllDecl [ | tyGam: TyGam | ]
ATTR AllExpr [ tyGam: TyGam | | ]
%%]

%%[3
SEM Decl
  | TySig       lhs         .   tyGam               =   @lhs.tyGam
%%]

%%[4
ATTR AllPatExpr [ | tyGam: TyGam | ]
%%]

%%[5
ATTR AllDataConstr AllCase [ tyGam: TyGam | | ]
ATTR AllDecl [ | patTyGam: TyGam | ]

SEM Expr
  | Let         decls       .   patTyGam            =   gamPushNew @lhs.tyGam
                            .   tyGam               =   @decls.patTyGam
%%]

%%[6
ATTR AllExpr AllPatExpr AllData AllCase AllDecl [ | kiCnstr: Cnstr | ]
ATTR AllDecl [ | patKiCnstr: Cnstr | ]

SEM Expr
  | Let         decls       .   patTyGam            :=  gamPushGam @decls.gathKiSigGam @lhs.tyGam
                            .   patKiCnstr          =   @lhs.kiCnstr
                loc         .   (tyGam_l_,tyGam_g_) =   gamPop @decls.patTyGam
                decls       .   tyGam               :=  gamPushGam @tyGam_l_ @lhs.tyGam
                            .   kiCnstr             =   @decls.patKiCnstr
                loc         .   lSubsTyGam          =   @decls.kiCnstr |=> @tyGam_l_
                            .   gSubsTyGam          =   @decls.kiCnstr |=> @tyGam_g_
                            .   gKiTvL              =   ftv @gSubsTyGam
                            .   lQuTyGam            =   tyGamInst1Exists @lUniq3 . tyGamQuantify @gKiTvL $ @lSubsTyGam
                body        .   tyGam               =   gamPushGam @lQuTyGam @gSubsTyGam

SEM Decl
  | TySig       tyExpr      .   tyGam               =   gamPushNew @lhs.tyGam
                loc         .   fo_                 =   fitsIn weakFIOpts @fe @lUniq2 @tyExpr.ki kiStar
                lhs         .   kiCnstr             =   foCnstr @fo_ |=> @tyExpr.kiCnstr
%%]

%%[7
ATTR AllDataField [ | tyGam: TyGam | ]
%%]

%%[50
ATTR AllDataConstrEq [ | tyGam: TyGam | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data info gam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.dataGam
ATTR AllDecl AllExpr AllCase [ | gathDataGam: DataGam | ]
ATTR AllDecl AllExpr AllCase AllPatExpr [ dataGam: DataGam | | ]

SEM AGItf
  | AGItf       expr        .   gathDataGam         =   emptyGam
%%]

%%[8.initDataGam
SEM AGItf
  | AGItf       expr        .   dataGam             =   @expr.gathDataGam
%%]

%%[12 -8.initDataGam
ATTR AGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gamma/Environment for fitting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
SEM Decl
  | *           loc         .   fe                  =   emptyFE
%%]

%%[9
SEM Decl
  | Instance    loc         .   fe                  :=  emptyFE {fePrfCtxtId = @prfCtxtId, feEHCOpts = @lhs.opts}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Init of tyGam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.initTyGam
SEM AGItf
  | AGItf       loc         .   tyGam               =   initTyGam
%%]

%%[12 -1.initTyGam
ATTR AGItf [ tyGam: TyGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Sort, but no inferencing && etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6
ATTR AllExpr AllTyExpr AllPatExpr AllData AllCase AllDecl [ kiGam: KiGam | | ]
%%]

%%[6
SEM AGItf
  | AGItf       loc         .   kiCnstr             =   emptyCnstr
%%]

%%[6.initKiGam
SEM AGItf
  | AGItf       loc         .   kiGam               =   initKiGam
%%]

%%[12 -6.initKiGam
ATTR AGItf [ kiGam: KiGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type signatures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.gathTySigGam
ATTR AllDecl [ | | gathTySigGam USE {`gamAddGam`} {emptyGam}: ValGam ]
%%]

-- generated from ruler rules into EHRulerRules, was 1.gamSigTyGath
%%[5.gamSigTyGath
SEM Decl
  | TySig       loc         .   gamSigTy            =   @tyExpr.ty
                            .   gathTySigGam        =   @nm `gamUnit` ValGamInfo @gamSigTy
%%]
SEM Expr
  | Let         decls       .   gathTySigGam        =   emptyGam

%%[1.tySigGam
ATTR AllDecl [ tySigGam: ValGam | | ]
%%]

-- generated from ruler rules into EHRulerRules, was 1.tySigGam.TysigLet
%%[5.tySigGam.TysigLet
SEM Expr
  | Let         decls       .   tySigGam            =   @decls.gathTySigGam
%%]

-- generated from ruler rules into EHRulerRules, was 1.tySigGam.Val
%%[5.tySigGam.Val
SEM Decl
  | Val         loc         .   (ty_sig_,hasTySig)  =   case @patExpr.mbTopNm of
                                                          Nothing
                                                            ->  (Ty_Any,False)
                                                          Just nm
                                                            ->  case gamLookup nm @lhs.tySigGam of
                                                                  Nothing   -> (Ty_Any,False)
                                                                  Just vgi  -> (vgiTy vgi,True)
%%]

-- generated from ruler rules into EHRulerRules, was 3.TySig
%%[5.TySig
SEM Decl
  | TySig       loc         .   ty_sig_             =   tyQuantify (`elem` @tyExpr.tyVarWildL) @tyExpr.ty
                            .   gamSigTy            :=  @ty_sig_
%%]

%%[4_2
ATTR AllDecl [ | tySigTyCnstr: Cnstr | ]
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.TySig
%%[90
SEM Decl
  | TySig       loc         .   (gamSigTy,gamSigCnstr)
                                                    :=  tyAsCnstr @lUniq @ty_sig_
                lhs         .   tySigTyCnstr        =   @gamSigCnstr |=> @lhs.tySigTyCnstr
%%]

-- generated from ruler rules into EHRulerRules, was 4_2.Let.tySigGam
%%[90.Let.tySigGam
SEM Expr
  | Let         decls       .   tySigGam            :=  @decls.tySigTyCnstr |=> @decls.gathTySigGam
%%]

%%[6
SEM Decl
  | TySig       loc         .   gTyTvL              =   ftv . map (tgiTy.snd) . gamToAssocL $ @lhs.tyGam
                            .   ty_sig_             :=  tyQuantify (`elem` (@tyExpr.tyVarWildL ++ @gTyTvL)) @tyExpr.ty
%%]

%%[9
SEM Decl
  | TySig       loc         .   ty_sig_             :=  tqoTy (tyQuantifyPr  (defaultTyQuOpts {tqoptLeaveImpls=True})
                                                                             (`elem` (@tyExpr.tyVarWildL ++ @gTyTvL))
                                                                             TyQu_Forall [] @tyExpr.ty)
%%]

%%[8
SEM Decl
  | FFI         loc         .   ty_sig_             =   tyQuantifyClosed @tyExpr.ty
                lhs         .   gathTySigGam        =   @nm `gamUnit` ValGamInfo @ty_sig_
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind signatures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6.kiSigGam
ATTR AllDecl [ kiSigGam: TyGam | gathKiSigGam: TyGam | ]

SEM Decl
  | KiSig       lhs         .   gathKiSigGam        =   gamAdd @nm (mkTGI (Ty_Con @nm) @sigKi) @lhs.gathKiSigGam

SEM Expr
  | Let         decls       .   gathKiSigGam        =   emptyGam
                            .   kiSigGam            =   @decls.gathKiSigGam

SEM Decl
  | Data        loc         .   (sigKi,hasKiSig)    =   case gamLookup @tyNm @lhs.kiSigGam of
                                                          Nothing   -> (Ty_Any,False)
                                                          Just tgi  -> (tgiKi tgi,True)
%%]

%%[6
SEM Decl
  | KiSig       loc         .   sigKi               =   kiQuantify (const False) @kiExpr.ki
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Include binding for pattern var?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.inclVarBind
ATTR PatExpr [ inclVarBind: Bool | | ]

SEM PatExpr
  | AppTop      patExpr     .   inclVarBind         =   True

SEM Decl
  | Val         patExpr     .   inclVarBind         =   False

SEM Expr
  | Lam         arg         .   inclVarBind         =   True
%%]

%%[2
SEM Decl
  | Val         patExpr     .   inclVarBind         :=  not @hasTySig
%%]

%%[5
SEM CaseAlt
  | Pat         patExpr     .   inclVarBind         =   True
%%]

%%[7
SEM RecPatExpr
  | Ext Expr    patExpr     .   inclVarBind         =   True
%%]

%%[9
SEM Expr
  | LamImpl     arg         .   inclVarBind         =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Top name of pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.mbTopNm
ATTR PatExpr [ | | mbTopNm: {Maybe HsName} ]

SEM PatExpr
  | Var VarAs   loc         .   mbTopNm             =   if @nm == hsnWild then Nothing else Just @nm
  | * - Var VarAs
                loc         .   mbTopNm             =   Nothing
%%]

%%[7.topNm
ATTR PatExpr [ | | topNm: HsName ]

SEM PatExpr
  | Var VarAs   loc         .   topNm               =   if @nm == hsnWild then uidHNm @lUniq else @nm
  | App         lhs         .   topNm               =   hsnUnknown
  | AppTop Con Rec CConst IConst
                loc         .   topNm               =   uidHNm @lUniq
  | SConst      loc         .   topNm               =   uidHNm @uniq1
%%]

%%[8
SEM PatExpr
  | FConst      loc         .   topNm               =   uidHNm @uniq1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Records, default (positional) name if absent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7
ATTR RecPatExpr RowTyExpr RecExpr [ | positionalFldNmL: {[HsName]} | ]
ATTR RecPatExpr [ matchOnFld: Bool | | hasAFldRef: Bool ]

SEM Expr
  | Rec         recExpr     .   positionalFldNmL    =   positionalFldNames

SEM TyExpr
  | Row         rowTyExpr   .   positionalFldNmL    =   positionalFldNames

SEM PatExpr
  | Rec         recPatExpr  .   positionalFldNmL    =   positionalFldNames
                            .   matchOnFld          =   @recPatExpr.hasAFldRef

SEM RecPatExpr
  | Ext         lhs         .   hasAFldRef          =   maybe @recPatExpr.hasAFldRef (const True) @mbNm
                (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @recPatExpr.positionalFldNmL
                loc         .   nm                  =   case @mbNm of
                                                          Just nm                     -> nm
                                                          Nothing  | @lhs.matchOnFld  -> @patExpr.topNm
                                                                   | otherwise        -> @positionalNm
  | * - Ext     lhs         .   hasAFldRef          =   False
 
SEM RowTyExpr
  | Ext         (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @rowTyExpr.positionalFldNmL
                loc         .   nm                  =   maybe @positionalNm id @mbNm

SEM RecExpr
  | Ext         (loc.positionalNm,lhs.positionalFldNmL)
                                                    =   hdAndTl @recExpr.positionalFldNmL
                loc         .   nm                  =   maybe @positionalNm id @mbNm
%%]

%%[10
SEM PrExpr
  | Lacks       rowTyExpr   .   positionalFldNmL    =   positionalFldNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How to do subsumption
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.fiOpts.init
ATTR AllExpr AllPatExpr [ fiOpts: FIOpts | | ]

SEM AGItf
  | AGItf       expr        .  fiOpts               =   strongFIOpts
%%]

-- generated from ruler rules into EHRulerRules, was/from 4.fiOpts.init
%%[5.fiOpts.init
SEM Expr
  | AppImpred   func        .  fiOpts               =   strongFIOpts
                loc         .  argFIOpts            =   strongFIOpts
                arg         .  fiOpts               =   @argFIOpts

%%]

-- generated from ruler rules into EHRulerRules, was 2.App
%%[5.fiOpts.init
SEM Decl
  | Val         expr        .  fiOpts               =   strongFIOpts
                patExpr     .  fiOpts               =   strongFIOpts
%%]

-- generated from ruler rules into EHRulerRules, was 2.App
%%[5.fiOpts.init
SEM Expr
  | Lam         loc         .  knFunFIOpts          =   @lhs.fiOpts {fioBindRFirst=True}
  | App         func        .  fiOpts               =   strongFIOpts
                loc         .  argFIOpts            =   instLFIOpts
                arg         .  fiOpts               =   @argFIOpts
%%]

%%[5
ATTR AllCase [ fiOpts: FIOpts | | ]

SEM Decl
  | Val         expr        .  fiOpts               :=  if @hasTySig then strongFIOpts else weakFIOpts

SEM CaseAlt
  | Pat         patExpr     .  fiOpts               =   strongFIOpts
%%]

%%[7
SEM RecExpr
  | Ext Upd     expr        .  fiOpts               =   strongFIOpts

SEM Expr
  | Rec         loc         .  fiOpts               =   strongFIOpts
%%]

%%[9
SEM Expr
  | App         func        .  fiOpts               :=  implFIOpts
  | AppImpl     arg         .  fiOpts               =   strongFIOpts

SEM Decl
  | InstanceIntro
                expr        .  fiOpts               =   strongFIOpts
%%]

%%[10
SEM Decl
  | DynVal      expr        .  fiOpts               =   strongFIOpts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicate env, for elim of predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllDecl [ | patPrElimTGam: PrElimTGam | ]
ATTR NTPrf [ | prElimTGam: PrElimTGam | ]
%%]

%%[9.initPrElimTGam
SEM AGItf
  | AGItf       loc         .   prElimTGam          =   emptyTGam @prfCtxtId
%%]

%%[12 -9.initPrElimTGam
ATTR AGItf [ prElimTGam: PrElimTGam | | ]

SEM AGItf
  | AGItf       loc         .   prElimTGam          =   tgamPushNew @lhs.prfCtxtId @prfCtxtId @lhs.prElimTGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicate env, for intro of predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllDecl [ | patPrIntroGam: PrIntroGam | ]
ATTR NTPrf AllPrExpr AllTyExpr AllData AllPatExpr [ prIntroGam: PrIntroGam | | ]
%%]

%%[9.initPrIntroGam
SEM AGItf
  | AGItf       loc         .   prIntroGam          =   emptyGam
%%]

%%[12 -9.initPrIntroGam
ATTR AGItf [ prIntroGam: PrIntroGam | | ]
%%]

%%[9
SEM Expr
  | Let         decls       .   patPrIntroGam       =   gamPushNew @lhs.prIntroGam
                loc         .   (lPrIGam,gPrIGam)   =   gamPop @decls.patPrIntroGam
                decls       .   prIntroGam          =   gamPushGam @lPrIGam @lhs.prIntroGam
                loc         .   lSubsPrIGam         =   @decls.kiCnstr |=> @lPrIGam
                            .   gSubsPrIGam         =   @decls.kiCnstr |=> @gPrIGam
                            .   gKiTvL              :=  ftv @gSubsTyGam `List.union` ftv @gSubsPrIGam
                            .   lQuPrIGam           =   gamMap
                                                            (\(n,t) -> (n,t {pigiKi = tyQuantify (`elem` @gKiTvL) (pigiKi t)}))
                                                            @lSubsPrIGam
                body        .   prIntroGam          =   gamPushGam @lQuPrIGam @gSubsPrIGam
%%]

