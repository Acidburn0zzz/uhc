%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to JavaScript/AbsSyn
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs module {%{EH}JavaScript} import({%{EH}Base.Common})
%%]

%%[(8 javascript) hs export(JavaScriptModule(..), Stat(..), StatL, NmExpr, NmExprL, Expr(..), ExprL, MbExpr, AGItf(..)) 
%%]

%%[(8 javascript) hs import({%{EH}Gam.DataGam})
%%]

%%[(8 javascript) hs export(Alt(..), AltL) 
%%]

%%[(8 javascript) ag import({JavaScript/AbsSyn})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs
nmFunSuff :: Int -> String
nmFunSuff n | n >  5    = "N"
            | n >= 0    = show n
            | otherwise = ""
nmApplyN n  = "_a" ++ nmFunSuff n ++ "_"
nmApply     = nmApplyN (-1)
nmEvalN  n  = "_e" ++ nmFunSuff n ++ "_"
nmEval      = nmEvalN (-1)
%%]

%%[(8 javascript) hs export(nmTag)
nmTag       = mkHNm "_tag_"
%%]

%%[(8 javascript) hs export(hsnJavaScriptVar)
hsnJavaScriptVar :: Bool -> HsName -> HsName -> HsName -> HsName
%%[[8
hsnJavaScriptVar isGlobal = hsnJavaLikeVar (id, id, id)
%%][50
hsnJavaScriptVar isGlobal = hsnJavaLikeVar (hsn, hsnPrefix "$", ('$':))
  where hsn | isGlobal  = id
            | otherwise = hsnQualified
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Smart constructors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs export(localVarDecl)
-- | declare a local var
localVarDecl :: HsName -> Maybe Expr -> Stat
localVarDecl n me = Stat_VarDecl n me
%%]

%%[(8 javascript) hs export(varDecl)
-- | declare a var, or a field in object, depending on name being qualified
varDecl :: HsName -> Expr -> Stat
%%[[8
varDecl n e = localVarDecl n (Just e)
%%][50
varDecl n e
  = case hsnQualifier n of
      Just _ -> Stat_Assign (Expr_Var n) e
      _      -> localVarDecl n (Just e)
%%]]
%%]

%%[(8 javascript) hs export(op)
-- | Operator expression
op :: String -> [Expr] -> Expr
op o (l:r:_) = Expr_Op    (mkHNm o) l r
op o (e  :_) = Expr_PreOp (mkHNm o) e
%%]

%%[(8 javascript) hs export(empty)
-- | Placeholder for empty
empty :: Expr
empty = Expr_Empty
%%]

%%[(8 javascript) hs export(vardecl)
vardecl :: HSNM n => n -> Maybe Expr -> Stat
vardecl nm mbe = Stat_VarDecl (mkHNm nm) mbe
%%]

%%[(8 javascript) hs export(arr, newTup)
-- | Construct array
arr ::[Expr] -> Expr
arr = Expr_Arr

-- new tuple
newTup :: [Expr] -> Expr
newTup = arr
%%]

%%[(8 javascript) hs export(dataFldNames, newTupOrData)
-- | field names used for data constructors, either as provided by program, or made up here
--   20101012 AD, note: internally generated datatypes not yet have correct meta info, so fill up names as needed, as temporary hack
dataFldNames :: TagLike t => DataGam -> t -> [HsName]
dataFldNames dataGam tag
  = map (hsnSafeJavaLike . hsnQualified) nms ++ hsnLclSupply
  where nms  = maybe [] (\(_,dti) -> map fldNm $ dtiFldRefL dti) $ dataGamTagLookup tag dataGam

-- either new data constructor or tuple
newTupOrData :: TagLike t => DataGam -> t -> [Expr] -> Expr
newTupOrData dataGam tag as
  | tagIsData tag
      = Expr_Obj $ ((nmTag, intConst $ tagDataTag tag):) $ zip (dataFldNames dataGam tag) as
  | tagIsTup tag
      = newTup as
%%]

%%[(8 javascript) hs export(intConst, evl, apl, var, call, callv, ret', ret, assign)
-- | Int constant
intConst :: Integral x => x -> Expr
intConst i = Expr_Int $ fromIntegral i

-- | call, function is an expr
call :: Expr -> [Expr] -> Expr
call = Expr_Call

-- | call, function is a name
callv :: HSNM n => n -> [Expr] -> Expr
callv f = call (var $ mkHNm f)

-- | force evaluation
evl :: Expr -> Expr
evl x = callv nmEval [x]

-- | force application
apl :: Expr -> [Expr] -> Expr
apl f as = callv nmApply [f, arr as]

-- | var
var :: HSNM x => x -> Expr
var nm = Expr_Var $ mkHNm nm

-- | return
ret' :: Maybe Expr -> Stat
ret' e = Stat_Ret e

-- | return
ret :: Expr -> Stat
ret e = ret' (Just e)

-- assign
assign :: HSNM x => x -> Expr -> Stat
assign n e = Stat_Assign (var $ mkHNm n) e

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Observations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs export(exprMbVar)
exprMbVar :: Expr -> Maybe HsName
exprMbVar (Expr_Var n) = Just n
exprMbVar _            = Nothing
%%]
