%%[(8 counting) hs module {%{EH}CountingAnalysis}
%%]

%%[(8 counting) hs import(Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName, hsnIsNr)})
%%]

%%[(8 counting) hs import(UHC.Util.Binary, UHC.Util.Serialize, UHC.Util.Pretty)
%%]

%%[(8 counting) hs import(Control.Monad)
%%]

%%[(8 counting) hs import(qualified Data.Sequence as Seq, qualified Data.Foldable as Fold)
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn})
-- optpragmas
-- {
-- {-# LANGUAGE TypeFamilies #-}
-- {-# LANGUAGE RankNTypes #-}
-- {-# LANGUAGE MultiParamTypeClasses #-}
-- {-# LANGUAGE FunctionalDependencies #-}
-- {-# LANGUAGE DeriveFunctor #-}
-- {-# LANGUAGE TemplateHaskell #-}
-- }
%%]

%%[(8 counting) hs

singleC :: Constraint -> Constraints
singleC x =[x]

%%]

%%[(8 counting) hs
type AnnSol = Map HsName Annotation
type TySol = Map HsName Type
type SchemeSol = Map HsName Scheme
type PartSolution = Map HsName (Set AnnVal)
data Solution = Solution 
  { _annSol :: AnnSol
  , _tySol :: TySol
  , _schemeSol :: SchemeSol
  }
  deriving (Eq, Show)
  
emptySolution = Solution
  { _annSol = M.empty
  , _tySol = M.empty
  , _schemeSol = M.empty
  }

type Imports = Map HsName Scheme
type Exports = Set HsName
type BindingEnv = Env
%%]

%%[(8 counting) ag
DERIVING *
  : Typeable, Eq, Show, Ord, Data, Generic

-- DERIVING *
--   : Eq, Show

%%]

%%[(8 counting) hs
type Var = Int
type HsNames = [HsName]
type AnnVal = Set AnnPrim
type AnnotationValue = AnnVal

annBot' = S.empty
annBot = Annotation_Val annBot'

annZero' = S.singleton AnnPrim_Zero
annZero = Annotation_Val annZero'

annOne' = S.singleton AnnPrim_One
annOne = Annotation_Val annOne'

annW' = S.singleton AnnPrim_Infinity
annW = Annotation_Val annW'

annTop' = S.fromList [AnnPrim_Zero, AnnPrim_One, AnnPrim_Infinity]
annTop = Annotation_Val annTop'

annPow :: AnnVal -> Set AnnVal
annPow = S.fromList . map (S.fromList) . annPow' . S.toList
  where annPow' [] = [[]]
        annPow' (x:xs) = p ++ map (x:) p
          where p = annPow' xs

annPowWithoutEmpty :: AnnVal -> Set AnnVal
annPowWithoutEmpty = S.delete (S.empty) . annPow

type UsageAnnotation = Annotation
type DemandAnnotation = Annotation

type family UType a
type instance UType EtaType = Type
type instance UType EtaScheme = Scheme
type instance UType RhoType = Type
type instance UType RhoScheme = Scheme
type instance UType (GEta a) = a
type instance UType (GRho a) = a

data GEta a = GEta a Annotation
  deriving (Show, Ord, Eq, Functor)
data GRho a  = GRho (GEta a) Annotation
  deriving (Show, Ord, Eq, Functor)

class Eta a where
  getType :: a -> UType a
  getUsage :: a -> Annotation
  toGEta :: a -> GEta (UType a)
  toGEta a = GEta (getType a) (getUsage a)
  fromGEta :: GEta (UType a) -> a

class Eta a => Rho a where
  getDemand :: a -> DemandAnnotation
  toGRho :: a -> GRho (UType a)
  toGRho a = GRho (toGEta a) (getDemand a)
  fromGRho :: GRho (UType a) -> a

instance Eta (GEta a) where
  getType (GEta a _) = a
  getUsage (GEta _ u) = u
  fromGEta = id

instance Eta (GRho a) where
  getType (GRho e _) = getType e
  getUsage (GRho _ u) = u
  fromGEta = undefined

instance Rho (GRho a) where
  getDemand (GRho _ d) = d
  fromGRho = id

instance Eta EtaType where
  getType (EtaType_Eta t _) = t
  getUsage (EtaType_Eta _ u) = u
  fromGEta (GEta t u) = EtaType_Eta t u

instance Eta EtaScheme where
  getType (EtaScheme_Eta t _) = t
  getUsage (EtaScheme_Eta _ u) = u
  fromGEta (GEta s u) = EtaScheme_Eta s u

instance Eta RhoType where
  getType (RhoType_Rho e _) = getType e
  getUsage (RhoType_Rho e _) = getUsage e
  fromGEta = undefined

instance Eta RhoScheme where
  getType (RhoScheme_Rho e _) = getType e
  getUsage (RhoScheme_Rho e _) = getUsage e
  fromGEta = undefined

instance Rho RhoType where
  getDemand (RhoType_Rho _ d) = d
  fromGRho (GRho e d) = RhoType_Rho (fromGEta e) d

instance Rho RhoScheme where
  getDemand (RhoScheme_Rho _ d) = d
  fromGRho (GRho e d) = RhoScheme_Rho (fromGEta e) d
  
%%]

Serialize
%%[(8 counting) hs
instance Serialize AnnPrim where
instance Serialize Annotation where
instance Serialize Type where
instance Serialize EtaType where
instance Serialize RhoType where
instance Serialize EtaScheme where
instance Serialize RhoScheme where
instance Serialize Field where
instance Serialize Scheme where
instance Serialize Constraint where
instance Serialize ConstraintAnn where
instance Serialize ConstraintEq where  
%%]
-- Pretty printing
%%[(8 counting) hs
instance PP Module where
  pp (Module_Module mod) = pp mod

instance PP Expr where
  pp (Expr_VarLocal v) = pp v
  pp (Expr_VarImport v) = pp v
  pp (Expr_Const c) = pp c
  pp (Expr_Let binds body) = "let" >-< indent 2 (vlist binds) >-< "in" >#< body
  pp (Expr_LetBang x e1 e2) = "let!" >#< x >#< "=" >#< e1 >-< "in" >#< e2
  pp (Expr_Con _ conNm flds) = conNm >#< ppSpaces flds 
  pp (Expr_Tup flds) = ppParensCommas flds
  pp (Expr_AppLocal func arg) = func >#< arg
  pp (Expr_AppImport func arg) = func >#< arg
  pp (Expr_AppConst func arg) = func >#< arg
  pp (Expr_Abs bind body) = "\\" >|< bind >#< "->" >-< indent 2 body
  pp (Expr_CaseCon e alts) = "case" >#< e >#< "of" >-< indent 2 (vlist alts)
  pp (Expr_CaseTup e xs e1) = "case" >#< e >#< "of" >-< indent 2 (ppParensCommas xs >#< "->" >#< e1)
  pp (Expr_CaseConst e alts) = "case" >#< e >#< "of" >-< indent 2 (vlist alts)
  pp Expr_FFI{} = text "FFI"
  pp (Expr_Ann t e) = ppParens e >#< "::" >#< t

instance PP ConVar where
  pp (ConVar_VarLocal v) = pp v
  pp (ConVar_VarImport v) = pp v
  pp (ConVar_Const c) = pp c

instance PP Binding where
  pp (Binding_Bind n e) = n >#< "=" >#< e

instance PP Const where
  pp (Const_Int c) = pp c
  pp (Const_Char c) = pp c
  pp (Const_String c) = pp c
  pp (Const_Integer c) = pp c

instance PP AltCon where
  pp (AltCon_Alt _ c xs e) = c >#< ppSpaces xs >#< "->" >#< e

instance PP AltConst where
  pp (AltConst_Int c e) = c >#< "->" >#< e
  pp (AltConst_Char c e) = c >#< "->" >#< e
  
instance PP Scheme where
  pp (Scheme_Var v) = pp v
  pp (Scheme_Forall as ts c t) = "forall" >#<
    ppCurlysCommas (S.toList as ++ S.toList ts) 
    >#< "." >#< text ("cs: " ++ show (length c))
    >#< "=>"  >#< t >-< indent 4 (vlist c)

instance PP Type where
  pp (Type_Var v) = pp v
  pp (Type_Data n as ts) = n >#< ppSpaces as >#< ppSpaces ts
  pp (Type_App t1 t2) = t1 >#< t2
  pp (Type_Func t1 t2) = ppParens (t1 >#< "->" >#< t2)
  pp (Type_Tup ts) = ppParensCommas ts
  pp (Type_Error e) = "Type Error:" >#< e

instance PP RhoType where
  pp (RhoType_Rho (EtaType_Eta t u) d) = ppParens t >#< "^" >#< ppParensCommas [u,d]

instance PP EtaType where
  pp (EtaType_Eta t u) = ppParens t >#< "^" >#< u

instance PP RhoScheme where
  pp (RhoScheme_Rho (EtaScheme_Eta s u) d) = ppParens s >#< "^" >#< ppParensCommas [u,d]

instance PP EtaScheme where
  pp (EtaScheme_Eta s u) = ppParens s >#< "^" >#< u

instance PP Annotation where
  pp (Annotation_Var v) = pp v
  pp (Annotation_Val v) = ppCurlysCommas $ S.toList v
  
instance PP AnnPrim where
  pp AnnPrim_Zero = text "0"
  pp AnnPrim_One = text "1"
  pp AnnPrim_Infinity = text "2"

instance PP Constraint where
  pp (Constraint_Ann c) = pp c
  pp (Constraint_Eq c) = pp c
  pp (Constraint_Inst s t) = "inst(" >|< s >|< ") ==" >#< t
  pp (Constraint_Gen t u d n0 d0 c e s) = "gen" 
    >|< ppParensCommas [t >#< "^" >#< ppParensCommas [u, d], pp $ "cs: " ++ show (length c), pp $ "e: " ++ show (M.size e)]
    >#< "==" >#< s >#< "^" >#< ppParensCommas [n0, d0]
    >-< indent 4 (vlist c) >-< indent 4 (ppMap e)

instance PP ConstraintAnn where
  pp (ConstraintAnn_Plus a1 a2 a) = a1 >#< "(+)" >#< a2 >#< "==" >#< a
  pp (ConstraintAnn_Union a1 a2 a) = a1 >#< "U" >#< a2 >#< "==" >#< a
  pp (ConstraintAnn_Times a1 a2 a) = a1 >#< "." >#< a2 >#< "==" >#< a
  pp (ConstraintAnn_Cond a1 a2 a) = a1 >#< ">" >#< a2 >#< "==" >#< a

instance PP ConstraintEq where
  pp (ConstraintEq_Ann a1 a2) = a1 >#< "==" >#< a2
  pp (ConstraintEq_Type t1 t2) = t1 >#< "==" >#< t2
  pp (ConstraintEq_Scheme s1 s2) = s1 >#< "==" >#< s2

ppMap :: (PP k, PP v) => Map k v -> PP_Doc
ppMap = vlist . map f . M.toList
  where f (k,v) = k >#< "->" >-< indent 2 (pp v)

instance PP Solution where
  pp (Solution as ts ss) = "annSol:" >-< indent 2 (ppMap as)
    >-< "typeSol:" >-< indent 2 (ppMap ts)
    >-< "schemeSol:" >-< indent 2 (ppMap ss)

class PPAnnFree a where
  ppAnnFree :: a -> PP_Doc

ppMapAnnFree :: (PP k, PPAnnFree v) => Map k v -> PP_Doc
ppMapAnnFree = vlist . map f . M.toList
  where f (k,v) = k >#< "->" >-< indent 2 (ppAnnFree v)

instance PPAnnFree RhoScheme where
  ppAnnFree (RhoScheme_Rho (EtaScheme_Eta s _) _) = ppAnnFree s
  
instance PPAnnFree Scheme where
  ppAnnFree (Scheme_Var v) = pp v
  ppAnnFree (Scheme_Forall _ _ _ t) = ppAnnFree t

instance PPAnnFree Type where
  ppAnnFree (Type_Var v) = pp v
  ppAnnFree (Type_Data n _ ts) = n >#< ppSpaces (map ppAnnFree ts)
  ppAnnFree (Type_App t1 t2) = ppAnnFree t1 >#< ppAnnFree t2
  ppAnnFree (Type_Func t1 t2) = ppParens (ppAnnFree t1 >#< "->" >#< ppAnnFree t2)
  ppAnnFree (Type_Tup ts) = ppParensCommas (map ppAnnFree ts)
  ppAnnFree (Type_Error e) = "Type Error:" >#< e

instance PPAnnFree RhoType where
  ppAnnFree (RhoType_Rho (EtaType_Eta t _) _) = ppAnnFree t

instance PPAnnFree EtaType where
  ppAnnFree (EtaType_Eta t _) = ppAnnFree t
%%]
