-- kate: indent-mode normal

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) import({Silly/AbsSyn})
%%]

%%[(8 codegen grin).wrapper
WRAPPER SilModule
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.EmbedVars} export(embedVars)
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import(qualified Data.Set as Set)
%%]
%%[(8 codegen grin) hs import(Debug.Trace)
%%]

%%[(8 codegen grin) hs


decrement :: Int -> Int
decrement n = n-1

embedVars :: EHCOpts -> SilModule -> SilModule
embedVars options input   
  = let t = wrap_SilModule (sem_SilModule input)
                           (Inh_SilModule {opts_Inh_SilModule = options})
    in if (ehcOptMetaClosures options) 
       then trfMeta_Syn_SilModule t
       else trf_Syn_SilModule t

%%]

%%[(8 codegen grin)

ATTR SilModule   [ opts : {EHCOpts} | | ]
ATTR AllNT [ | | trf: SELF  ]
ATTR Statement Statements Alternative Alternatives Variable Value Values [ numberLocals : {Int} | | ]
ATTR Statement Statements Alternative Alternatives                       [ | embedMap : {EmbedMap} | ]
ATTR Variable Value Values                                               [ embedMap : {EmbedMap} | | ]
ATTR Statement Statements Alternative Alternatives Variable              [ | | localsSet USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]
ATTR Statement Statements Alternative Alternatives Variable Value Values [ | | usedSet USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]
ATTR Statement Statements Alternative Alternatives                       [ neededSet: {Set.Set HsName} | | ]
ATTR Statement Statements Alternative Alternatives Variable Value Values [ numberParameters : {Int} | | ]
ATTR Statement                                                           [ | | trfStats: {[Statement]} ]
ATTR Function Functions 
     Statement Statements Alternative Alternatives Value Values Variable [ optGenOwn  : {Bool}  optGenLink : {Bool}  optGenLocReg : {Bool}| | ]
ATTR Function Functions 
     Statement Statements Alternative Alternatives                       [ optGenReturnViaStack : {Bool} | | ]


SEM SilModule
  | SilModule  loc.optGenOwn            = ehcOptGenOwn @lhs.opts  &&  not (ehcOptEmitLLVM @lhs.opts)
               loc.optGenLocReg         = ehcOptGenOwn @lhs.opts  &&  not (ehcOptEmitLLVM @lhs.opts)  &&  ehcOptGenLocReg @lhs.opts
               loc.optGenReturnViaStack = ehcOptGenOwn @lhs.opts  &&  not (ehcOptEmitLLVM @lhs.opts)  &&  ehcOptGenRVS  @lhs.opts
               loc.optGenLink           = ehcOptGenOwn @lhs.opts  &&  not (ehcOptEmitLLVM @lhs.opts)  &&  ehcOptGenLink @lhs.opts


ATTR Values [ | | length : {Int} ]

SEM Values
  | Nil lhs.length = 0
  | Cons lhs.length = 1 + @tl.length


ATTR Functions Function Statements Statement Alternatives Alternative [  |  retNr : {Int} |  ]

SEM SilModule
  | SilModule     functions . retNr   = 3


%%]

%%[(8 codegen grin)

SEM Statement
  | Call      lhs . trfStats =  if not @lhs.optGenOwn
                                then [@loc.trf]
                                else if @tailJumps
                                then (  let nl |  @lhs.optGenLocReg = 0
                                               |  otherwise         = @lhs.numberLocals
                                            locPar = nl + @lhs.numberParameters
                                            sources      = reverse @args.trf                                                    -- put arguments on the stack
                                                           ++ [ Value_Var (Variable_Subs Variable_SP (nl +1))                   -- put original return address on the stack
                                                              | @lhs.optGenLink                                                 --  (if there is a link below it)
                                                              ]
                                                           ++ [ Value_Var (Variable_Subs Variable_SP (nl   ))                   -- put original link on the stack (if there is one), or otherwise the original return address
                                                              ]
                                            destinations = iterate decrement (locPar+ (if @lhs.optGenLink then 2 else 1) -1)
                                            adjust       = locPar - @args.length
                                        in  Statement_Comment ["Tailcall"]
                                            :
                                            smartAssignment (zip destinations sources)                                          -- do stack-putting in an overlapping fashion with the original stack contents
                                            ++
                                            [ Statement_Assignment Variable_SP (Value_Offset Variable_SP  adjust)                -- adjust stack: increment for original parameters&callinfo&locals, decrement for new parameters&callinfo
                                            | adjust /= 0                                                                       --   (if necessary)
                                            ]
                                            ++
                                            [ Statement_Call @name True []                                                      -- do the jump, which will return to the original return address
                                            ]
                                     )
                                else (  let nl |  @lhs.optGenLocReg = 0
                                               |  otherwise         = @lhs.numberLocals
                                            worthyNames = [ n 
                                                          | Variable_Local n v <- Map.elems @lhs.embedMap
                                                          , Set.member v @lhs.neededSet
                                                          ]
                                            registersToSave = map (Variable_Subs Variable_LP) worthyNames
                                            sources     =  ( if @lhs.optGenLocReg
                                                             then map Value_Var registersToSave                                        -- saveRegisters
                                                             else []
                                                           )
                                                           ++ reverse @args.trf                                                 -- put arguments on stack
                                                           ++ [ Value_Label @loc.label ]                                        -- put return address on the stack
                                                           ++ [ Value_Cast (Value_Offset Variable_SP  nl) True                   -- put dynamic link on the stack
                                                              | @lhs.optGenLink                                                 --  (if requested)
                                                              ]
                                            destinations = (map (Variable_Subs Variable_SP) (iterate decrement (-1)))
                                            adjust       = - length sources
                                        in  Statement_Comment ["Call, worthy: " ++ show worthyNames]
                                            :
                                            zipWith Statement_Assignment destinations sources                                   -- do stack-putting by assignments
                                            ++ 
                                            [ Statement_Assignment Variable_SP (Value_Offset Variable_SP  adjust)                -- adjust stack: decrement for new parameters&callinfo
                                            , Statement_Call @name False []                                                     -- do the call (in fact a jump, which will return one line below here)
                                            , Statement_Label @loc.label                                                        -- return here after the call
                                            ]
                                            ++
                                            ( if @lhs.optGenLocReg
                                              then Statement_Assignment Variable_SP (Value_Offset Variable_SP  (length registersToSave))
                                                   :
                                                   zipWith Statement_Assignment registersToSave (map Value_Var destinations)           -- restore registers
                                              else []
                                            )
                                     )
           lhs.retNr     = @lhs.retNr + 1
           loc.label     = "retlab"++show @lhs.retNr

                                
  | Return    lhs . trfStats = let nl |  @lhs.optGenLocReg = 0
                                      |  otherwise         = @lhs.numberLocals
                                   locPar  =  nl +  @lhs.numberParameters
                                   callInfoSize = if @lhs.optGenLink then 2 else 1
                               in  (  if @lhs.optGenReturnViaStack
                                      then  let moveRet = @vals.length  > @lhs.numberParameters
                                                sources = @vals.trf 
                                                          ++ [Value_Var (Variable_Subs Variable_SP (1+nl)) | moveRet]
                                                destinations = iterate decrement (locPar+ callInfoSize -1)
                                            in  smartAssignment (zip destinations sources)    -- results overlap original parameters&callinfo&locals
                                      else  [ Statement_Assignment v e
                                            | (v,e) <-zip [Variable_Subs Variable_RP i | i <- [0..] ]
                                                          @vals.trf
                                            ]
                                   )
                                   ++
                                   (  if @lhs.optGenOwn
                                      then let n | @lhs.optGenReturnViaStack = max @vals.length @lhs.numberParameters
                                                 | otherwise                 =                  @lhs.numberParameters
                                           in  [ Statement_Assignment Variable_SP (Value_Offset Variable_SP  (locPar + callInfoSize ))
                                               , Statement_Return [] (Value_Var $ Variable_Subs Variable_SP (-(n + 1 )))
                                               ]                                    
                                      else []
                                   )

  | * - Return
        Call   lhs . trfStats = [@loc.trf]

SEM Statements
  | Cons      lhs . trf      = @hd.trfStats ++ @tl.trf


  

SEM Function
  | Function  lhs . trf    =  Function_Function @name
                                                -- parameters
                                                (if @lhs.optGenOwn then [] else @parameters)
                                                -- locals
                                                (if @lhs.optGenOwn then [] else Set.toList (Set.difference @body.localsSet (Set.fromList @parameters)))
                                                -- body
                                                (  ( if   @lhs.optGenOwn
                                                     then Statement_Comment ["Expects " ++ show (length @parameters) ++ " parameters, uses " ++ show @loc.numberLocals ++ " local variables" ]
                                                          : ( if   @lhs.optGenLocReg || @loc.numberLocals == 0
                                                              then []
                                                              else [ Statement_Assignment Variable_SP (Value_Offset Variable_SP  (- @loc.numberLocals)) ]
                                                            )
                                                     else []
                                                   )
                                                   ++ @body.trf
                                                )
                                                
SEM Function
  | Function  body . numberParameters = length @parameters
              body . embedMap = Map.fromList (zipWith (makeEmbedTupel Variable_Param) [1..] @parameters)
              loc  . numberLocals : Int
              loc  . numberLocals = maxNeededLocal @body.localsSet @body.embedMap


ATTR Variable [ | | unembeddedName : {Maybe HsName} ]
SEM Variable
  | Unembedded   lhs.unembeddedName = Just @name
  | *-Unembedded lhs.unembeddedName = Nothing

SEM Statement
  | Assignment
    Assignment2 loc . embedMap : EmbedMap
                loc . embedMap = maybe @lhs.embedMap
                                       (\name@(HNmNr nr _) -> if    Map.member nr @lhs.embedMap
                                                              then  @lhs.embedMap
                                                              else  let newint = 1 + maxNeededLocal @lhs.neededSet @lhs.embedMap
                                                                        newvar = Variable_Local newint name
                                                                    in  -- trace ("new local: " ++ show newvar ) $
                                                                        Map.insert nr newvar @lhs.embedMap
                                       )
                                       @dest.unembeddedName
  
{
maxNeededLocal :: Set.Set HsName -> EmbedMap -> Int
maxNeededLocal s m = let ns = [ n |  Variable_Local n v <- Map.elems m , Set.member v s ]
                     in  {- trace (show $ Set.toList s) $ -} if null ns then 0 else maximum ns
}



SEM Function
  | Function       body . neededSet = @lhs.persistentVars
  
SEM Statements
  | Cons           hd . neededSet = Set.union @lhs.neededSet @tl.usedSet

SEM Alternatives
  | Cons           hd . neededSet = Set.union @lhs.neededSet @tl.usedSet


SEM Variable
  | Unembedded      lhs . localsSet = case @name of
                                       HNmNr _ (OrigGlobal _) -> Set.empty
                                       _                      -> Set.singleton @name
  | *-Unembedded    lhs . localsSet = Set.empty

SEM Variable
  | Unembedded      lhs . usedSet = Set.singleton @name


SEM Variable
  | Unembedded   lhs.trf =  embedUsing (if   not @lhs.optGenOwn 
                                        then strategyId
                                        else if   @lhs.optGenLocReg
                                             then strategyLocReg  @lhs.numberLocals (if @lhs.optGenLink then 2 else 1)
                                             else strategyOnStack @lhs.numberLocals (if @lhs.optGenLink then 2 else 1)
                                       ) 
                                       @lhs.embedMap 
                                       @name

-- The needed set is the set of variables that is still used later on the function
-- this is used to re-use memory location for different variables
-- For meta-closures however a variable might still be used, even though it is never
-- referenced again in the function, it might be looked up later on 
-- through a variable offset (fetch var). To make sure
-- that these variables aren't overwritten we first built the set 
-- of "persistent" variables, i.e. variables that should have
-- their own memory location. 
-- This is added to the needed set.

ATTR Functions Function Statements Statement Alternatives Alternative Constant Variable Values Value 
    [ persistentVars : {Set.Set HsName} | | persistentVarsUp USE {`Set.union`} {Set.empty} : {Set.Set HsName} ]

SEM Value
    | OffsetVar lhs.persistentVarsUp = Set.singleton @var

SEM SilModule
    | SilModule functions.persistentVars = @functions.persistentVarsUp

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Embedding of parameters and local variables on the stack
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

type EmbedMap = Map.Map Int Variable
type EmbedFunction = HsName->Variable
type EmbedStrategy = Variable -> Variable

makeEmbedTupel :: (Int->HsName->Variable) -> Int -> HsName -> (Int,Variable)
makeEmbedTupel constr k x@(HNmNr n _) = (n, constr k x)


strategyId :: EmbedStrategy
strategyId v = v

strategyOnStack :: Int -> Int -> EmbedStrategy
strategyOnStack d _            (Variable_Local n _) = Variable_Subs Variable_SP (d-n)
strategyOnStack d callInfoSize (Variable_Param n _) = Variable_Subs Variable_SP (d+callInfoSize-1+n)

strategyLocReg :: Int -> Int -> EmbedStrategy
strategyLocReg d _            (Variable_Local n _) = Variable_Subs Variable_LP n
strategyLocReg d callInfoSize (Variable_Param n _) = Variable_Subs Variable_SP (callInfoSize-1+n)

-- new for meta closures

strategyOnHeapFrame :: Int -> EmbedStrategy
strategyOnHeapFrame nrParams       (Variable_Local n _) = Variable_Subs Variable_SP (2 + nrParams + n -1 )
strategyOnHeapFrame _              (Variable_Param n _) = Variable_Subs Variable_SP (2+n -1 )

embedUsing :: EmbedStrategy -> EmbedMap -> EmbedFunction
embedUsing strat m x@(HNmNr n _) = if n==0
                                   then Variable_None
                                   else maybe (Variable_Global x)
                                              strat
                                              (Map.lookup n m)


--showEmbedPair :: Int -> HptMap -> (Int,Variable) -> String
--showEmbedPair d h (i, Variable_Param n name) = "Param " ++ show n ++ " \t" ++ postPad 12 (hsnShowAlphanumeric name) ++ "\tSP[" ++ show (d+1+n) ++ "]\t(" ++ show (getEnvVar h i) ++ ")"
--showEmbedPair d h (i, Variable_Local n name) = "Local " ++ show n ++ " \t" ++ postPad 12 (hsnShowAlphanumeric name) ++ "\tSP[" ++ show (d+0-n) ++ "]\t(" ++ show (getEnvVar h i) ++ ")"

postPad n s = let w = length s
              in  if w>=n then s else s ++ replicate (n-w) ' '
                  



%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The Smart Assignation strategy (probably reinvented a topological sort algorithm here)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

type EIV = Either Int Value
data SmartTree = SmartTree EIV [(SmartTree,Maybe Int)]
       deriving Show

smartAssignment :: [(Int,Value)] -> [Statement]
smartAssignment = concat . map smartAss . foldr smartAdd [] . convertTups
{-
smartAssignment tups = let convs  = trace ("smart tups=" ++ show tups)  $ convertTups tups
                           trees  = trace ("smart convs="++ show convs) $ foldr smartAdd [] convs
                           statss = trace ("smart trees="++ show trees) $ map smartAss trees
                           res    = trace ("smart stats="++ show statss)$ concat statss
                       in  res
-}

isJust Nothing = False
isJust (Just _)= True

convertTups :: [(Int,Value)] -> [(EIV,Maybe Int,Int)]
convertTups tups = [ (dependency, mbindex, destination) 
                   | (destination, value) <- tups
                   , let (dependency,mbindex) = smartDep value
                   , either (\dep->dep/=destination || isJust mbindex) (\v->True) dependency
                   ]

smartDep :: Value -> (EIV,Maybe Int)
smartDep (Value_Var (Variable_Subs Variable_SP n)) = (Left n,Nothing)
smartDep (Value_Var (Variable_Subs (Variable_Subs Variable_SP n) k)) = (Left n,Just k)
smartDep v = (Right v,Nothing)

-- single out the tree that has n as its root, or make a new tree
smartFind :: EIV -> [SmartTree] -> (SmartTree, [SmartTree])
smartFind n [] =  (SmartTree n [], [])
smartFind n (t@(SmartTree r ks):ts)
  | n==r       =  (t, ts)
  | otherwise  =  let (t2,ts2) = smartFind n ts
                  in (t2, t:ts2)

smartAdd :: (EIV,Maybe Int,Int) -> [SmartTree] -> [SmartTree]
smartAdd p@(dep,mbi,dest) ts = let (found,ts2) = smartFind (Left dest) ts
                                   (rs,b) = smartIns (dep,found,mbi) ts2
                               in  if b
                                   then rs
                                   else (SmartTree dep [(found,mbi)]) : ts2
                           
                           
smartInsert :: (EIV,SmartTree,Maybe Int) -> SmartTree -> (SmartTree,Bool)
smartInsert p@(dep,found,mbi) t@(SmartTree root kids)
 | dep==root  =  (SmartTree root ((found,mbi):kids), True)
 | otherwise  =  let (kids2,mbis2) = unzip kids
                     (rs,b) = smartIns p kids2
                 in  if b
                     then (SmartTree root (zip rs mbis2), True)
                     else (t                            , False)
                    
smartIns :: (EIV,SmartTree,Maybe Int) -> [SmartTree] -> ([SmartTree],Bool)
smartIns p ts = foldr f ([],False) ts
  where f t (rs,True) = (t:rs, True)
        f t (rs,False) = let (r,b) = smartInsert p t
                         in  (r:rs, b)
       
smartElems :: SmartTree -> [Int]
smartElems (SmartTree (Left n) [])   = [n]
smartElems (SmartTree (Left n) kids) = n : concat (map smartElems (map fst kids))


auxVar = Variable_Aux
auxVal = Value_Var auxVar

smartAss :: SmartTree -> [Statement]
smartAss t@(SmartTree root kids) 
  =  either
     (\n -> if  n `elem` concat (map smartElems (map fst kids))
            then Statement_Assignment auxVar (Value_Var (Variable_Subs Variable_SP n))
                 : concat (map (smartChain (mbsubs auxVar)) kids)
            else concat (map (smartChain (mbsubs (Variable_Subs Variable_SP n))) kids)
     )
     (\v -> concat (map (smartChain (const v)) kids)
     )
     root
  
mbsubs :: Variable -> (Maybe Int -> Value)
mbsubs var Nothing  = Value_Var var
mbsubs var (Just i) = Value_Var (Variable_Subs var i)
  
smartChain :: (Maybe Int -> Value) -> (SmartTree,Maybe Int) -> [Statement]
smartChain v (SmartTree (Left root) kids, mbindex) 
   = concat (map (smartChain (mbsubs (Variable_Subs Variable_SP root))) kids) 
     ++ [ Statement_Assignment (Variable_Subs Variable_SP root) 
                               (v mbindex) 
        ]

       
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Embedding of parameters and local variables in frames on the heap for Meta closures (new) by Atze van der Ploeg
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)



-- compute frame sizes (new)

ATTR AllNT [ | | frameSizesMapUp USE {`Map.union`} {Map.empty} : {Map.Map HsName Int} ]

SEM Function 
    | Function lhs.frameSizesMapUp = let callInfoSize = 2 -- 1 for return adress, 1 for dynamic link
                                         size =  (@loc.numberLocals) + (length @parameters) + callInfoSize
                                     in  Map.singleton @name size

ATTR Functions Function Statements Statement Alternatives Alternative [ frameSizesMap : {Map.Map HsName Int} || ]

-- reinsert result of up into top of tree

SEM SilModule
    | SilModule functions.frameSizesMap = @functions.frameSizesMapUp
    
{- Here we use a different frame layout:

0: ret addr
1: dyn link
2: argument 1
3: argument 2
.
.
n + 2 : argument n
n + 3 : local variable 1
n + 4 : local variable 2
.
.
n + m + 2 : local variable m

-}


-- ATTR Function Statement Statements Alternative Alternatives Value Values Variable 
--     [ | |  realNrLocals USE {+} {0}: {Int} ]
-- 
-- -- get the set of locals that is actually used, apperantly the list of @locals of a function is not updated in the last transform...
-- 
-- SEM Variable
--   | Unembedded      lhs . realNrLocals = case @name of
--                                           HNmNr _ (OrigGlobal _) -> 0 -- apperantly if we can somehow see if it was originally a global
--                                           _                      -> 1
  
-- now make a map from the name of a variable to its position in the frame

-- SEM Function
--     | Function body.mEmbedMap = 
--         let  keyValuePairs = zip allNames [callInfoSize..]
--              allNames      = @parameters ++ (Set.toList @body.realLocals)
--              callInfoSize  = 2
--         in   Map.fromList keyValuePairs 
              
-- the actual transformation
    
ATTR AllNT      [ | | trfMeta : SELF ]    
 
ATTR Statement  [ | | trfMetaStats: {[Statement]} ]    
SEM Statement
    | Call      lhs.trfMetaStats
        = let   allocFrame =
                    [Statement_Comment ["Going to call", "Allocate new heap frame"],
                    Statement_Assignment Variable_SPTemp newFramePointer]
                    where newFramePointer       = Value_Cast (Value_Alloc allocFrameSize GCManaged) False -- for obscure reason heapmalloc returns a word!
                          Just allocFrameSize   = Map.lookup @name @lhs.frameSizesMap
                  
                fillArgumentsAndCallinfoInFrame =
                    Statement_Comment ["Fill in arguments and params"] :
                    zipWith Statement_Assignment destinations sources 
                    where
                    sources = 
                        returnAddress ++
                        dynamicLink ++ 
                        arguments
                
                    returnAddress  = [ Value_Label @loc.label ]
                    dynamicLink   = [ Value_Cast (Value_Var Variable_SP) True ]
                    arguments = @args.trfMeta
                    destinations = map (Variable_Subs Variable_SPTemp) [0..]
            
                switchSP = [ Statement_Comment ["Switching SP to new frame"],
                        Statement_Assignment Variable_SP $ Value_Var Variable_SPTemp ]
            
                jump = [ Statement_Call @name False [] ]
            
                label = [ Statement_Label @loc.label ] 
                
                returnIfTailCall = 
                    if @tailJumps 
                    then jumpBackImmediatly
                    else []
                    where
                    jumpBackImmediatly =
                        -- these are defined below
                        saveOldFramePtr       ++
                        restoreDynamicLink    ++
                        jumpToReturnAdress 
                                   
            
            in  allocFrame ++
                fillArgumentsAndCallinfoInFrame ++
                switchSP ++
                jump ++
                label ++
                returnIfTailCall
          
         
          
    | Return    lhs.trfMetaStats 
        =   let setReturnValues =
                    Statement_Comment ["set return values"] :
                    zipWith Statement_Assignment destinations sources 
                    where sources       = @vals.trfMeta
                          destinations  = map returnRegister [0..]
                          returnRegister i = Variable_Subs Variable_RP i 
            -- for the last three see below
            in  setReturnValues       ++
                saveOldFramePtr       ++
                restoreDynamicLink    ++
                jumpToReturnAdress 
          
          
          
          

  | * - Return
        Call   lhs . trfMetaStats = [@loc.trfMeta]

SEM Statements
  | Cons      lhs . trfMeta      = @hd.trfMetaStats ++ @tl.trfMeta


-- a problem with frames on the heap is that we need to know the size of the frame of the function before
-- calling it. This gives us a problem when translating to C, we must call the main silly function from c
-- but we do not know how big the frame of main is. To get around this we let c alloc a frame of size 2 for main, 
-- and then let main alloc the actual frame and copy the data (dynamic link, return adress) from the original frame.

SEM Function
    | Function  lhs.trfMeta
        = Function_Function
            @name
            [] -- no parameters
            [] -- no locals
            ( if hsnShowAlphanumeric @name == "fun_fun0tildemain" 
              then let frameSize = Map.findWithDefault (error "cannot find size of main!") @name @lhs.frameSizesMap
                   in (makeMainFrame frameSize ) ++ @body.trfMeta
              else @body.trfMeta
            )
            
{

makeMainFrame frameSize = [ Statement_Assignment Variable_SPTemp ( Value_Cast (Value_Alloc frameSize GCManaged) False )
                          , Statement_Assignment (Variable_Subs Variable_SPTemp 0) (Value_Var $  Variable_Subs Variable_SP 0)
                          , Statement_Assignment (Variable_Subs Variable_SPTemp 1) (Value_Var $  Variable_Subs Variable_SP 1)
                          , Statement_Assignment (Variable_SP) (Value_Var Variable_SPTemp) 
                          ]
}
        
SEM Variable
  | Unembedded   lhs.trfMeta =  embedUsing ( strategyOnHeapFrame  @lhs.numberParameters ) 
                                       @lhs.embedMap 
                                       @name
                                       
SEM Value
  | This         lhs.trfMeta = Value_Cast (Value_Var Variable_SP) True

ATTR Variable [ | | self : SELF ]

SEM Value
    | OffsetVar  lhs.trfMeta = let (HNmNr nameNr _) = @var -- note that we use here that nrs are globally unique
                                   offset = case Map.lookup nameNr @lhs.frameOffsetMap of
                                                Just off -> off
                                                Nothing -> error $ "No offset found in map for var with nr:" ++ (show nameNr)
                               in  Value_Var $ Variable_Subs @frame.trfMeta offset

-- get the offsets of all local variables and parameters
ATTR Functions Function Statements Statement Alternatives Alternative Constant Variable Values Value  [frameOffsetMap : {Map.Map Int Int} | | frameOffsetMapUp USE {`Map.union`} {Map.empty} : {Map.Map Int Int} ]   

SEM SilModule
  | SilModule  functions.frameOffsetMap = @functions.frameOffsetMapUp
-- 
SEM Function
  | Function   lhs.frameOffsetMapUp =  let embed x = embedUsing ( strategyOnHeapFrame  (length @parameters) ) 
                                                        @body.embedMap 
                                                        x
                                           offset embedded = case embedded of 
                                                                Variable_Subs Variable_SP offset -> offset
                                                                _                                -> error "No offset found"
                                           allVars = @parameters ++ @locals
                                           offsets = map (offset . embed) allVars
                                           nameNr x = case x of
                                                        (HNmNr nameNr  _) -> nameNr
                                                        _                 -> error "encountered non nr name when constucting frame offset map"
                                           nameNrs  = map nameNr allVars
                                       in  Map.fromList $ zip nameNrs offsets
                                       

{
-- shared between call and return
saveOldFramePtr = 
    [ Statement_Comment ["save old frame pointer"] ,
    Statement_Assignment Variable_Aux $ Value_Dereference $ Value_Var Variable_SP  ]

restoreDynamicLink =
    [ Statement_Comment ["restoring dynamic link"],
    Statement_Assignment Variable_SP dynamicLinkLocation ] 
    where dynamicLinkLocation = 
            Value_Cast (Value_Var $ Variable_Subs Variable_SP dynlinkoffset) False
          dynlinkoffset = 1

jumpToReturnAdress = 
    [  Statement_Return [] returnAdressLocation ]
    where returnAdressLocation = Value_Var Variable_Aux
    
}






        
%%]