\chapter{Extensions}
\label{cap:Extensions}
Up until now the type checker can only type one sentence expressions. It cannot actually type check a full function because of the fact that there is no support for case statements. This means that type checking an entire Haskell module is also out of the question. This chapter outlines the steps taken to implement type checking of entire modules.

\section{Tuples}
Because of the way functions are desugared in EH, support for tuples need to be added before case expressions can be evaluated. UHC implements tuples quite differently then GHC, namely as a recursive datatype. The reason for this is that it makes it easier to implement extensible records.

Inside the \emph{Expr} datatype there is this definition:
\begin{code}
  con Rec
    recExpr       :  RecExpr
\end{code}

This particular constructor represents a tuple expression. \emph{RecExpr} is defined as:

\begin{figure}[H]
\begin{minipage}[t]{0.5\linewidth}
\begin{code}
data RecExpr
  con Empty
  con Ext
    recExpr     :  RecExpr
    mbNm        :: (Maybe HsName)
    expr        :  Expr
  con Upd
    recExpr     :  RecExpr
    mbNm        :: HsName
    expr        :  Expr
  con Expr
    expr        :  Expr
\end{code}
\end{minipage}
\begin{minipage}[t]{0.5\linewidth}
\begin{code}
itf RecExpr
  visit infer
    inh pre  :: Prefix
    inh env  :: Gamma
    inh frs  :: Int
    inh ast  :: RecExpr
    syn pre  :: Prefix
    syn sub  :: Env
    syn res  :: Maybe RowTyExpr
    syn frs  :: Int 
\end{code}
\end{minipage}
\label{record}
\caption{Definition of a record along with the interface}
\end{figure}
Figure \ref{record} also shows the interface defined for type checking tuples. The result is a \emph{RowTyExpr}, which is the type of a tuple. The \emph{Upd} constructor is ignored since there is no support for records in this version.

\paragraph{extending the datasem Expr}
Extending the Expr datatype is straight forward, the only code needed is

\begin{code}
clause Rec
   recExpr.pre  = lhs.pre
   recExpr.env  = lhs.env
   recExpr.frs  = lhs.frs
   
   loc.res =  let e = recExpr.res
              in case e of
                   Nothing  ->  error "Type inference failed in tuple"
                   Just ty  ->  TyExpr_AppTop $
                                   TyExpr_App
                                      (TyExpr_Con (mkName "_Rec"))
                                      (TyExpr_Row ty)
   
   (loc.q1, loc.q2) = split (recExpr.pre, domain lhs.pre)
   lhs.res = return  $ desugar 
                     $ TyScheme_Sugar loc.q2 
                     $ TyScheme_SystemF loc.res
   lhs.sub  = recExpr.sub
   lhs.pre  = loc.q1
   lhs.frs  = recExpr.frs
\end{code}
The type of the tuple is inferred and wrapped as a call to a special constructor "\_Rec" and then generalized. This is all that is needed in \emph{Expr}

\paragraph{Implementing RecExpr}
The code relevant to the implementation of type inference for a \emph{RecExpr} is:

\begin{code}
datasem RecExpr monad IO
 default? sub = const empty
 default? pre = last
 default? frs = last
 default? res = const Nothing
 clause Ext
   recExpr.pre  = lhs.pre
   recExpr.env  = lhs.env
   recExpr.frs  = lhs.frs
   
   expr.pre  = recExpr.pre
   expr.env  = appAll recExpr.sub lhs.env
   expr.frs  = recExpr.frs
\end{code}
The recursive part of the \emph{RecExpr} needs to be inferred first. After that the resulting substitutions are applied to the $\Gamma$ to update the shared values. This is important in expressions such as |\f -> (f 1, f 'a')| where |f| is shared between elements in the tuple. With the recursive part type checked and the new prefix, the type of the expression at the current position of the tuple can be inferred.

\begin{code}    
   (loc.q1, loc.frs, loc.res)
     =  let  e  = recExpr.res
             t  = expr.res
        in case (e, t) of
             (Nothing, u_s) -> error ... -- tuple element infer failed
             (u_s, Nothing) -> error ... -- expr infer failed
             (Just rty,Just ty) -> 
                let  (typ, frs,  u_s)  = renameBound expr.frs ty 
                     (q,   e        )  = second  (RowTyExpr_Ext rty loc.mbNm) 
                                                 (deep_explode' expr.pre typ)
                in (q, frs, e)
\end{code}
\emph{rty} represents the type of the recursive RecExpr and the \emph{ty} is the type of the current expression. If both are not Nothing then the current type is renamed and its quantifiers are removed and moved to the prefix. Generalization in the \emph{Expr} datasem will fully quantify them again. This is done because the type of |(id, id)| should be |forall a. b. (a -> a, b -> b)| and not |(forall a. a -> a, forall a. a -> a)|. Another possibility to handle this is to generate two new fresh variables and extend the environment with the these new variables instead:

\begin{code}
                let  (typ, frs, u_s)  = renameBound expr.frs ty 
                     (a1 , frs1    )  = fresh frs
                     (a2 , frs2    )  = fresh frs1
                     (q,   e       )  = let (Q_1, theta_1) = extend (expr.pre, a1 >= TyScheme_SystemF rty)
                                           (Q_2, theta_2) = extend (Q_1, a2 >= TyScheme_SystemF typ)

                                       in second  (RowTyExpr_Ext (theta_1 ^ a1) loc.mbNm) 
                                                  (deep_explode' Q_2 (theta_2 ^ a2))
                in (q, frs, e)
\end{code}
The first approach was chosen because it generates types that the average Haskell is used to and because there is no benefit to using type schemes as the type of tuples.

\begin{code}                              
      lhs.sub  = recExpr.sub `munion` expr.sub
      lhs.res  = return loc.res
      lhs.frs  = loc.frs
      lhs.pre  = loc.q1
   clause Empty
      lhs.res  = return RowTyExpr_Empty
\end{code}
The resulting type is then simply returned along with the substitutions and the new prefix. 

\section{Case expressions}
UHC desugars a function with multiple binding into a single let with a case expression inside. This is done in two ways
\paragraph{Single argument functions}
Consider the function \emph{f} defined as:
\begin{code}
f True  = False
f x     = x && True
\end{code}
This is desuged by UHC into:
\begin{code}
let f = \x1 -> case x1 of
                 True -> False
                 x -> (&& x True)
\end{code}
This also shows that infix applications are made into the normal application style.

\paragraph{multiple argument functions}
Multiple argument functions are desugared somewhat differently, consider the function \emph{q}:
\begin{code}
q True  x = id x
q False x = (+x)
\end{code}
which is desugared into:
\begin{code}
let q = \x1 x2 -> case (x1,x2) of
                    (True,x) -> id x
                    (False,x) -> \x_0_3_0 -> (+ x_0_3_0 x)
\end{code}

In the abstract syntax of EH there is a flag to indicate if there are multiple arguments. Adding support for tuples means adding a definition for the \emph{Case} clause in the datasem of the \emph{Expr} type. The datatype definition for the constructor \emph{Case} in \emph{Expr} is:
\begin{code}
  con Case
    expr          :  Expr
    alts          :  CaseAlts
    mbCaseIds     :: (Maybe UIDS)
    caseFailS     :: UIDS
    isTupOfArg    :: Bool
\end{code}

With this definition the datasem of \emph{Expr} can be expanded with:

\begin{code}
   clause Case
      expr.env  = lhs.env
      expr.pre  = lhs.pre
      expr.frs  = lhs.frs
      
      -- check if infer of expression succeeded
      loc.etype = maybe (error ...) id expr.res
\end{code}
The type of the scrutinee is first inferred. This is usually returns a completely polymorphic types since the scrutinee is usually a variable (or a tuple thereof). 

\begin{code}
   alts.exp  = loc.etype
   alts.env  = appAll expr.sub lhs.env
   alts.frs  = expr.frs
   alts.pre  = expr.pre
   
   child s : UnifyScheme = unifyScheme
   s.pre  = alts.pre
   s.ty1  = loc.etype
   s.ty2  = caseLHS alts.res
   s.frs  = alts.frs
\end{code}

The types of the case alternatives are inferred next. The result of which is a record which contains the inferred type for all the left hand sides of the case alternatives (unified together) and the type of all the right hand sides of the case alternatives (unified together). The type of the scrutinee is then unified with that of the left-hand sides of the case alternatives.

\begin{code}       
   (loc.q1, loc.q2) = split (s.pre, domain lhs.pre)
   
   lhs.res = return  $ desugar 
                     $ TyScheme_Sugar loc.q2 
                     $ appAll alts.sub 
                     $ body alts.res
   lhs.sub  = s.sub `pick` alts.sub `pick` expr.sub
   lhs.pre  = loc.q1
   lhs.frs  = s.frs
\end{code}
At the end generalization is done and the fully quantified type is returned. This type consists of the substitutions gathered during inference applied to the type of the right-hand side of the case expressions (to insure that all substitutions they have all been applied). The |pick| function adds to the first environment anything new from the second environment. In essence it is the same as |nub . concat|.

The interface for \emph{CaseAlts} is defined as:
\begin{code}
itf CaseAlts
  visit infer
    inh ast  :: CaseAlts
    inh env  :: Gamma
    inh pre  :: Prefix
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn res  :: CaseType
    syn frs  :: Int 
\end{code}

The datatype |CaseType| is defined as 

\begin{code}
data CaseType = CaseType  
         {  caseLHS  ::  TyScheme
         ,  body     ::  TyScheme
         }
\end{code}

and returns the type inferred at both sides of a case alternative.
The full implementation will not be covered here, but those interested can look it up in the source code.

\subsection{typing rules expression}
Inferring the type of case expressions comes down two the following typing rules which are self explanatory:

\begin{prooftree}
		\AxiomC{$Q,\Gamma \vdash e_1 : \varphi_1 \quad Q,\Gamma \vdash e_2 : \varphi_2$}
	\LeftLabel{Case:\quad}
		\UnaryInfC{$Q,\Gamma \vdash \textbf{case} \hspace{3pt} e_1 of e_2 : \varphi_2$}
\end{prooftree}

\begin{prooftree}
		\AxiomC{$Q,\Gamma \vdash p_1 : \varphi_1 \rightarrow e_1 : \varphi_2 \quad Q,\Gamma \vdash p_2 : \varphi_3 \rightarrow e_2 : \varphi_4 \newline \quad \varphi_5 \sqsubset \varphi_1 \wedge \varphi_3 \quad \varphi_6 \sqsubset \varphi_2 \wedge \varphi_4$}
	\LeftLabel{CaseAlt:\quad}
		\UnaryInfC{$Q,\Gamma \vdash p : \varphi_5 \rightarrow e : \varphi_6$}
\end{prooftree} 
\section{Fixpoint recursion}
Typing fixpoint recursive functions is a simple yet needed extension. What this essentially comes down to is providing support for \emph{letrec}. As an example the function fix defined as

\begin{code}
fix f = f (fix f)
\end{code} 

Would be typed as $\forall \alpha \beta. (\alpha \rightarrow \beta) \rightarrow \beta$ without this support. This is because after giving a temporary type for \emph{fix} based on what was known about \emph{f} at the application site, when we later learn more about the value of \emph{f} the type of \emph{fix} is never updated.

Type checking is essentially building up a list of constraints and then solving these constraints. In this case the constraints are the substitutions that are being build every time extra information about a type becomes available.
This means that all the needed bits of information are available to reconstruct the type there should be, and the type that was inferred. In order to provide support for letrec three things need to be done:

\begin{itemize}
\item Apply the substitutions (constraints) gathered during inference to the original type of the binding. Remember that functions are preprocessed and given a polymorphic type variable as a type. This gives the type that should be available logically from the constraints.
\item Solve the constraints. This is done by unifying the type returned from the inference of the expression and with the type reconstructed in step 1. This fills in any missing information between the types.
\item Apply the substitutions gained from the unification to the inferred type. This then results in the final and correct type for the expression.
\end{itemize}

Since Haskell does not have a special keyword for \emph{letrec} the same code is also called for normal functions. In the case of normal (non fixpoint recursive) functions the reconstructed type would be the same as the type that was inferred. Unify would just return an empty substitution.

\section{Type annotations}
Type annotations are nothing special. If the type that is being annotated with a new type has the type of a polymorphic variable then that type is just replaced in the $\Gamma$ with the annotated type. Since there is no bidirectional typing giving a type signature for a function is not supported. The support for annotation is just enough to allow annotation on variables.
