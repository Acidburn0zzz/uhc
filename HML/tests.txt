GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
Preparing to run 143 tests.
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                    -= Standard Prelude Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
($) ...                                                                                                                      [RIGHT]
($) :: (a -> b) -> a -> b ...                                                                                                [RIGHT]
not ...                                                                                                                      [RIGHT]
not :: Bool -> Bool ...                                                                                                      [RIGHT]
(>=) ...                                                                                                                     [RIGHT]
(>=) ...                                                                                                                     [RIGHT]
(>=) :: a -> a -> Bool ...                                                                                                   [RIGHT]
(>=) :: a -> a -> Bool ...                                                                                                   [RIGHT]
(++) ...                                                                                                                     [RIGHT]
(++) :: List a -> List a -> List a ...                                                                                       [RIGHT]
(.) ...                                                                                                                      [RIGHT]
id ...                                                                                                                       [RIGHT]
id :: a -> a ...                                                                                                             [RIGHT]
($) ...                                                                                                                      [RIGHT]
const ...                                                                                                                    [RIGHT]
app ...                                                                                                                      [RIGHT]
app id ...                                                                                                                   [RIGHT]
app id ...                                                                                                                   [RIGHT]
app (const 1) ...                                                                                                            [RIGHT]
app (const 1) ...                                                                                                            [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                          -= Tuple Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
foo ...                                                                                                                      [RIGHT]
foo :: a -> (Int, a, Int) ...                                                                                                [WRONG]
\x -> (x, x) ...                                                                                                             [RIGHT]
(id, id) ...                                                                                                                 [RIGHT]
(id, id) ...                                                                                                                 [RIGHT]
(Nil, Nil) ...                                                                                                               [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                    -= Case Unification Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
map ...                                                                                                                      [RIGHT]
g ...                                                                                                                        [RIGHT]
q ...                                                                                                                        [RIGHT]
otherwise ...                                                                                                                [RIGHT]
filter ...                                                                                                                   [RIGHT]
filter :: (a -> Bool) -> List a -> List a ...                                                                                [RIGHT]
f ...                                                                                                                        [RIGHT]
qsort ...                                                                                                                    [RIGHT]
qsort ...                                                                                                                    [RIGHT]
qsort :: List a -> List a ...                                                                                                [RIGHT]
qsort :: List a -> List a ...                                                                                                [RIGHT]
foldr ...                                                                                                                    [RIGHT]
foldr :: (a -> b -> b) -> b -> List a -> b ...                                                                               [RIGHT]
foldr ...                                                                                                                    [RIGHT]
foldr :: (a -> b -> b) -> b -> List a -> b ...                                                                               [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                -= Standard H&M Application test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
map (id id) (Cons 1 Nil) ...                                                                                                 [RIGHT]
((+1). id) ...                                                                                                               [RIGHT]
((+1). id) ...                                                                                                               [RIGHT]
(m . n) ...                                                                                                                  [RIGHT]
map (id id) ...                                                                                                              [RIGHT]
map (id id) ...                                                                                                              [RIGHT]
id id ...                                                                                                                    [RIGHT]
\f -> Cons (f 0) (Cons (f 'a') Nil) ...                                                                                      [RIGHT]
Cons 1 Nil ...                                                                                                               [RIGHT]
Cons id Nil ...                                                                                                              [RIGHT]
map map ...                                                                                                                  [RIGHT]
idF ...                                                                                                                      [RIGHT]
\a -> Nil ...                                                                                                                [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                    -= Mutual recursion Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
foo ...                                                                                                                      [WRONG]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                   -= Checking Simple lambdas =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
\a b -> a ...                                                                                                                [RIGHT]
\a b c -> a ...                                                                                                              [RIGHT]
\_ -> 'o' ...                                                                                                                [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                 -= Standard Hindley-Milner Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
\x -> x ...                                                                                                                  [RIGHT]
\f x ->f x ...                                                                                                               [RIGHT]
inc True ...                                                                                                                 [WRONG]
let i = \x -> x in i i ...                                                                                                   [RIGHT]
\i -> i i ...                                                                                                                [WRONG]
\i -> (i 1, i True) ...                                                                                                      [WRONG]
single id ...                                                                                                                [RIGHT]
choose (\x y-> x) (\x y-> y) ...                                                                                             [RIGHT]
choose id ...                                                                                                                [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                      -= Impredicative application & Higher rank arguments =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
xauto ...                                                                                                                    [RIGHT]
auto ...                                                                                                                     [RIGHT]
\(i:: forall a. a -> a) -> i i ...                                                                                           [RIGHT]
auto id ...                                                                                                                  [RIGHT]
apply auto id ...                                                                                                            [RIGHT]
(single :: (forall a. a -> a) -> List (forall a. a -> a)) id ...                                                             [RIGHT]
runST (returnST 1) ...                                                                                                       [RIGHT]
runST (newRef 1) ...                                                                                                         [WRONG]
apply runST (returnST 1) ...                                                                                                 [RIGHT]
map xauto ids ...                                                                                                            [RIGHT]
map xauto (map xauto ids) ...                                                                                                [WRONG]
map auto ids ...                                                                                                             [RIGHT]
map auto (map auto ids) ...                                                                                                  [RIGHT]
head ids ...                                                                                                                 [RIGHT]
tail ids ...                                                                                                                 [RIGHT]
apply tail ids ...                                                                                                           [RIGHT]
map head (single ids) ...                                                                                                    [RIGHT]
apply (map head) (single ids) ...                                                                                            [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                   -= Infinite poly types Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
(undefined :: some a. List (a -> a) -> Int) (undefined :: some c. List ((forall d. d -> c) -> c)) ...                        [WRONG]
(undefined :: some a. List (a -> a) -> Int) (undefined :: List ((forall d. d -> d) -> (Int -> Int))) ...                     [WRONG]
(undefined :: some a. List (a -> (forall b. b -> b)) -> Int) (undefined :: some c. List ((forall d. d -> d) -> c)) ...       [WRONG]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                        -= GHC choke test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
choose id auto ...                                                                                                           [RIGHT]
choose auto id ...                                                                                                           [RIGHT]
choose xauto xauto ...                                                                                                       [RIGHT]
choose id xauto ...                                                                                                          [WRONG]
choose xauto id ...                                                                                                          [WRONG]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                     -= These fail in ghc :) =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
choose Nil ids ...                                                                                                           [RIGHT]
choose xauto ids ...                                                                                                         [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                    -= Escaping Skolems Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
\x -> auto x ...                                                                                                             [WRONG]
let poly (xs :: List (forall a. a -> a)) = 1 in \x -> poly x ...                                                             [WRONG]
\x -> (x :: List (forall a. a -> a)) ...                                                                                     [WRONG]
\x -> let polys (xs :: List (forall a. a -> a)) = 1; f y = x in polys (Cons (f::some a. forall b. b -> a) Nil) ...           [WRONG]
ids :: forall b. List (forall a. a -> b) ...                                                                                 [WRONG]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                   -= co/contra Variance Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
let g (x::(forall a. a -> a) -> Int) = x id; f (x :: Int -> Int) = x 1 in g f ...                                            [WRONG]
let g (x::(forall a. a -> a) -> Int) = x id; f (x :: Int -> Int) = x 1 in g (\\(x :: forall a. a -> a) -> f x) ...           [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                   -= Shared Polymorphism Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
let f (x :: List (forall a.a -> a)) = x in let g (x :: List (Int -> Int)) = x in let ids = Cons id Nil in (f ids, g ids) ... [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                    -= Rigid annotations Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
single (id :: forall a. a -> a) ...                                                                                          [RIGHT]
(id :: forall a. a -> a) 1 ...                                                                                               [RIGHT]
(id :: some a. a -> a) 1 ...                                                                                                 [RIGHT]
\x -> ((\y -> x) :: some a. forall b. b -> a) ...                                                                            [RIGHT]
\(f :: forall a. a -> a) -> ((f f) :: forall a. a -> a) ...                                                                  [RIGHT]
revapp (id :: forall a. a -> a) auto ...                                                                                     [RIGHT]
choose inc id ...                                                                                                            [RIGHT]
choose inc (id :: forall a. a -> a) ...                                                                                      [RIGHT]
choose inc (id :: some a. a -> a) ...                                                                                        [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                   -= N-ary Application Tests =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
revapp id auto ...                                                                                                           [RIGHT]
let f = revapp id in f auto ...                                                                                              [RIGHT]
let f = revapp (id :: forall a. a -> a) in f auto ...                                                                        [RIGHT]
head ids 1 ...                                                                                                               [RIGHT]
auto id 1 ...                                                                                                                [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                              -= Sharing of Polymorphic types Test =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
let ids = single id in (map auto ids, append (single inc) ids) ...                                                           [RIGHT]
single id ...                                                                                                                [RIGHT]
choose id ...                                                                                                                [RIGHT]
choose id inc ...                                                                                                            [RIGHT]
choose id auto ...                                                                                                           [RIGHT]
\x y -> x ...                                                                                                                [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                    -= Type Propagation Tests =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
single id :: List (forall a. a -> a) ...                                                                                     [RIGHT]
returnST 1 :: forall s. ST s Int ...                                                                                         [RIGHT]
auto id :: Int -> Int ...                                                                                                    [RIGHT]
head ids 1 :: Int ...                                                                                                        [RIGHT]
head ids :: Int -> Int ...                                                                                                   [RIGHT]
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                                        -= Eta Poly Tests =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
\x -> auto x ...                                                                                                             [RIGHT]
\x -> (auto x, x 1) ...                                                                                                      [WRONG]
\x -> (auto x, (x :: forall a. a -> a) 1) ...                                                                                [RIGHT]
\x -> (auto x, (x :: Int -> Int) 1) ...                                                                                      [WRONG]
Testing completed.
 ---------------------------------------------------------------------------------------------------------------------------------- 
                                            -= SUCCEEDED: 132	 FAILED: 11	TOTAL: 143 =-
 ---------------------------------------------------------------------------------------------------------------------------------- 
Leaving GHCi.
