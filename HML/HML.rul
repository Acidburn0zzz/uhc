{
{-# LANGUAGE BangPatterns          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances  #-}
module HML where

import Control.Monad.Error
import Pretty   
import qualified Data.Map as M
import Control.Monad
import Control.Arrow hiding (app)
import Control.Applicative((<$>), (<|>))

import Data.List
import Data.Maybe hiding (mapMaybe)

import EH8.EH
import EH8.Base.HsName
import EH8.Ty(tyQu_Forall)

import EqHML
import Utils
-- import UtilsInterop
-- import UtilsWorking

import EH.Util.Pretty hiding (pp, empty)
}
    
data TyQu
  con TyForall
    
data TyExpr
  con Con
    nm        :: HsName
  con App
    func      :: TyExpr
    arg       :: TyExpr
  con AppTop
    tyExpr    :: TyExpr
  con Parens
    tyExpr    :: TyExpr
  con Ann
    ann       :: TyExprAnn
    tyExpr    :: TyExpr
  con Wild
  con Mono
  con Var
    nm        :: HsName
  con VarWild
    mm        :: HsName
  con Quant
    qu        :: TyQu
    tyVar     :: HsName
    tyExpr    :: TyExpr
  con Forall
    qu        :: TyQu
    tyVar     :: [HsName]
    tyExpr    :: TyExpr    
  con Row
    rowTyExpr :: RowTyExpr
    
data TyVar
  con Var
    nm      :: HsName
    
type TyVars : [TyVar]
    
-- Type Index (a1 >= TyQuantifiedScheme)
data TyIndex
  con Group
    varnm   :: HsName
    bounds  :: TyQuantifiedScheme
    
-- Type Schemes
data TyScheme
  con Quant
    subst    :: Scheme
    tyExpr   :: TyScheme
  con SystemF
    tyExpr   :: TyExpr
  con Bottom
  -- These next two are just used internally
  con Sugar
     prefix  :: Prefix
     tyExpr  :: TyScheme
  con Forall
     tyQuant :: [HsName]
     tyExpr  :: TyScheme

-- A simple tybound e.f. (a >= phi)
data Scheme
  con Simple
    varnm  :: HsName
    bounds :: TyScheme
    
data DataFieldExpr
  con Upd
    dataFieldExpr  :  DataFieldExpr
    nm             :: HsName
    expr           :  Expr
  con Con
    nm             :: HsName
  con Expr
    expr           :  Expr
   
data DataFieldPatExpr
  con Ext
    dataFieldPatExpr  :: DataFieldPatExpr
    nm                :: HsName
    patExpr           :: PatExpr
  con Con
    nm                :: HsName
    
data RecExpr
  con Empty
  con Ext
    recExpr     :  RecExpr
    mbNm        :: (Maybe HsName)
    expr        :  Expr
  con Upd
    recExpr     :  RecExpr
    mbNm        :: HsName
    expr        :  Expr
  con Expr
    expr        :  Expr
    
data RecPatExpr
  con Empty
  con Ext
    recPatExpr  :  RecPatExpr
    mbNm        :: (Maybe HsName)
    patExpr     :: PatExpr
  con Expr
    patExpr     :: PatExpr
    
data RowTyExpr
  con Empty
  con Ext
    rowTyExpr       :: RowTyExpr
    mbNm            :: (Maybe HsName)
    tyExpr          :: TyExpr
    
data KiExpr
  con Con
    nm       :: HsName
  con Var
    nm       :: HsName
  con App
    func     :: KiExpr
    arg      :: KiExpr
  con AppTop
    kiExpr   :: KiExpr
  con Parens
    kiExpr   :: KiExpr
  con Ann
    ann      :: KiExprAnn
    kiExpr   :: KiExpr
    
data Expr
  con IConst
    int           :: Int
  con CConst
    char          :: Char
  con Con
    nm            :: HsName
  con Var
    nm            :: HsName
  con App
    func          :  Expr
    arg           :  Expr
  con Let
    isStrict      :: Bool
    decls         :  Decls
    body          :  Expr
  con Lam
    arg           :: PatExpr
    body          :  Expr
  con AppTop
    expr          :  Expr
  con Parens
    expr          :  Expr
  con TypeAs
    tyExpr        :: TyExpr
    expr          :  Expr
  con Ann
    ann           :: ExprAnn
    expr          :  Expr
  con AppImpred
    func          :  Expr
    arg           :  Expr
  con SConst 
    str           :: String
  con Case
    expr          :  Expr
    alts          :: CaseAlts
    mbCaseIds     :: (Maybe UIDS)
    caseFailS     :: UIDS
    isTupOfArg    :: Bool
  con DataFields
    dataFieldExpr :: DataFieldExpr
  con Rec
    recExpr       :: RecExpr
  con Sel
    expr          :  Expr
    lbl           :: HsName
  con Undefined
  con CaseAltFail 
    caseId        :: UID
    
data PatExpr
  con IConst
    int              :: Int
  con CConst
    char             :: Char
  con Con
    nm               :: HsName
  con Var
    nm               :: HsName
  con VarAs
    nm               :: HsName
    patExpr          :: PatExpr
  con App
    func             :: PatExpr
    arg              :: PatExpr
  con AppTop
    patExpr          :: PatExpr
  con Parens
    patExpr          :: PatExpr
  con Ann
    ann              :: PatExprAnn
    patExpr          :: PatExpr
  con TypeAs
    tyExpr           :: TyExpr
    patExpr          :: PatExpr
  con SConst
    str              :: String
  con Rec
    recPatExpr       :: RecPatExpr
  con DataFields
    dataFieldPatExpr :: DataFieldPatExpr
  con Irrefutable
    patExpr          :: PatExpr
    
data CaseAlt
  con Pat
    patExpr   :: PatExpr
    expr      :  Expr

type CaseAlts : [CaseAlt]
    
data DataConstr
  con Constr
    conNm      :: HsName
    fields     :  DataFields
    
type DataConstrs : [DataConstr]

data DataField
  con Field
    mbLabels     :: (Maybe [HsName])
    tyExpr       :: TyExpr
    
type DataFields : [DataField]
   
data ExprAnn
  con Empty
  
data TyExprAnn
  con Empty

data PatExprAnn
  con Empty
  
data KiExprAnn
  con Empty
  
data Decl
  con TySig
    nm         :: HsName
    tyExpr     :: TyExpr
  con Val
    patExpr    :: PatExpr
    expr       :  Expr
  con Data
    isNewType  :: Bool
    tyNm       :: HsName
    tyVars     :: TyVars
    constrs    :: DataConstrs
  con KiSig
    nm         :: HsName
    kiExpr     :: KiExpr
  con FFI
    callconv   :: FFIWay
    safety     :: String
    impEnt     :: String
    nm         :: HsName
    tyExpr     :: TyExpr
  
type TyExprs : [TyExpr]
type Decls   : [Decl]
  
itf Expr
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh ast :: Expr
    inh exp :: Expr
    inh frs :: Int
    syn pre :: Prefix
    syn sub :: Env
    syn res :: Maybe TyScheme
    syn frs :: Int
    
itf RecExpr
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh frs :: Int
    inh ast :: RecExpr
    syn pre :: Prefix
    syn sub :: Env
    syn res :: Maybe RowTyExpr
    syn frs :: Int  
    
itf DataConstrs
  visit findTypes
    inh ast :: DataConstrs
    inh nm  :: TyExpr
    syn ty  :: [(HsName, TyExpr)]
    
itf DataConstr
  visit findType
    inh ast :: DataConstr
    inh nm  :: TyExpr
    syn ty  :: (HsName, TyExpr)
    
itf DataFields
  visit findTypes
    inh ast :: DataFields
    syn ty  :: TyExprs
    
itf DataField
  visit findType
    inh ast :: DataField
    syn ty  :: TyExpr
    
itf Decls
  visit infer
    inh ast :: Decls
    inh pre :: Prefix
    inh env :: Gamma
    inh sig :: Gamma -- A collection of type signatures
    inh frs :: Int
    syn pre :: Prefix
    syn env :: Gamma
    syn sig :: Gamma
    syn sub :: Env
    syn frs :: Int
    
itf Decl
  visit infer
    inh ast :: Decl
    inh pre :: Prefix
    inh env :: Gamma
    inh sig :: Gamma -- A collection of type signatures
    inh frs :: Int
    syn pre :: Prefix
    syn env :: Gamma -- These declarations can update the gamma in a non-local way, so we have to return the new one
    syn sig :: Gamma -- A collection of type signature, if at the end this is not empty then we have a sig without a let
    syn sub :: Env
    syn frs :: Int

itf RecPatExpr
  visit vars
    inh ast    :: RecPatExpr
    syn var_nm :: [HsName]
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh frs :: Int
    syn pre :: Prefix
    syn sub :: Env
    syn env :: Gamma -- A RecPatExpr is still a pattern and so can extend the gamma
    syn res :: Maybe RowTyExpr
    syn frs :: Int      
 
itf PatExpr
  visit vars
    inh ast    :: PatExpr
    syn var_nm :: [HsName]
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh exp :: PatExpr
    inh frs :: Int
    syn pre :: Prefix
    syn env :: Gamma -- A PatExpr might want to expand the Gamma, so we need to again return it.
    syn sub :: Env
    syn res :: TyScheme
    syn frs :: Int
    
{
data CaseType = CaseType { caseLHS :: TyScheme
                         , body    :: TyScheme
                         }
                         
instance Pretty CaseType where
    pp (CaseType a b) = pp a ++ " -> " ++ pp b
}
    
itf CaseAlts
  visit infer
    inh exp :: TyScheme
    inh ast :: CaseAlts
    inh env :: Gamma
    inh pre :: Prefix
    inh frs :: Int
    syn pre :: Prefix
    syn sub :: Env
    syn res :: CaseType
    syn frs :: Int 
    
itf CaseAlt
  visit infer
    inh exp :: TyScheme
    inh ast :: CaseAlt
    inh env :: Gamma
    inh pre :: Prefix
    inh frs :: Int
    syn pre :: Prefix
    syn frs :: Int
    syn sub :: Env
    syn res :: CaseType
    
datasem CaseAlt monad IO
  clause Pat
    child patExpr : PatExpr
    
    patExpr.ast = loc.patExpr
    patExpr.pre = trace ("Pat: " ++ pp lhs.pre) lhs.pre
    patExpr.env = lhs.env
    patExpr.exp = loc.patExpr
    patExpr.frs = lhs.frs
    
    expr.exp = loc.expr
    expr.pre = patExpr.pre
    expr.env = patExpr.env
    expr.frs = patExpr.frs
    
    loc.pat = appAll expr.sub patExpr.res
    
    loc.ety = trace ("Expr: " ++ pp loc.expr ++ ":" ++ pp expr.res ++ "\nPatExpr: " ++ pp loc.patExpr ++ ":" ++ pp patExpr.res) $ maybe (error $ "Type inference of the expression '" ++ pp loc.expr ++ "' has failed") id expr.res
    -- (loc.q1, loc.q2) = split(patExpr.pre, domain patExpr.res \\ domain expr.pre)
    loc.pre = expr.pre -- `munion` loc.q1
   (loc.q4, loc.t2) = trace ("Deep2: " ++ pp loc.pre ++ " ^^ " ++ pp loc.ety) $ deep_explode loc.pre loc.ety
    
    lhs.pre = trace ("Prefix: " ++ pp loc.q4) loc.q4
    lhs.frs = expr.frs
    lhs.sub = expr.sub -- s.sub -- `remove` (domain patExpr.res \\ domain expr.sub) -- `munion` expr.sub
    lhs.res = let e = CaseType loc.pat loc.t2
              in trace ("case finished: " ++ pp e ++ " {" ++ pp expr.sub ++ "}") e
    
datasem CaseAlts monad IO
  clause Cons
    hd.exp = lhs.exp
    hd.env = lhs.env    
    hd.pre = lhs.pre
    hd.frs = lhs.frs
    
    tl.exp = appAll hd.sub lhs.exp
    tl.env = lhs.env
    tl.pre = let e = hd.pre in trace ("TL in: " ++ pp e) e -- `merge` lhs.pre in trace ("TL in: " ++ pp e) e
    tl.frs = hd.frs
        
    loc.ty_tl = trace ("CaseAlts tl: " ++ pp tl.res ++ " ** " ++ pp tl.sub) tl.res
    loc.ty_hd = trace ("CaseAlts hd: " ++ pp hd.res ++ " ** " ++ pp hd.sub) hd.res
    
    child s1 : UnifyScheme = unifyScheme
    
    s1.pre = trace ("TL out/S1 in:" ++ pp tl.pre) tl.pre
    s1.ty1 = appAll tl.sub $ caseLHS loc.ty_hd
    s1.ty2 = appAll hd.sub $ caseLHS loc.ty_tl
    s1.frs = tl.frs
    
    child s2 : UnifyScheme = unifyScheme
    
    loc.ep = s2.sub `pick` s1.sub
    loc.subs = tl.sub `pick` hd.sub
    
    s2.pre = trace ("S1 out/S2 in:" ++ pp s1.pre ++ "@Subs: " ++ pp loc.subs) s1.pre
    s2.ty1 = appAll s1.sub $ body loc.ty_hd
    s2.ty2 = appAll s1.sub $ body loc.ty_tl
    s2.frs = s1.frs
    
    lhs.frs = s2.frs
    lhs.res = let e = CaseType (appAll s2.sub s1.ty) s2.ty
              in trace ("CaseAlts res: " ++ pp e) e
    lhs.sub = let f1 = trace ("@S1:   " ++ pp s1.sub) $ trace ("@S2:   " ++ pp s2.sub) 
              in  f1 $ loc.subs `pick` loc.ep -- tl.sub `munion` hd.sub `munion` s2.sub `munion` s1.sub
    (loc.q3, loc.q4) = split (tl.pre, domain loc.subs)
    
    lhs.pre = trace ("S2 out/ret:" ++ pp s2.pre) s2.pre 
  clause Nil
    (loc.a, loc.frs1) = fresh lhs.frs
    loc.exp_a  = TyScheme_SystemF $ TyExpr_Var loc.a
    (loc.b, loc.frs2) = fresh loc.frs1
    loc.exp_b  = TyScheme_SystemF $ TyExpr_Var loc.b
    lhs.res    = CaseType loc.exp_a loc.exp_b
    lhs.pre    = (TyIndex_Group loc.a TyScheme_Bottom):(TyIndex_Group loc.b TyScheme_Bottom):lhs.pre
    lhs.frs    = loc.frs2
    lhs.sub    = empty
    
datasem DataFields monad IO
  clause Cons
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = empty
    
datasem DataField monad IO
  clause Field
    lhs.ty = loc.tyExpr
    
datasem DataConstr monad IO
  clause Constr
    lhs.ty = (loc.conNm, foldr mkArrow lhs.nm fields.ty)
    
datasem DataConstrs monad IO
  clause Cons
    hd.nm = lhs.nm
    tl.nm = lhs.nm
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem RecPatExpr monad IO
  default? var_nm = const empty
  default? sub = const empty
  default? pre = last
  default? frs = last
  default? res = const Nothing
  default? env = last
  clause Empty
    lhs.res = return RowTyExpr_Empty
  clause Expr
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr

    patExpr.env = lhs.env
    patExpr.exp = loc.patExpr
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    lhs.var_nm = patExpr.var_nm
    lhs.env    = patExpr.env
    lhs.sub    = patExpr.sub
    lhs.frs    = patExpr.frs
    lhs.pre    = patExpr.pre
  clause Ext
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    lhs.var_nm = recPatExpr.var_nm ++ patExpr.var_nm
    
    recPatExpr.pre = lhs.pre
    recPatExpr.env = lhs.env
    recPatExpr.frs = lhs.frs
    
    patExpr.exp = loc.patExpr
    patExpr.pre = recPatExpr.pre
    patExpr.env = recPatExpr.env
    patExpr.frs = recPatExpr.frs
    
    (loc.q1, loc.frs, loc.res)
            = let e = recPatExpr.res
                  t = return patExpr.res
              in case (e, t) of
                   (Nothing, _) -> error $ "Cannot infer the type of tuple element '" ++ pp loc.mbNm ++ "'"
                   (_, Nothing) -> error $ "Cannot infer the type of the expression '" ++ pp loc.patExpr ++ "'"
                   (Just rty,Just ty) -> let (typ, frs, _) = renameBound patExpr.frs ty 
                                             (q, e)        = second (\ty'->RowTyExpr_Ext rty loc.mbNm ty') (deep_explode' patExpr.pre typ) 
                                         in (q, frs, e)
                   
    lhs.sub = recPatExpr.sub `munion` patExpr.sub
    lhs.res = return loc.res
    lhs.frs = loc.frs
    lhs.pre = loc.q1
    lhs.env = patExpr.env
    
datasem PatExpr monad IO
  default? res = const (error "This PatExpr does not have a type")
  default? sub = const empty
  default? pre = last
  default? frs = last
  default? env = last
  default? var_nm = const empty
  clause IConst
     lhs.res = TyScheme_SystemF $ TyExpr_Con $ mkName "Int"
  clause CConst
     lhs.res = TyScheme_SystemF $ TyExpr_Con $ mkName "Char"
  clause Con
     loc.res = maybe (error $ "Constructor '" ++ pp loc.nm ++ "' not found in lookup") id $ lookup loc.nm (unGam lhs.env)
     (lhs.res, lhs.frs, lhs.pre) = let (e,i,_) = renameBound lhs.frs loc.res
                                       (q, e') = deep_explode lhs.pre e
                                   in trace ("Con: Renaming " ++ pp loc.nm ++ " to " ++ pp e) (e', i, q)
  clause Var
    lhs.var_nm = return loc.nm
    
    (loc.a, loc.frs1) = fresh lhs.frs
    loc.exp_a  = mkVar loc.a
    lhs.res    = loc.exp_a
    lhs.env    = Gamma $ minsert loc.nm loc.exp_a (unGam lhs.env)
    lhs.pre    = (TyIndex_Group loc.a TyScheme_Bottom):lhs.pre
    lhs.frs    = loc.frs1
  clause VarAs
    lhs.var_nm = return loc.nm
    
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    lhs.pre = patExpr.pre
    lhs.frs = patExpr.frs
    lhs.env = Gamma $ minsert loc.nm patExpr.res (unGam patExpr.env)
    lhs.res = patExpr.res
  clause App
    loc.frs            = lhs.frs
    (loc.a1, loc.frs1) = fresh loc.frs
    (loc.a2, loc.frs2) = fresh loc.frs1
    (loc.b , loc.frs3) = fresh loc.frs2
    
    child func : PatExpr
    func.ast = loc.func
    func.exp = loc.func
    func.frs = loc.frs3
    func.pre = lhs.pre
    func.env = lhs.env
    
    (loc.func_pre, loc.func_res) = let e = deep_explode func.pre func.res
                                   in trace ("PatExpr:[App]:[Func]    " ++ pp e) e
    
    child arg : PatExpr
    arg.ast = loc.arg
    arg.exp = loc.arg
    arg.frs = func.frs
    arg.pre = loc.func_pre
    arg.env = appAll func.sub func.env
    
    (loc.arg_pre, loc.arg_res) = let e = deep_explode arg.pre arg.res
                                 in trace ("PatExpr:[App]:[Arg]     " ++ pp e) e
    
    (loc.temp1, loc.frt1) = trace ("Extend[1] " ++ pp loc.arg_pre) $ extend (loc.arg_pre, Scheme_Simple loc.a1 (appAll arg.sub loc.func_res), arg.frs) True
    (loc.temp2, loc.frt2) = trace ("Extend[2] " ++ pp (fst loc.temp1)) $ extend (fst loc.temp1, Scheme_Simple loc.a2 (loc.arg_res), loc.frt1) True
    (loc.temp3, loc.frt3) = trace ("Extend[3] " ++ pp (fst loc.temp2)) $ extend (fst loc.temp2, Scheme_Simple loc.b  (TyScheme_Bottom), loc.frt2) True
    
    (loc.q2', loc.e2') = (fst loc.temp3, (snd loc.temp1) `munion` (snd loc.temp2) `munion` (snd loc.temp3) `munion` func.sub)
    
    child u : Unify = unify
    u.pre  = trace ("PatExpr:[App]:[Pre-in]  " ++ pp loc.q2') loc.q2'
    
    u.exp1 = appAll loc.e2' (TyExpr_Var loc.a1)
    u.exp2 = (appAll loc.e2' (TyExpr_Var loc.a2)) `mkArrow` (TyExpr_Var loc.b)
    u.frs  = loc.frt3
    
    loc.q3 = trace ("PatExpr:[App]:[Pre-out] " ++ pp u.pre) u.pre
    loc.e3 = trace ("PatExpr:[App]:[Env]     " ++ pp u.sub) u.sub
    
    (loc.q4, loc.q5) = curry split loc.q3 (domain lhs.pre)
    
    lhs.res = let b = TyExpr_Var loc.b
                  e = appAll (loc.e3 `munion` loc.e2') b
                  f = ptype $ desugar $ TyScheme_Sugar loc.q5 (TyScheme_SystemF e)
              in trace ("PatExpr:[App]:[Res]     " ++ pp f ++ "\n\t" ++ pp loc.q4 ++ "\n\t" ++ pp loc.temp_sub) (ptype $ (TyScheme_SystemF e))
    loc.temp_sub = let subs = func.sub `munion` arg.sub -- applyEnv loc.e2' (func.sub `munion` arg.sub)
                   in subs `munion` loc.e3 -- added union
    lhs.sub = loc.temp_sub
    lhs.pre = loc.q3 -- loc.q4
    lhs.frs = u.frs
    
    loc.sub = let x = nub (domain loc.q3)
              in loc.temp_sub `remove` x
              
    lhs.env = let e = appAll loc.sub arg.env
              in trace ("Renaming: " ++ pp arg.env ++ "\n\tUsing: " ++ pp loc.sub ++ "\n\tto " ++ pp e ) e 
    
    lhs.var_nm = func.var_nm `munion` arg.var_nm
  clause AppTop
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre

    lhs.var_nm = patExpr.var_nm
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.pre = patExpr.pre
    lhs.env = patExpr.env
    lhs.frs = patExpr.frs
  clause Parens
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre

    lhs.var_nm = patExpr.var_nm
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.pre = patExpr.pre
    lhs.env = patExpr.env
    lhs.frs = patExpr.frs
  clause Ann
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    lhs.var_nm = patExpr.var_nm 
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.env = patExpr.env
    lhs.pre = patExpr.pre
    lhs.frs = patExpr.frs
  clause TypeAs
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    patExpr.env = lhs.env
    patExpr.exp = loc.patExpr
    patExpr.pre = lhs.pre
    patExpr.frs = lhs.frs
    
    lhs.var_nm = patExpr.var_nm
    
    child t : TypeAs = typeAs
    t.env = patExpr.env
    t.pre = patExpr.pre
    t.frs = patExpr.frs
    t.ty  = patExpr.res
    t.exp = loc.tyExpr    

    lhs.frs = t.frs
    lhs.env = Gamma $ foldl (.) id (zipWith minsert patExpr.var_nm (repeat $ TyScheme_SystemF t.ty)) (unGam t.env)
    lhs.res = TyScheme_SystemF $ TyExpr_Parens t.ty -- segfault @#$&^@#^%$
    lhs.sub = patExpr.sub `munion` t.sub
    lhs.pre = t.pre
  clause SConst
    lhs.var_nm = error "SConst not a var"
  clause Rec
    child recPatExpr : RecPatExpr
    recPatExpr.ast = loc.recPatExpr
    
    lhs.var_nm = recPatExpr.var_nm
    
    recPatExpr.pre = lhs.pre
    recPatExpr.env = lhs.env
    recPatExpr.frs = lhs.frs
    
    loc.res = let e = recPatExpr.res
              in case e of
                   Nothing -> error "Type inference failed in tuple"
                   Just ty -> TyExpr_AppTop $
                                 TyExpr_App
                                    (TyExpr_Con (mkName "_Rec"))
                                    (TyExpr_Row ty)
                                    
    (loc.q1, loc.q2) = split (recPatExpr.pre, domain lhs.pre)
    -- lhs.res = ptype $ desugar $ TyScheme_Sugar loc.q2  $ TyScheme_SystemF loc.res
    lhs.res = ptype $ TyScheme_SystemF loc.res
    -- lhs.res = TyScheme_SystemF loc.res
    lhs.sub = recPatExpr.sub
    -- lhs.pre = loc.q1
    lhs.pre = recPatExpr.pre
    lhs.frs = recPatExpr.frs
    lhs.env = recPatExpr.env
  clause DataFields
    lhs.var_nm = error "DataFields not a var"
  clause Irrefutable 
    lhs.var_nm = error "Irrefutable not a var"
    
datasem Decl monad IO
  default? sub = const []
  default? pre = last
  default? frs = last
  default? sig = last
  default? env = last
  clause Val
    match PatExpr.Var@loc = loc.patExpr
    
    expr.pre = lhs.pre
    expr.env = lhs.env
    expr.exp = loc.expr
    expr.frs = lhs.frs
    
    loc.env           = unGam lhs.env
    loc.ty            = fromJust $ lookup loc.nm (unGam lhs.env)
    loc.declared      = lookup loc.nm (unGam lhs.sig)
    loc.isNotDeclared = isJust loc.declared
    
    loc.inferred' = case expr.res of
                      Nothing -> error  $ "Inference failed datasem Decl clause Val. No result"
                      Just x  -> trace ("** " ++ pp loc.nm ++ ": " ++ pp x ++ "\ntSubs: " ++ pp expr.sub) x -- update the Gamma
     
    (loc.q1, loc.irTy) = deep_explode expr.pre $ addQuantifiers $ appAll expr.sub loc.ty
    
    child u : UnifyScheme = unifyScheme
    u.pre = loc.q1
    u.ty2 = loc.inferred'
    u.ty1 = loc.irTy
    u.frs = expr.frs
    
    loc.inferred = let e = applyUpdate u.sub loc.inferred'
                   in trace ("!! Updating: " ++ pp loc.inferred' ++ "\n\tTo: " ++ pp e ++ "\n\tUsing: " ++ pp u.sub) e
    lhs.pre = expr.pre
    
    loc.sub = expr.sub `pick` u.sub
    loc.gam = Gamma $ minsert loc.nm loc.inferred loc.env
    
    -- TODO: Find out if this is really needed
    -- only send up the substitutions that we need
    loc.e1 = let x = nub (domain lhs.pre)       -- find the subtitutions we still might need
                 d = applyEnv loc.sub loc.sub -- resolve any chained subtitutions
             in filter ((`elem` x).fst) d       -- return only the substitutions needed 
             
    lhs.sub = loc.e1
                   
    -- the let bindings are preprocessed. So is the nf of the inferred type for a binding is _|_ the inferrence
    -- hasn't been done. and also we *can't* infer it here. So we defer this action.
    internal is_inferred
       clause already_inferred1
         match True = loc.isNotDeclared
         loc.declared' = fromJust loc.declared
         loc.dcl = ftype loc.declared'
        
         child s : Subsume = subsume
         s.pre = trace ("Checking '" ++ pp loc.inferred ++ "' against '" ++ (pp $ clean loc.dcl) ++ "' in bind '" ++  pp loc.nm ++ "'") lhs.pre
         s.ty  = loc.inferred
         s.exp = loc.dcl
         s.frs = u.frs
        
         lhs.frs = s.frs -- we don't really need the frs, but we're faking the dependency to insure that it's executed
         lhs.env = scope lhs.env (Gamma $ minsert loc.nm loc.declared' loc.env)
       clause isNot_inferred 
         match False = loc.isNotDeclared
         lhs.frs = u.frs
         lhs.env = scope lhs.env (loc.gam)
  clause TySig
    -- (loc.ty, loc.frs, _) = renameVars lhs.frs (mkQuantified loc.tyExpr)
    loc.env      = unGam lhs.env
    loc.inferred = maybe (error $ "Type signature given without let binding '" ++ pp loc.nm ++ "'") id (lookup loc.nm loc.env)

    loc.vars     = nub $ ftv loc.tyExpr
    loc.declared = let tyExpr = simplify loc.tyExpr
                   in case null loc.vars of
                       True  -> tyExpr
                       False -> foldl (.) id (map (TyExpr_Quant tyQu_Forall) loc.vars) tyExpr

    (loc.dcl, loc.frs, _) = renameBound lhs.frs (embedF loc.declared) 
    -- the let bindings are preprocessed. So is the nf of the inferred type for a binding is _|_ the inferrence
    -- hasn't been done. and also we *can't* infer it here. So we defer this action.
    loc.isNotInferred = isBottom $ nf loc.inferred
    internal is_inferred
       clause already_inferred
         match False = loc.isNotInferred
        
         child s : Subsume = subsume
         s.pre = trace ("Checking '" ++ pp loc.inferred ++ "' against '" ++ pp loc.declared ++ "'") lhs.pre
         s.ty  = loc.inferred
         s.exp = loc.declared
         s.frs = loc.frs
        
         lhs.frs = s.frs -- we don't really need the frs, but we're faking the dependency to insure that it's executed
         lhs.env = Gamma $ minsert loc.nm loc.dcl loc.env  -- update the Gamma
       clause not_inferred
         match True = loc.isNotInferred
         lhs.frs = loc.frs
         lhs.sig = Gamma $ minsert loc.nm loc.dcl (unGam lhs.sig)  -- update the Sig list
       
  clause Data
     child constrs : DataConstrs
     constrs.ast = loc.constrs
     loc.nm = let vars = map (\(TyVar_Var x) -> TyExpr_Var x) loc.tyVars
              in  foldl TyExpr_App (TyExpr_Con loc.tyNm) vars
     (TyScheme_SystemF constrs.nm, lhs.frs, loc.sub) = renameVars lhs.frs (TyScheme_SystemF loc.nm)
     
     lhs.env = Gamma $ (foldr (.) id . map (\(k,v)->minsert k (mkQuantified $ appAll loc.sub v))) constrs.ty (unGam lhs.env) -- update the Gamma
  clause FFI
     (TyScheme_SystemF loc.tyExprRen, lhs.frs, _) = renameVars lhs.frs (TyScheme_SystemF loc.tyExpr)
     loc.vars = nub $ ftv loc.tyExprRen
     loc.exp = let tyExpr = simplify loc.tyExprRen
               in case null loc.vars of
                   True  -> tyExpr
                   False -> foldl (.) id (map (TyExpr_Quant tyQu_Forall) loc.vars) tyExpr
     lhs.env = Gamma $ minsert loc.nm (embedF loc.exp) (unGam lhs.env) -- update the Gamma
  clause KiSig
     lhs.env = lhs.env
    
datasem Decls monad IO
  default? sub = const empty
  default? env = last
  default? sig = last
  default? pre = last
  default? frs = last
  clause Cons
    hd.pre     = lhs.pre
    hd.env     = lhs.env
    hd.frs     = lhs.frs
    hd.sig     = lhs.sig
    
    tl.env     = hd.env
    tl.pre     = hd.pre
    tl.frs     = hd.frs
    tl.sig     = hd.sig
    
    lhs.pre       = tl.pre
    lhs.sub       = hd.sub `munion` tl.sub
    lhs.frs       = tl.frs
    lhs.env       = tl.env
    lhs.sig       = tl.sig
  clause Nil
       
datasem Expr monad IO
    default? sub = const empty
    default? pre = last
    default? frs = last
    default? res = const Nothing
    clause Var
        (lhs.res, loc.frs)
             = case lookup loc.nm (unGam lhs.env) of
                Just a  -> (return a, lhs.frs)
                Nothing -> error $ "Variable '" ++ show loc.nm ++ "' not in scope"
        lhs.frs = loc.frs
    clause IConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Int"
    clause CConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Char"
    clause Con
       loc.res = maybe (error $ "Constructor '" ++ pp loc.nm ++ "' not found in lookup") id $ lookup loc.nm (unGam lhs.env)
       (loc.res2, lhs.frs, _) = let e = renameBound lhs.frs loc.res
                                in trace ("Con: Renaming " ++ pp loc.nm ++ " to " ++ (\(a,_,_) -> pp a) e) e
       lhs.res = return loc.res2
    clause App
       loc.frs            = lhs.frs
       (loc.a1, loc.frs1) = fresh loc.frs
       (loc.a2, loc.frs2) = fresh loc.frs1
       (loc.b , loc.frs3) = fresh loc.frs2
       
       func.exp = loc.func
       func.frs = loc.frs3
       func.pre = lhs.pre
       func.env = lhs.env
       
       match True = isJust func.res
       
       (loc.func_pre, loc.func_res) = let e = explode func.pre (fromJust func.res)
                                      in trace ("App:[Func]    " ++ pp e) e
       -- loc.func_res = let e = fromJust func.res
                      -- in trace ("App:[Func]    " ++ pp e) e
       
       arg.exp = loc.arg
       arg.frs = func.frs
       arg.pre = loc.func_pre
       
       arg.env = appAll func.sub lhs.env
       
       match True = isJust arg.res
       
       -- These break higher-rank functions, They need to be pushed in the Env as is.
       (loc.arg_pre, loc.arg_res) = let e = explode arg.pre (fromJust arg.res)
                                    in trace ("App:[Arg]     " ++ pp e) e
       -- loc.arg_res = let e = fromJust arg.res
                     -- in trace ("App:[Arg]     " ++ pp e) e
       
       (loc.temp1, loc.frt1) = trace ("Extend[1] " ++ pp arg.pre) $ extend (loc.arg_pre, Scheme_Simple loc.a1 (appAll arg.sub loc.func_res), arg.frs) True
       (loc.temp2, loc.frt2) = trace ("Extend[2] " ++ pp (fst loc.temp1)) $ extend (fst loc.temp1, Scheme_Simple loc.a2 (loc.arg_res), loc.frt1) True
       (loc.temp3, loc.frt3) = trace ("Extend[3] " ++ pp (fst loc.temp2)) $ extend (fst loc.temp2, Scheme_Simple loc.b  (TyScheme_Bottom), loc.frt2) True
       
       (loc.q2', loc.e2') = (fst loc.temp3, (snd loc.temp1) `munion` (snd loc.temp2) `munion` (snd loc.temp3) `munion` func.sub)
       
       child u : Unify = unify
       u.pre  = trace ("App:[Pre-in]  " ++ pp loc.q2') loc.q2'
       
       u.exp1 = appAll loc.e2' (TyExpr_Var loc.a1)
       u.exp2 = (appAll loc.e2' (TyExpr_Var loc.a2)) `mkArrow` (TyExpr_Var loc.b)
       u.frs  = loc.frt3
       
       loc.q3 = trace ("App:[Pre-out] " ++ pp u.pre) u.pre
       loc.e3 = trace ("App:[Env]     " ++ pp u.sub) u.sub
       
       (loc.q4, loc.q5) = curry split loc.q3 (domain lhs.pre)
    
       lhs.res = let b = TyExpr_Var loc.b
                     e = appAll (loc.e3 `munion` loc.e2') b
                     f = return $ ptype $ desugar $ TyScheme_Sugar loc.q5 (TyScheme_SystemF e)
                 in trace ("App:[Res]     " ++ pp f ++ "\n\t" ++ pp loc.q4 ++ "\n\t" ++ pp loc.temp_sub) f
       loc.temp_sub = let subs = func.sub `munion` arg.sub -- applyEnv loc.e2' (func.sub `munion` arg.sub)
                      in subs `munion` loc.e3 -- added union
       lhs.sub = loc.temp_sub
       lhs.pre = loc.q4
       lhs.frs = u.frs
    clause Let
        -- | Preprocess the binds to fill the environemnt
        (loc.frs, loc.binds)  = let nms         = getBindLHs loc.decls
                                    (vars, frs) = freshM lhs.frs (length nms)
                                in (frs, zipWith (\a b->(a, mkQVar b)) nms vars)
        loc.env   = Gamma $ foldr (.) id (map (\(k,v)->minsertUnique k v) loc.binds) (unGam lhs.env) -- temporaty update the environment. this will later be updated
        
        decls.pre = lhs.pre
        decls.env = loc.env
        decls.frs = loc.frs
        decls.sig = Gamma empty

        body.pre = decls.pre
        body.env = decls.env -- make sure bindings don't leak out, only top level bindings are allowed
        body.exp = loc.body
        body.frs = decls.frs

        lhs.pre = body.pre
        lhs.res = body.res
        lhs.sub = decls.sub `munion` body.sub
        lhs.frs = body.frs
        -- Add check for empty Sig
    clause Lam
        child arg : PatExpr
        arg.ast = loc.arg
        arg.env = lhs.env
        arg.pre = lhs.pre
        arg.exp = loc.arg
        arg.frs = lhs.frs
   
       loc.exp_a = ftype arg.res
       
       -- (TyScheme_SystemF loc.exp_a) = arg.res
       -- loc.exp_a = let e = ftype arg.res
                   -- in trace ("Arg: " ++ pp e ++ "\n\t" ++ pp arg.env) e
       (loc.b, loc.frs2) = let e = fresh arg.frs
                           in trace ("Lam:[Arg]: " ++ pp loc.exp_a ++ "\n\t" ++ pp loc.env') e
       -- loc.q'            = arg.pre
       loc.env'          = appAll arg.sub arg.env -- update the bindings with what's occured in the patexpr.
       
       body.frs = loc.frs2
       body.env = loc.env'
       body.pre = arg.pre
       body.exp = loc.body
       
       loc.env_full = arg.sub `munion` body.sub
       
       loc.tau = let x = appAll loc.env_full loc.exp_a
                 in if isUnQualTy x || not (isVar loc.arg)
                       then x
                       else error "The resulting type is not a Tau type"
                       
       loc.phi1 = case body.res of
                     Nothing -> error "Inference of Expressions failed in Lam, no type infered for body"
                     Just x  -> trace ("Body: " ++ pp x ++ "\n\t" ++ pp body.pre ++ " (" ++ pp (domain lhs.pre) ++ ") \n\t" ++ pp loc.env_full) x

       (loc.q2,  loc.q3)  = curry split body.pre (domain lhs.pre)
                              
       (loc.q3_, loc.phi1') = deep_explode loc.q3 loc.phi1
       
       ((loc.q3', loc.e3'), loc.frs') = extend (loc.q3_, (Scheme_Simple loc.b loc.phi1'), body.frs) False
       
       lhs.res = let b'    = appAll loc.e3' (TyExpr_Var loc.b)
                     a'    = appAll body.sub loc.exp_a -- (TyExpr_Var loc.a)
                     arrow = a' `mkArrow` b'
                     e = ptype $ desugar $ TyScheme_Sugar loc.q3' (TyScheme_SystemF arrow)
                 in trace ("Body:[Res] " ++ pp e) $ return e
       lhs.sub = body.sub
       lhs.pre = loc.q2
       lhs.frs = loc.frs'
    clause AppTop
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.pre = expr.pre
       lhs.frs = expr.frs
    clause Parens
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.pre = expr.pre
       lhs.frs = expr.frs
    clause TypeAs
       expr.env = lhs.env
       expr.exp = loc.expr
       expr.pre = lhs.pre
       expr.frs = lhs.frs
       
       child t : TypeAs = typeAs
       t.env = lhs.env
       t.pre = expr.pre
       t.frs = expr.frs
       t.ty  = maybe (error $ "Type inference of expression '" ++ pp loc.expr ++ "' failed in Case") id expr.res
       t.exp = loc.tyExpr   
       
       lhs.frs = t.frs -- we don't really need the frs, but we're faking the dependency to insure that it's executed
       lhs.res = trace ("Returning: " ++ pp t.ty) $ return $ TyScheme_SystemF $ TyExpr_Parens t.ty
       lhs.sub = let e = expr.sub `munion` t.sub
                 in  trace ("TypeAs:[Sub] " ++ pp e ) e
       lhs.pre = t.pre
    clause Ann
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.pre = expr.pre
       lhs.frs = expr.frs
    clause AppImpred
       arg.env = lhs.env
       arg.exp = loc.arg
       
       func.env = lhs.env
       func.exp = loc.func
    clause Case
       expr.env = lhs.env
       expr.pre = lhs.pre
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       child alts : CaseAlts
       
       loc.etype = maybe (error $ "Type inference of expression '" ++ pp loc.expr ++ "' failed in Case") id expr.res
       -- (loc.q, loc.frs, loc.type) = deep_explode expr.pre expr.frs loc.etype
       
       alts.ast = loc.alts
       alts.exp = loc.etype
       alts.env = let e = appAll expr.sub lhs.env in trace (pp e) e
       alts.frs = expr.frs
       alts.pre = trace ("Case Expr - " ++ pp loc.expr ++ ":" ++ pp loc.etype ++ "% " ++ pp expr.pre) expr.pre
       
       child s : UnifyScheme = unifyScheme
       s.pre = alts.pre
       s.ty1 = loc.etype
       s.ty2 = caseLHS alts.res
       s.frs = alts.frs
       
       (loc.q1, loc.q2) = split (s.pre, domain lhs.pre)
       
       lhs.res = return $ let e = ptype $ desugar $ TyScheme_Sugar loc.q2 $ appAll alts.sub $ body alts.res in trace ("Case done:" ++ pp e) e
       lhs.sub = trace ("Case alts: " ++ pp alts.sub) $ s.sub `pick` alts.sub `pick` expr.sub
       lhs.pre = loc.q1
       lhs.frs = s.frs
    clause CaseAltFail
       (loc.a, lhs.frs) = fresh lhs.frs
       loc.vari = mkQuantified $ TyExpr_Var loc.a
       lhs.res  = return loc.vari
    clause DataFields
    clause Rec
       child recExpr : RecExpr
    
       recExpr.pre = lhs.pre
       recExpr.env = lhs.env
       recExpr.frs = lhs.frs
       recExpr.ast = loc.recExpr
       
       loc.res = let e = recExpr.res
                 in case e of
                      Nothing -> error "Type inference failed in tuple"
                      Just ty -> TyExpr_AppTop $
                                    TyExpr_App
                                       (TyExpr_Con (mkName "_Rec"))
                                       (TyExpr_Row ty)
       
       (loc.q1, loc.q2) = split (recExpr.pre, domain lhs.pre)
       lhs.res = return $ ptype $ desugar $ TyScheme_Sugar loc.q2 $ TyScheme_SystemF loc.res
       -- lhs.res = return $ TyScheme_SystemF loc.res
       lhs.sub = recExpr.sub
       lhs.pre = loc.q1
       -- lhs.pre = recExpr.pre
       lhs.frs = recExpr.frs
    clause SConst
    clause Sel
       expr.env = lhs.env
       expr.exp = loc.expr
    clause Undefined
       (loc.a, lhs.frs) = fresh lhs.frs
       lhs.res = return $ mkQuantified $ TyExpr_Var loc.a
       
datasem RecExpr monad IO
    default? sub = const empty
    default? pre = last
    default? frs = last
    default? res = const Nothing
    clause Ext
       recExpr.pre = lhs.pre
       recExpr.env = lhs.env
       recExpr.frs = lhs.frs
       
       expr.exp = loc.expr
       expr.pre = recExpr.pre
       expr.env = appAll recExpr.sub lhs.env -- update bindings for e.g. \f -> f 1, f 'a')
       expr.frs = recExpr.frs
       
       (loc.q1, loc.frs, loc.res)
               = let e = recExpr.res
                     t = expr.res
                 in case (e, t) of
                      (Nothing, _) -> error $ "Cannot infer the type of tuple element '" ++ pp loc.mbNm ++ "'"
                      (_, Nothing) -> error $ "Cannot infer the type of the expression '" ++ pp loc.expr ++ "'"
                      (Just rty,Just ty) -> let (typ, frs, _) = renameBound expr.frs ty 
                                                (q,   e     ) = second (\ty'->RowTyExpr_Ext rty loc.mbNm ty') (deep_explode' expr.pre typ)
                                            in (q, frs, e)
                                            
       lhs.sub = recExpr.sub `munion` expr.sub
       lhs.res = return loc.res
       lhs.frs = loc.frs
       lhs.pre = loc.q1
    clause Empty
       lhs.res = return RowTyExpr_Empty
    clause Upd
       expr.env = lhs.env
       expr.exp = loc.expr
       recExpr.env = lhs.env
       
       lhs.res = Nothing
    clause Expr
       expr.env = lhs.env
       expr.exp = loc.expr
       
itf Unify
  visit unify
    inh pre  :: Prefix
    inh exp1 :: TyExpr
    inh exp2 :: TyExpr
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn frs  :: Int

itf Subsume
  visit subsume
    inh pre  :: Prefix
    inh exp  :: TyExpr
    inh ty   :: TyScheme
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn frs  :: Int
    
itf UnifyScheme
  visit unifyScheme
    inh pre  :: Prefix
    inh ty1  :: TyScheme
    inh ty2  :: TyScheme
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn ty   :: TyScheme
    syn frs  :: Int         
    
itf RowTyExpr
  visit unifyRows
    inh pre :: Prefix
    inh ty1 :: RowTyExpr
    inh ty2 :: RowTyExpr
    inh frs :: Int
    syn pre :: Prefix
    syn res :: RowTyExpr
    syn frs :: Int
    syn sub :: Env
 
itf TypeAs
  visit typeAs
    inh pre :: Prefix
    inh env :: Gamma
    inh ty  :: TyScheme
    inh exp :: TyExpr
    inh frs :: Int
    syn pre :: Prefix
    syn frs :: Int
    syn env :: Gamma
    syn sub :: Env
    syn ty  :: TyExpr -- res cauzes issues
    
{
typeAs = sem typeAs : TypeAs monad IO
           visit typeAs
             default? frs = last
             default? pre = last
             default? env = last
             default? sub = const empty
             clause variable
                (loc.pre, loc.ty) = deep_explode lhs.pre lhs.ty
                match TyScheme.SystemF@ty  = loc.ty
                match TyExpr.Var@vari      = ty.tyExpr
                lhs.ty  = trace ("TypeAs Variable match. Returning wild: " ++ pp loc.sub) $ mkQuant lhs.exp
                -- lhs.ty  = trace "TypeAs Variable match. Returning wild" $ lhs.ty -- mkQuant lhs.exp
                loc.sub = (vari.nm, mkQuantified lhs.exp)
                (lhs.pre, lhs.sub) = update (lhs.pre, Right loc.sub)
                lhs.env = app loc.sub lhs.env
             clause other
                loc.inferred = lhs.ty
                loc.declared = mkQuant lhs.exp
                
                child s : Subsume = subsume
                s.pre = trace ("Checking '" ++ pp loc.inferred ++ "' against '" ++ pp loc.declared ++ "'") lhs.pre
                s.ty  = let e = loc.inferred in trace ("Inferred Scheme: " ++ sche e) e
                s.exp = loc.declared
                s.frs = lhs.frs
                
                lhs.frs = s.frs -- we don't really need the frs, but we're faking the dependency to insure that it's executed
                lhs.ty  = loc.declared
                lhs.sub = s.sub
                lhs.pre = s.pre
                lhs.env = trace "TypeAs done" $ appAll s.sub lhs.env
               

unifyRows = sem unifyRows : RowTyExpr monad IO
              visit unifyRows
                default? frs = last
                default? pre = last
                default? sub = const empty
                clause empty
                    match RowTyExpr.Empty@e1 = lhs.ty1
                    match RowTyExpr.Empty@e2 = lhs.ty2
                    
                    lhs.res = RowTyExpr_Empty
                clause ext
                    match RowTyExpr.Ext@ext1 = lhs.ty1
                    match RowTyExpr.Ext@ext2 = lhs.ty2
                    
                    loc.ext1 = embedF ext1.tyExpr
                    loc.ext2 = embedF ext2.tyExpr
                    
                    child u : UnifyScheme = unifyScheme
                    
                    u.pre = lhs.pre
                    u.frs = lhs.frs 
                    u.ty1 = trace ("%1: " ++ pp loc.ext1) $ loc.ext1
                    u.ty2 = trace ("%2: " ++ pp loc.ext2) $ loc.ext2
                    
                    child row : RowTyExpr = unifyRows
                    
                    row.pre = u.pre
                    row.frs = u.frs
                    row.ty1 = appAll u.sub ext1.rowTyExpr
                    row.ty2 = appAll u.sub ext2.rowTyExpr    
                    
                    (loc.q, loc.ty) = explode' row.pre u.ty
                    loc.sub = row.sub `pick` u.sub
                    (loc.q1, loc.q2) = split (loc.q, domain loc.sub)
                    
                    lhs.pre = loc.q2
                    lhs.frs = row.frs
                    lhs.sub = loc.sub
                    lhs.res = RowTyExpr_Ext row.res ext1.mbNm loc.ty
                clause mismatch
                    lhs.res = error $ "mismatch between rows '" ++ pp lhs.ty1 ++ "' and '" ++ pp lhs.ty2 ++ "'"

unifyScheme = sem unifyScheme : UnifyScheme monad IO
                visit unifyScheme
                  default? pre = last
                  default? frs = last
                  default? sub = const empty
                  clause Main_unifyScheme
                      loc.b1 = isBottom lhs.ty1
                      loc.b2 = isBottom lhs.ty2
                      internal bot_check
                        clause first_bottom
                            match True = loc.b1
                            (loc.q, loc.tyx) = splitQuant lhs.ty2
                            lhs.ty     = nf lhs.ty2
                        clause second_bottom
                            match True = loc.b2
                            (loc.q, loc.tyx) = splitQuant lhs.ty1
                            lhs.ty     = nf lhs.ty1
                        clause norm
                            match False = loc.b1 || loc.b2
                            match TyScheme.Sugar@exp1 = sugar $ nf lhs.ty1
                            match TyScheme.Sugar@exp2 = sugar $ nf lhs.ty2
                              
                            loc.q = lhs.pre
                                
                            child u : Unify = unify
                                
                            u.pre  = loc.q ++ exp1.prefix ++ exp2.prefix
                            u.exp1 = let x = dropScheme exp1.tyExpr
                                     in trace ("U1: " ++ pp x ++ " = " ++ con x) x
                            u.exp2 = let x = dropScheme exp2.tyExpr
                                     in trace ("U2: " ++ pp x ++ " = " ++ con x) x
                            u.frs  = lhs.frs
                                
                            loc.q3 = u.pre
                            loc.e3 = u.sub
                                
                            (loc.q4, loc.q5) = split (loc.q3, domain loc.q)
                                
                            lhs.frs = u.frs
                            lhs.pre = loc.q4
                            lhs.sub = loc.e3
                            lhs.ty  = let ty  = appAll loc.e3 exp1.tyExpr
                                          ret = TyScheme_Sugar loc.q5 ty
                                      in ptype $ desugar ret

subsume = sem subsume : Subsume monad IO 
             visit subsume
               default? pre = last
               default? frs = last
               clause Main_subsume
                loc.ty   = lhs.ty -- nf lhs.ty
                loc.nfTy = isNf lhs.exp
                loc.nfTs = isNf loc.ty
                loc.nf   = loc.nfTy && loc.nfTs
                internal nf_check
                    clause s_subsume
                      match True                  = loc.nf
                      match TyExpr.Forall@exp     = mkForall lhs.exp
                      match TyScheme.Sugar@scheme = sugar loc.ty
                      
                      loc.q  = lhs.pre
                      loc.q2 = scheme.prefix
                      
                      child u : Unify = unify
                      
                      (loc.c, loc.frs1) = freshS lhs.frs (length exp.tyVar)
                      loc.qq2 = loc.q ++ loc.q2
                      
                      loc.p1 = dropScheme scheme.tyExpr
                      loc.p2 = appAll (zipWith (\a b->(a, mkSkolem b)) exp.tyVar loc.c) exp.tyExpr
                      
                      u.pre  = loc.qq2
                      
                      u.exp1 = loc.p1
                      u.exp2 = loc.p2
                      u.frs  = loc.frs1
                      
                      loc.q1 = u.pre
                      loc.e1 = u.sub
                      
                      (loc.q3, loc.q4) = split (loc.q1, domain loc.q)
                      loc.e2 = let x = nub (domain loc.q4)
                               in loc.e1 `remove` x
                      loc.codom = nub $ skolems loc.e2 ++ skolems loc.q3
                      loc.check = any (`elem` loc.codom) loc.c
                      
                      internal skol_check
                        clause succeeded
                          match False  = loc.check
                          lhs.pre = loc.q3
                          lhs.sub = trace ("Instantiation Env: " ++ pp loc.e2 ++ "\nFull Env: " ++ pp loc.e1) loc.e2
                          lhs.frs = u.frs
                        clause failed
                          match (loc.bla, True) = ((), loc.check)
                          lhs.sub = const (error $ "Subsume failure, Could not instatiate because doing so would leak the skolems " ++ pp loc.codom ++ " into the environment.") loc.bla
                    
                    clause wild_subsume
                      match True                  = loc.nf
                      match (loc.fo, TyScheme.Bottom@l)     = ((), sugar loc.ty)
                      lhs.sub = empty
                      
                    clause f_subsume
                      match (loc.bla, False) = ((), loc.nf)
                      lhs.sub = const (error $ "Subsume failure, the given type is not in normal form.") loc.bla

unify = sem unify : Unify monad IO    
          visit unify
             default? pre = last
             default? frs = last
             default? sub = const (error "Generic Unify failure")
             clause Main_unify
               loc.nfTy1 = isNf lhs.exp1
               loc.nfTy2 = isNf lhs.exp2
               loc.nf    = let e = loc.nfTy1 && loc.nfTy2
                           in trace ("\tUnify:[1]: " ++ pp lhs.exp1 ++ "\n\tUnify:[2]: " ++ pp lhs.exp2) e
               internal nf_check
                 clause s_unify
                   match True  = loc.nf
                   internal ty_check
                     clause LeftTop
                       match TyExpr.AppTop@app = lhs.exp1
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = app.tyExpr
                       u.exp2 = lhs.exp2
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause RightTop
                       match TyExpr.AppTop@app = lhs.exp2
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = lhs.exp1
                       u.exp2 = app.tyExpr
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause LeftParens
                       match TyExpr.Parens@app = lhs.exp1
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = app.tyExpr
                       u.exp2 = lhs.exp2
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause RightParens
                       match TyExpr.Parens@app = lhs.exp2
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = lhs.exp1
                       u.exp2 = app.tyExpr
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause vars
                       match TyExpr.Var@var1 = lhs.exp1
                       match TyExpr.Var@var2 = lhs.exp2
                       
                       internal case_check
                         clause eq_vars
                           match True = trace "In Variable check" $ var1.nm == var2.nm
                           lhs.sub = empty
                         clause rest_vars
                           loc.q  = lhs.pre
                           loc.p1 = loc.q `contains` var1.nm
                           loc.p2 = loc.q `contains` var2.nm
                           internal var_check
                             loc.isJust    = let e =  isJust loc.p1 && isJust loc.p2
                                             in trace ("Var check: " ++ show e) e 
                             clause pure_var
                               match False = loc.isJust
                               lhs.sub = error $ "Variable check failed. A binding for variable '" ++ pp var1.nm ++ "' or '" ++ pp var2.nm ++ "' was not found in prefix " ++ pp loc.q -- empty 
                             clause ty_var
                               match True  = loc.isJust
                               loc.phi1 = fromJust loc.p1
                               loc.phi2 = fromJust loc.p2
                               loc.exists = let v1 = occursCheck var1.nm loc.q (toScheme loc.phi2)
                                                v2 = occursCheck var2.nm loc.q (toScheme loc.phi1)
                                            in v1 || v2
                               internal dom_check
                                 clause s_dom_check
                                   match True  = loc.exists
                                   lhs.sub = error "Domain check failed in Unify"
                                 clause f_dom_check
                                   match False = loc.exists
                                   
                                   child s : UnifyScheme = unifyScheme
                                   
                                   s.pre = loc.q
                                   s.frs = lhs.frs
                                   s.ty1 = dropQuant loc.phi1
                                   s.ty2 = dropQuant loc.phi2
                                   
                                   loc.q1  = s.pre
                                   loc.e1  = s.sub
                                   loc.phi = s.ty
                                   
                                   (loc.q2, loc.e2) = update (loc.q1, Right (var1.nm, TyScheme_SystemF $ TyExpr_Var var2.nm))
                                   (loc.q3, loc.e3) = update (loc.q2, Left (Scheme_Simple var2.nm loc.phi)) 
                                   
                                   lhs.frs = s.frs
                                   lhs.pre = loc.q3
                                   lhs.sub = let e = loc.e3 `munion'` loc.e2 `munion'` loc.e1
                                             in trace ("Unify:[Sub[Vars]] " ++ pp e) e
                     clause cons
                       match TyExpr.Con@var1 = lhs.exp1
                       match TyExpr.Con@var2 = lhs.exp2
                       
                       loc.eq = var1.nm == var2.nm
                       
                       internal con_check
                          clause succeeded1
                            match True  = loc.eq
                            lhs.sub     = empty
                          clause failed1
                            match False = loc.eq
                            lhs.sub = error $ "Type mismatch, expected '" ++ show var1.nm ++ "' but got '" ++ show var2.nm ++ "'"
                     clause apptype
                       match TyExpr.App@app1 = lhs.exp1
                       match TyExpr.App@app2 = lhs.exp2
                       
                       child uf : Unify = unify
                       
                       uf.frs  = lhs.frs
                       uf.pre  = lhs.pre
                       uf.exp1 = app1.func
                       uf.exp2 = app2.func
                       
                       child ua : Unify = unify
                       
                       ua.frs  = uf.frs
                       ua.pre  = uf.pre
                       ua.exp1 = appAll uf.sub app1.arg
                       ua.exp2 = appAll uf.sub app2.arg
                       
                       lhs.pre = ua.pre
                       lhs.sub = uf.sub `munion` ua.sub
                       
                     clause vartype   
                       internal varchoice
                         clause leftvar
                           match TyExpr.Var@var1 = lhs.exp1
                           loc.expr  = lhs.exp2
                           loc.varnm = var1.nm
                           -- | code duplication, bah, the graph reordering is screwed up
                           loc.q   = lhs.pre
                           loc.phi = loc.q `contains` loc.varnm
                           loc.occurs = occursCheck loc.varnm loc.q (TyScheme_SystemF loc.expr)
                           
                           internal occurs_check
                             clause valid
                               match False = loc.occurs
                               loc.phi' = fromJust loc.phi
                               
                               loc.p = loc.expr
                               
                               child s : Subsume = subsume
                               
                               s.pre = loc.q
                               s.exp = loc.p
                               s.frs = lhs.frs
                               s.ty  = dropQuant loc.phi'
                               
                               (loc.q2, loc.e2) = let a   = appAll s.sub loc.expr
                                                      sub = (loc.varnm, TyScheme_SystemF $ mkTop a) 
                                                  in update (s.pre, Right sub)
                               
                               lhs.pre = loc.q2
                               loc.ret = loc.e2 `munion` s.sub
                               lhs.sub = trace ("Unify:[LeftSub[Vars]] " ++ pp loc.ret) loc.ret
                               lhs.frs = s.frs  
                             clause invalid
                               match True = loc.occurs
                               lhs.sub = error $ "Occurs check: cannot construct the infinite type: " ++ pp loc.varnm ++ " = " ++ pp loc.expr
                               
                         clause rightvar
                           match TyExpr.Var@var2 = lhs.exp2
                           loc.expr  = lhs.exp1
                           loc.varnm = var2.nm
                           -- | code duplication, bah, the graph reordering is screwed up
                           loc.q = lhs.pre
                           loc.phi = loc.q `contains` loc.varnm
                           loc.occurs = occursCheck loc.varnm loc.q (TyScheme_SystemF loc.expr)
                           
                           internal occurs_check
                             clause valid2
                               match False = loc.occurs
                               loc.phi' = fromJust loc.phi
                               
                               loc.p = loc.expr
                               
                               child s : Subsume = subsume
                               
                               s.pre = loc.q
                               s.exp = loc.p
                               s.frs = lhs.frs
                               s.ty  = dropQuant loc.phi'
                               
                               (loc.q2, loc.e2) = let a   = appAll s.sub loc.expr
                                                      sub = (loc.varnm, TyScheme_SystemF $ mkTop a) 
                                                  in update (s.pre, Right sub)
                               
                               lhs.pre = loc.q2
                               loc.ret = loc.e2 `munion` s.sub
                               lhs.sub = trace ("Unify:[RightSub[Vars]] " ++ pp loc.ret) loc.ret
                               lhs.frs = s.frs  
                             clause invalid2
                               match True = loc.occurs
                               lhs.sub = error $ "Occurs check: cannot construct the infinite type: " ++ pp loc.varnm ++ " = " ++ pp loc.expr
                               
                     clause quant
                       match TyExpr.Quant@var1 = lhs.exp1
                       match TyExpr.Quant@var2 = lhs.exp2
                       
                       child u : Unify = unify
                       
                       (loc.c, loc.frs1) = fresh lhs.frs
                       loc.varc = mkSkolem loc.c
                       u.frs  = loc.frs1
                       u.pre  = lhs.pre
                       u.exp1 = app (var1.tyVar, loc.varc) var1.tyExpr
                       u.exp2 = app (var2.tyVar, loc.varc) var2.tyExpr
                       
                       loc.q1 = u.pre
                       loc.e1 = u.sub
                       
                       loc.check = loc.c `elem` (codomain loc.e1 ++ codomain loc.q1)
                       
                       internal skol_check
                          clause succeeded
                            match False  = loc.check
                            lhs.pre = loc.q1
                            lhs.sub = loc.e1
                            lhs.frs = u.frs
                          clause failed
                            match (loc.bla, True) = ((), loc.check)
                            lhs.sub = const (error "Subsume failure, A skolem constant has leaked outside") loc.bla
                     clause rowmatch
                       match TyExpr.Row@row1 = lhs.exp1
                       match TyExpr.Row@row2 = lhs.exp2
                       
                       child rows : RowTyExpr = unifyRows
                       
                       rows.pre = lhs.pre
                       rows.ty1 = row1.rowTyExpr
                       rows.ty2 = row2.rowTyExpr
                       rows.frs = lhs.frs
                       
                       lhs.pre  = trace ("Ty: " ++ pp rows.res ++ " = " ++ pp row1.rowTyExpr ++ " = " ++ pp row2.rowTyExpr ++ " ** " ++ pp rows.sub ++ " -- " ++ pp rows.pre) rows.pre
                       lhs.sub  = rows.sub
                       lhs.frs  = rows.frs
                     clause mismatch
                       lhs.sub = error $   "Could not match expected type '" 
                                        ++ pp (clean lhs.exp1) ++ "' with inferred type '" 
                                        ++ pp (clean lhs.exp2) ++ "'" 
                 clause f_unify
                   match (loc.bla, False) = ((), loc.nf)
                   lhs.sub = const (error "Unify failure, one or both of the TyExpr are not in normal form.") loc.bla
 
typeCheck ::  Expr -> IO ([TyScheme], Env, Prefix, Int)
typeCheck exp = do
  let inh = Inh_Expr_infer { exp_Inh_Expr = exp
                           , env_Inh_Expr = Gamma empty
                           , pre_Inh_Expr = []
                           , ast_Inh_Expr = exp
                           , frs_Inh_Expr = 1
                           }
  syn <- invoke_Expr_infer dnt_Expr inh
  let res = maybe [] return $ res_Syn_Expr syn
      sub = sub_Syn_Expr syn
      pre = pre_Syn_Expr syn
      frs = frs_Syn_Expr syn
  return (res, sub, pre, frs)
  
exampleLet  = Expr_Let False [] (Expr_IConst 3)
exampleLet2 = Expr_Let False [Decl_Val (PatExpr_Var $ mkName "a") (Expr_IConst 3)] (Expr_Var $ mkName "a")
}